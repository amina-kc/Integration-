
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

08000000 <_vector_table>:
 8000000:	20020970 	.word	0x20020970
 8000004:	08002ee9 	.word	0x08002ee9
 8000008:	08004c43 	.word	0x08004c43
 800000c:	08002d91 	.word	0x08002d91
 8000010:	08002d91 	.word	0x08002d91
 8000014:	08002d91 	.word	0x08002d91
 8000018:	08002d91 	.word	0x08002d91
 800001c:	08002d91 	.word	0x08002d91
 8000020:	08002d91 	.word	0x08002d91
 8000024:	08002d91 	.word	0x08002d91
 8000028:	08002d91 	.word	0x08002d91
 800002c:	08002a25 	.word	0x08002a25
 8000030:	08002d91 	.word	0x08002d91
 8000034:	08002d91 	.word	0x08002d91
 8000038:	080029dd 	.word	0x080029dd
 800003c:	08001061 	.word	0x08001061

08000040 <_irq_vector_table>:
 8000040:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000050:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000060:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000070:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000080:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000090:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000a0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000b0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000c0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000d0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000e0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80000f0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000100:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000110:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000120:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000130:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000140:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000150:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000160:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000170:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000180:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 8000190:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001a0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001b0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001c0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001d0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001e0:	08002ec1 08002ec1 08002ec1 08002ec1     ................
 80001f0:	08002ec1 08002ec1                       ........

Disassembly of section _TEXT_SECTION_NAME_2:

080001f8 <__aeabi_uldivmod>:
 80001f8:	b953      	cbnz	r3, 8000210 <__aeabi_uldivmod+0x18>
 80001fa:	b94a      	cbnz	r2, 8000210 <__aeabi_uldivmod+0x18>
 80001fc:	2900      	cmp	r1, #0
 80001fe:	bf08      	it	eq
 8000200:	2800      	cmpeq	r0, #0
 8000202:	bf1c      	itt	ne
 8000204:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000208:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 800020c:	f000 b80c 	b.w	8000228 <__aeabi_idiv0>
 8000210:	f1ad 0c08 	sub.w	ip, sp, #8
 8000214:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000218:	f000 f808 	bl	800022c <__udivmoddi4>
 800021c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000220:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000224:	b004      	add	sp, #16
 8000226:	4770      	bx	lr

08000228 <__aeabi_idiv0>:
 8000228:	4770      	bx	lr
 800022a:	bf00      	nop

0800022c <__udivmoddi4>:
 800022c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000230:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8000232:	4615      	mov	r5, r2
 8000234:	4604      	mov	r4, r0
 8000236:	468e      	mov	lr, r1
 8000238:	461e      	mov	r6, r3
 800023a:	2b00      	cmp	r3, #0
 800023c:	f040 80cc 	bne.w	80003d8 <__udivmoddi4+0x1ac>
 8000240:	428a      	cmp	r2, r1
 8000242:	fab2 fc82 	clz	ip, r2
 8000246:	d94c      	bls.n	80002e2 <__udivmoddi4+0xb6>
 8000248:	f1bc 0f00 	cmp.w	ip, #0
 800024c:	d00b      	beq.n	8000266 <__udivmoddi4+0x3a>
 800024e:	f1cc 0820 	rsb	r8, ip, #32
 8000252:	fa01 fe0c 	lsl.w	lr, r1, ip
 8000256:	fa20 f808 	lsr.w	r8, r0, r8
 800025a:	fa02 f50c 	lsl.w	r5, r2, ip
 800025e:	ea48 0e0e 	orr.w	lr, r8, lr
 8000262:	fa00 f40c 	lsl.w	r4, r0, ip
 8000266:	ea4f 4915 	mov.w	r9, r5, lsr #16
 800026a:	fa1f f885 	uxth.w	r8, r5
 800026e:	fbbe faf9 	udiv	sl, lr, r9
 8000272:	0c21      	lsrs	r1, r4, #16
 8000274:	fb09 e31a 	mls	r3, r9, sl, lr
 8000278:	fb0a fb08 	mul.w	fp, sl, r8
 800027c:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000280:	459b      	cmp	fp, r3
 8000282:	d92a      	bls.n	80002da <__udivmoddi4+0xae>
 8000284:	18eb      	adds	r3, r5, r3
 8000286:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
 800028a:	d204      	bcs.n	8000296 <__udivmoddi4+0x6a>
 800028c:	459b      	cmp	fp, r3
 800028e:	d902      	bls.n	8000296 <__udivmoddi4+0x6a>
 8000290:	f1aa 0002 	sub.w	r0, sl, #2
 8000294:	442b      	add	r3, r5
 8000296:	eba3 030b 	sub.w	r3, r3, fp
 800029a:	b2a4      	uxth	r4, r4
 800029c:	fbb3 f2f9 	udiv	r2, r3, r9
 80002a0:	fb09 3312 	mls	r3, r9, r2, r3
 80002a4:	fb02 f808 	mul.w	r8, r2, r8
 80002a8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80002ac:	45a0      	cmp	r8, r4
 80002ae:	d916      	bls.n	80002de <__udivmoddi4+0xb2>
 80002b0:	192c      	adds	r4, r5, r4
 80002b2:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
 80002b6:	d203      	bcs.n	80002c0 <__udivmoddi4+0x94>
 80002b8:	45a0      	cmp	r8, r4
 80002ba:	d901      	bls.n	80002c0 <__udivmoddi4+0x94>
 80002bc:	1e93      	subs	r3, r2, #2
 80002be:	442c      	add	r4, r5
 80002c0:	eba4 0408 	sub.w	r4, r4, r8
 80002c4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80002c8:	b127      	cbz	r7, 80002d4 <__udivmoddi4+0xa8>
 80002ca:	fa24 f40c 	lsr.w	r4, r4, ip
 80002ce:	2300      	movs	r3, #0
 80002d0:	603c      	str	r4, [r7, #0]
 80002d2:	607b      	str	r3, [r7, #4]
 80002d4:	4631      	mov	r1, r6
 80002d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80002da:	4650      	mov	r0, sl
 80002dc:	e7db      	b.n	8000296 <__udivmoddi4+0x6a>
 80002de:	4613      	mov	r3, r2
 80002e0:	e7ee      	b.n	80002c0 <__udivmoddi4+0x94>
 80002e2:	b902      	cbnz	r2, 80002e6 <__udivmoddi4+0xba>
 80002e4:	deff      	udf	#255	; 0xff
 80002e6:	f1bc 0f00 	cmp.w	ip, #0
 80002ea:	d12e      	bne.n	800034a <__udivmoddi4+0x11e>
 80002ec:	1a8b      	subs	r3, r1, r2
 80002ee:	2601      	movs	r6, #1
 80002f0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80002f4:	b2aa      	uxth	r2, r5
 80002f6:	fbb3 f8fe 	udiv	r8, r3, lr
 80002fa:	0c21      	lsrs	r1, r4, #16
 80002fc:	fb0e 3318 	mls	r3, lr, r8, r3
 8000300:	fb08 f902 	mul.w	r9, r8, r2
 8000304:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000308:	4599      	cmp	r9, r3
 800030a:	d961      	bls.n	80003d0 <__udivmoddi4+0x1a4>
 800030c:	18eb      	adds	r3, r5, r3
 800030e:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 8000312:	d204      	bcs.n	800031e <__udivmoddi4+0xf2>
 8000314:	4599      	cmp	r9, r3
 8000316:	d902      	bls.n	800031e <__udivmoddi4+0xf2>
 8000318:	f1a8 0002 	sub.w	r0, r8, #2
 800031c:	442b      	add	r3, r5
 800031e:	eba3 0309 	sub.w	r3, r3, r9
 8000322:	b2a4      	uxth	r4, r4
 8000324:	fbb3 f1fe 	udiv	r1, r3, lr
 8000328:	fb0e 3311 	mls	r3, lr, r1, r3
 800032c:	434a      	muls	r2, r1
 800032e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000332:	42a2      	cmp	r2, r4
 8000334:	d94e      	bls.n	80003d4 <__udivmoddi4+0x1a8>
 8000336:	192c      	adds	r4, r5, r4
 8000338:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
 800033c:	d203      	bcs.n	8000346 <__udivmoddi4+0x11a>
 800033e:	42a2      	cmp	r2, r4
 8000340:	d901      	bls.n	8000346 <__udivmoddi4+0x11a>
 8000342:	1e8b      	subs	r3, r1, #2
 8000344:	442c      	add	r4, r5
 8000346:	1aa4      	subs	r4, r4, r2
 8000348:	e7bc      	b.n	80002c4 <__udivmoddi4+0x98>
 800034a:	f1cc 0e20 	rsb	lr, ip, #32
 800034e:	fa02 f50c 	lsl.w	r5, r2, ip
 8000352:	fa21 f90e 	lsr.w	r9, r1, lr
 8000356:	fa01 f30c 	lsl.w	r3, r1, ip
 800035a:	fa20 fe0e 	lsr.w	lr, r0, lr
 800035e:	ea4e 0303 	orr.w	r3, lr, r3
 8000362:	ea4f 4815 	mov.w	r8, r5, lsr #16
 8000366:	fa00 f40c 	lsl.w	r4, r0, ip
 800036a:	fbb9 f1f8 	udiv	r1, r9, r8
 800036e:	fa1f fe85 	uxth.w	lr, r5
 8000372:	fb08 9211 	mls	r2, r8, r1, r9
 8000376:	0c18      	lsrs	r0, r3, #16
 8000378:	fb01 f60e 	mul.w	r6, r1, lr
 800037c:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
 8000380:	4296      	cmp	r6, r2
 8000382:	d921      	bls.n	80003c8 <__udivmoddi4+0x19c>
 8000384:	18aa      	adds	r2, r5, r2
 8000386:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 800038a:	d203      	bcs.n	8000394 <__udivmoddi4+0x168>
 800038c:	4296      	cmp	r6, r2
 800038e:	d901      	bls.n	8000394 <__udivmoddi4+0x168>
 8000390:	1e88      	subs	r0, r1, #2
 8000392:	442a      	add	r2, r5
 8000394:	1b92      	subs	r2, r2, r6
 8000396:	b29b      	uxth	r3, r3
 8000398:	fbb2 f9f8 	udiv	r9, r2, r8
 800039c:	fb08 2219 	mls	r2, r8, r9, r2
 80003a0:	fb09 fe0e 	mul.w	lr, r9, lr
 80003a4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80003a8:	459e      	cmp	lr, r3
 80003aa:	d90f      	bls.n	80003cc <__udivmoddi4+0x1a0>
 80003ac:	18eb      	adds	r3, r5, r3
 80003ae:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
 80003b2:	d204      	bcs.n	80003be <__udivmoddi4+0x192>
 80003b4:	459e      	cmp	lr, r3
 80003b6:	d902      	bls.n	80003be <__udivmoddi4+0x192>
 80003b8:	f1a9 0602 	sub.w	r6, r9, #2
 80003bc:	442b      	add	r3, r5
 80003be:	eba3 030e 	sub.w	r3, r3, lr
 80003c2:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 80003c6:	e793      	b.n	80002f0 <__udivmoddi4+0xc4>
 80003c8:	4608      	mov	r0, r1
 80003ca:	e7e3      	b.n	8000394 <__udivmoddi4+0x168>
 80003cc:	464e      	mov	r6, r9
 80003ce:	e7f6      	b.n	80003be <__udivmoddi4+0x192>
 80003d0:	4640      	mov	r0, r8
 80003d2:	e7a4      	b.n	800031e <__udivmoddi4+0xf2>
 80003d4:	460b      	mov	r3, r1
 80003d6:	e7b6      	b.n	8000346 <__udivmoddi4+0x11a>
 80003d8:	428b      	cmp	r3, r1
 80003da:	d905      	bls.n	80003e8 <__udivmoddi4+0x1bc>
 80003dc:	b10f      	cbz	r7, 80003e2 <__udivmoddi4+0x1b6>
 80003de:	e9c7 0100 	strd	r0, r1, [r7]
 80003e2:	2600      	movs	r6, #0
 80003e4:	4630      	mov	r0, r6
 80003e6:	e775      	b.n	80002d4 <__udivmoddi4+0xa8>
 80003e8:	fab3 fc83 	clz	ip, r3
 80003ec:	f1bc 0f00 	cmp.w	ip, #0
 80003f0:	d10f      	bne.n	8000412 <__udivmoddi4+0x1e6>
 80003f2:	428b      	cmp	r3, r1
 80003f4:	d301      	bcc.n	80003fa <__udivmoddi4+0x1ce>
 80003f6:	4282      	cmp	r2, r0
 80003f8:	d809      	bhi.n	800040e <__udivmoddi4+0x1e2>
 80003fa:	1a84      	subs	r4, r0, r2
 80003fc:	eb61 0e03 	sbc.w	lr, r1, r3
 8000400:	2001      	movs	r0, #1
 8000402:	2f00      	cmp	r7, #0
 8000404:	d06a      	beq.n	80004dc <__udivmoddi4+0x2b0>
 8000406:	e9c7 4e00 	strd	r4, lr, [r7]
 800040a:	2600      	movs	r6, #0
 800040c:	e762      	b.n	80002d4 <__udivmoddi4+0xa8>
 800040e:	4660      	mov	r0, ip
 8000410:	e7f7      	b.n	8000402 <__udivmoddi4+0x1d6>
 8000412:	f1cc 0e20 	rsb	lr, ip, #32
 8000416:	fa03 f30c 	lsl.w	r3, r3, ip
 800041a:	fa22 f50e 	lsr.w	r5, r2, lr
 800041e:	fa21 f40e 	lsr.w	r4, r1, lr
 8000422:	431d      	orrs	r5, r3
 8000424:	fa01 f30c 	lsl.w	r3, r1, ip
 8000428:	fa20 f10e 	lsr.w	r1, r0, lr
 800042c:	430b      	orrs	r3, r1
 800042e:	ea4f 4a15 	mov.w	sl, r5, lsr #16
 8000432:	fa00 f60c 	lsl.w	r6, r0, ip
 8000436:	fbb4 f9fa 	udiv	r9, r4, sl
 800043a:	fa1f f885 	uxth.w	r8, r5
 800043e:	fb0a 4019 	mls	r0, sl, r9, r4
 8000442:	0c1c      	lsrs	r4, r3, #16
 8000444:	fb09 f108 	mul.w	r1, r9, r8
 8000448:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
 800044c:	42a1      	cmp	r1, r4
 800044e:	fa02 f20c 	lsl.w	r2, r2, ip
 8000452:	d93f      	bls.n	80004d4 <__udivmoddi4+0x2a8>
 8000454:	192c      	adds	r4, r5, r4
 8000456:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 800045a:	d204      	bcs.n	8000466 <__udivmoddi4+0x23a>
 800045c:	42a1      	cmp	r1, r4
 800045e:	d902      	bls.n	8000466 <__udivmoddi4+0x23a>
 8000460:	f1a9 0002 	sub.w	r0, r9, #2
 8000464:	442c      	add	r4, r5
 8000466:	1a64      	subs	r4, r4, r1
 8000468:	b29b      	uxth	r3, r3
 800046a:	fbb4 f9fa 	udiv	r9, r4, sl
 800046e:	fb0a 4419 	mls	r4, sl, r9, r4
 8000472:	fb09 f808 	mul.w	r8, r9, r8
 8000476:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
 800047a:	4588      	cmp	r8, r1
 800047c:	d92c      	bls.n	80004d8 <__udivmoddi4+0x2ac>
 800047e:	1869      	adds	r1, r5, r1
 8000480:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
 8000484:	d204      	bcs.n	8000490 <__udivmoddi4+0x264>
 8000486:	4588      	cmp	r8, r1
 8000488:	d902      	bls.n	8000490 <__udivmoddi4+0x264>
 800048a:	f1a9 0302 	sub.w	r3, r9, #2
 800048e:	4429      	add	r1, r5
 8000490:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000494:	eba1 0108 	sub.w	r1, r1, r8
 8000498:	fba0 8902 	umull	r8, r9, r0, r2
 800049c:	4549      	cmp	r1, r9
 800049e:	46c2      	mov	sl, r8
 80004a0:	464c      	mov	r4, r9
 80004a2:	d302      	bcc.n	80004aa <__udivmoddi4+0x27e>
 80004a4:	d106      	bne.n	80004b4 <__udivmoddi4+0x288>
 80004a6:	4546      	cmp	r6, r8
 80004a8:	d204      	bcs.n	80004b4 <__udivmoddi4+0x288>
 80004aa:	ebb8 0a02 	subs.w	sl, r8, r2
 80004ae:	eb69 0405 	sbc.w	r4, r9, r5
 80004b2:	3801      	subs	r0, #1
 80004b4:	b197      	cbz	r7, 80004dc <__udivmoddi4+0x2b0>
 80004b6:	ebb6 030a 	subs.w	r3, r6, sl
 80004ba:	eb61 0604 	sbc.w	r6, r1, r4
 80004be:	fa06 fe0e 	lsl.w	lr, r6, lr
 80004c2:	fa23 f30c 	lsr.w	r3, r3, ip
 80004c6:	ea4e 0303 	orr.w	r3, lr, r3
 80004ca:	fa26 f60c 	lsr.w	r6, r6, ip
 80004ce:	e9c7 3600 	strd	r3, r6, [r7]
 80004d2:	e79a      	b.n	800040a <__udivmoddi4+0x1de>
 80004d4:	4648      	mov	r0, r9
 80004d6:	e7c6      	b.n	8000466 <__udivmoddi4+0x23a>
 80004d8:	464b      	mov	r3, r9
 80004da:	e7d9      	b.n	8000490 <__udivmoddi4+0x264>
 80004dc:	463e      	mov	r6, r7
 80004de:	e6f9      	b.n	80002d4 <__udivmoddi4+0xa8>

080004e0 <main>:
#include <zephyr.h>
#include <sys/printk.h>
#include <display/stm32f7-otm8009a.h>

void main(void)
{ 
 80004e0:	b508      	push	{r3, lr}


	BSP_LCD_Init();
 80004e2:	f003 ffe8 	bl	80044b6 <BSP_LCD_Init>
	printk("lcd init! \n");
 80004e6:	4816      	ldr	r0, [pc, #88]	; (8000540 <main+0x60>)
 80004e8:	f003 ff4b 	bl	8004382 <printk>

        BSP_LCD_LayerDefaultInit(1, LCD_FB_START_ADDRESS);
 80004ec:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
 80004f0:	2001      	movs	r0, #1
 80004f2:	f000 faa3 	bl	8000a3c <BSP_LCD_LayerDefaultInit>

  	BSP_LCD_SelectLayer(1);
 80004f6:	2001      	movs	r0, #1
 80004f8:	f000 fada 	bl	8000ab0 <BSP_LCD_SelectLayer>
  	printk("lcd select layer! \n"); 
 80004fc:	4811      	ldr	r0, [pc, #68]	; (8000544 <main+0x64>)
 80004fe:	f003 ff40 	bl	8004382 <printk>

	BSP_LCD_SetBackColor(LCD_COLOR_WHITE); 
 8000502:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000506:	f000 fae5 	bl	8000ad4 <BSP_LCD_SetBackColor>
	printk("set backcolor! \n");
 800050a:	480f      	ldr	r0, [pc, #60]	; (8000548 <main+0x68>)
 800050c:	f003 ff39 	bl	8004382 <printk>

  	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8000510:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000514:	f000 faea 	bl	8000aec <BSP_LCD_Clear>
	printk("lcd clear! \n");
 8000518:	480c      	ldr	r0, [pc, #48]	; (800054c <main+0x6c>)
 800051a:	f003 ff32 	bl	8004382 <printk>

 	BSP_LCD_SetTextColor(LCD_COLOR_DARKBLUE);  
 800051e:	480c      	ldr	r0, [pc, #48]	; (8000550 <main+0x70>)
 8000520:	f000 facc 	bl	8000abc <BSP_LCD_SetTextColor>
	printk("set text color! \n");
 8000524:	480b      	ldr	r0, [pc, #44]	; (8000554 <main+0x74>)
 8000526:	f003 ff2c 	bl	8004382 <printk>

  	BSP_LCD_DisplayStringAt(0, 10, (uint8_t *)"STM32F769I HELLO LCD", CENTER_MODE);
 800052a:	2000      	movs	r0, #0
 800052c:	2301      	movs	r3, #1
 800052e:	4a0a      	ldr	r2, [pc, #40]	; (8000558 <main+0x78>)
 8000530:	210a      	movs	r1, #10
 8000532:	f000 fcd3 	bl	8000edc <BSP_LCD_DisplayStringAt>
	printk("done! \n");
 8000536:	4809      	ldr	r0, [pc, #36]	; (800055c <main+0x7c>)
 8000538:	f003 ff23 	bl	8004382 <printk>

	while(1);
 800053c:	e7fe      	b.n	800053c <main+0x5c>
 800053e:	bf00      	nop
 8000540:	08005caa 	.word	0x08005caa
 8000544:	08005cb6 	.word	0x08005cb6
 8000548:	08005cca 	.word	0x08005cca
 800054c:	08005cdb 	.word	0x08005cdb
 8000550:	ff000080 	.word	0xff000080
 8000554:	08005ce8 	.word	0x08005ce8
 8000558:	08005cfa 	.word	0x08005cfa
 800055c:	08005d0f 	.word	0x08005d0f

08000560 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
 8000560:	680b      	ldr	r3, [r1, #0]
 8000562:	3301      	adds	r3, #1
 8000564:	600b      	str	r3, [r1, #0]
	return _char_out(c);
 8000566:	4b01      	ldr	r3, [pc, #4]	; (800056c <char_out+0xc>)
 8000568:	681b      	ldr	r3, [r3, #0]
 800056a:	4718      	bx	r3
 800056c:	200212b0 	.word	0x200212b0

08000570 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
 8000570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000574:	b085      	sub	sp, #20
 8000576:	469b      	mov	fp, r3
 8000578:	4616      	mov	r6, r2
 800057a:	4682      	mov	sl, r0
 800057c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 800057e:	4688      	mov	r8, r1
 8000580:	2501      	movs	r5, #1
 8000582:	270a      	movs	r7, #10
 8000584:	2c01      	cmp	r4, #1
 8000586:	f04f 0200 	mov.w	r2, #0
 800058a:	f8df 907c 	ldr.w	r9, [pc, #124]	; 8000608 <_printk_dec_ulong+0x98>
 800058e:	bfb8      	it	lt
 8000590:	2401      	movlt	r4, #1
 8000592:	2b01      	cmp	r3, #1
 8000594:	bf0c      	ite	eq
 8000596:	2330      	moveq	r3, #48	; 0x30
 8000598:	2320      	movne	r3, #32
 800059a:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
 800059c:	fbb6 f3f9 	udiv	r3, r6, r9
 80005a0:	9301      	str	r3, [sp, #4]
 80005a2:	b90a      	cbnz	r2, 80005a8 <_printk_dec_ulong+0x38>
 80005a4:	45b1      	cmp	r9, r6
 80005a6:	d81d      	bhi.n	80005e4 <_printk_dec_ulong+0x74>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
 80005a8:	9b01      	ldr	r3, [sp, #4]
 80005aa:	4641      	mov	r1, r8
			digits++;
 80005ac:	3501      	adds	r5, #1
			out((int)(remainder / pos + 48), ctx);
 80005ae:	f103 0030 	add.w	r0, r3, #48	; 0x30
 80005b2:	47d0      	blx	sl
			found_largest_digit = 1;
 80005b4:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
 80005b6:	9b01      	ldr	r3, [sp, #4]
		remaining--;
 80005b8:	3f01      	subs	r7, #1
		remainder %= pos;
 80005ba:	fb09 6613 	mls	r6, r9, r3, r6
	while (pos >= 10) {
 80005be:	2f01      	cmp	r7, #1
		pos /= 10;
 80005c0:	f04f 030a 	mov.w	r3, #10
 80005c4:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
 80005c8:	d1e8      	bne.n	800059c <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
 80005ca:	4641      	mov	r1, r8
 80005cc:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80005d0:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
 80005d2:	f1bb 0f03 	cmp.w	fp, #3
 80005d6:	d102      	bne.n	80005de <_printk_dec_ulong+0x6e>
		remaining = min_width - digits;
 80005d8:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
 80005da:	2c00      	cmp	r4, #0
 80005dc:	dc0e      	bgt.n	80005fc <_printk_dec_ulong+0x8c>
			out(' ', ctx);
		}
	}
}
 80005de:	b005      	add	sp, #20
 80005e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
 80005e4:	42bc      	cmp	r4, r7
 80005e6:	dbe6      	blt.n	80005b6 <_printk_dec_ulong+0x46>
				&& padding < PAD_SPACE_AFTER) {
 80005e8:	f1bb 0f02 	cmp.w	fp, #2
 80005ec:	d8e3      	bhi.n	80005b6 <_printk_dec_ulong+0x46>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 80005ee:	4641      	mov	r1, r8
 80005f0:	9802      	ldr	r0, [sp, #8]
 80005f2:	9203      	str	r2, [sp, #12]
			digits++;
 80005f4:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 80005f6:	47d0      	blx	sl
			digits++;
 80005f8:	9a03      	ldr	r2, [sp, #12]
 80005fa:	e7dc      	b.n	80005b6 <_printk_dec_ulong+0x46>
			out(' ', ctx);
 80005fc:	4641      	mov	r1, r8
 80005fe:	2020      	movs	r0, #32
 8000600:	47d0      	blx	sl
 8000602:	3c01      	subs	r4, #1
 8000604:	e7e9      	b.n	80005da <_printk_dec_ulong+0x6a>
 8000606:	bf00      	nop
 8000608:	3b9aca00 	.word	0x3b9aca00

0800060c <__printk_hook_install>:
	_char_out = fn;
 800060c:	4b01      	ldr	r3, [pc, #4]	; (8000614 <__printk_hook_install+0x8>)
 800060e:	6018      	str	r0, [r3, #0]
}
 8000610:	4770      	bx	lr
 8000612:	bf00      	nop
 8000614:	200212b0 	.word	0x200212b0

08000618 <vprintk>:
	struct out_context ctx = { 0 };
 8000618:	2300      	movs	r3, #0
{
 800061a:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
 800061c:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
 800061e:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
 8000620:	4803      	ldr	r0, [pc, #12]	; (8000630 <vprintk+0x18>)
 8000622:	460b      	mov	r3, r1
 8000624:	a901      	add	r1, sp, #4
 8000626:	f003 fd3c 	bl	80040a2 <z_vprintk>
}
 800062a:	b003      	add	sp, #12
 800062c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000630:	08000561 	.word	0x08000561

08000634 <st_stm32f7_init>:
 * So the init priority has to be 0 (zero).
 *
 * @return 0
 */
static int st_stm32f7_init(struct device *arg)
{
 8000634:	b5f0      	push	{r4, r5, r6, r7, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
 8000636:	f04f 0310 	mov.w	r3, #16
 800063a:	f3ef 8011 	mrs	r0, BASEPRI
 800063e:	f383 8811 	msr	BASEPRI, r3
 8000642:	f3bf 8f6f 	isb	sy
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000646:	4b26      	ldr	r3, [pc, #152]	; (80006e0 <st_stm32f7_init+0xac>)
 8000648:	695a      	ldr	r2, [r3, #20]
 800064a:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
 800064e:	d111      	bne.n	8000674 <st_stm32f7_init+0x40>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000650:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000654:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000658:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 800065c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000660:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000664:	695a      	ldr	r2, [r3, #20]
 8000666:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800066a:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 800066c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000670:	f3bf 8f6f 	isb	sy
	ARG_UNUSED(arg);

	key = irq_lock();

	SCB_EnableICache();
	if (!(SCB->CCR & SCB_CCR_DC_Msk)) {
 8000674:	4b1a      	ldr	r3, [pc, #104]	; (80006e0 <st_stm32f7_init+0xac>)
 8000676:	695a      	ldr	r2, [r3, #20]
 8000678:	03d2      	lsls	r2, r2, #15
 800067a:	d428      	bmi.n	80006ce <st_stm32f7_init+0x9a>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 800067c:	695a      	ldr	r2, [r3, #20]
 800067e:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
 8000682:	d124      	bne.n	80006ce <st_stm32f7_init+0x9a>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000684:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000688:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 800068c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000690:	f643 75e0 	movw	r5, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000694:	f3c2 04c9 	ubfx	r4, r2, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000698:	f3c2 324e 	ubfx	r2, r2, #13, #15
 800069c:	0152      	lsls	r2, r2, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800069e:	ea02 0705 	and.w	r7, r2, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80006a2:	4621      	mov	r1, r4
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80006a4:	ea47 7681 	orr.w	r6, r7, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 80006a8:	f111 31ff 	adds.w	r1, r1, #4294967295	; 0xffffffff
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80006ac:	f8c3 6260 	str.w	r6, [r3, #608]	; 0x260
      } while (ways-- != 0U);
 80006b0:	d2f8      	bcs.n	80006a4 <st_stm32f7_init+0x70>
 80006b2:	3a20      	subs	r2, #32
    } while(sets-- != 0U);
 80006b4:	f112 0f20 	cmn.w	r2, #32
 80006b8:	d1f1      	bne.n	800069e <st_stm32f7_init+0x6a>
 80006ba:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80006be:	695a      	ldr	r2, [r3, #20]
 80006c0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80006c4:	615a      	str	r2, [r3, #20]
 80006c6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80006ca:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 80006ce:	f380 8811 	msr	BASEPRI, r0
 80006d2:	f3bf 8f6f 	isb	sy

	irq_unlock(key);

	/* Update CMSIS SystemCoreClock variable (HCLK) */
	/* At reset, system core clock is set to 16 MHz from HSI */
	SystemCoreClock = 16000000;
 80006d6:	4b03      	ldr	r3, [pc, #12]	; (80006e4 <st_stm32f7_init+0xb0>)

	return 0;
}
 80006d8:	2000      	movs	r0, #0
	SystemCoreClock = 16000000;
 80006da:	4a03      	ldr	r2, [pc, #12]	; (80006e8 <st_stm32f7_init+0xb4>)
 80006dc:	601a      	str	r2, [r3, #0]
}
 80006de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006e0:	e000ed00 	.word	0xe000ed00
 80006e4:	200212d0 	.word	0x200212d0
 80006e8:	00f42400 	.word	0x00f42400

080006ec <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
 80006ec:	280a      	cmp	r0, #10
{
 80006ee:	b538      	push	{r3, r4, r5, lr}
 80006f0:	4604      	mov	r4, r0
 80006f2:	4d07      	ldr	r5, [pc, #28]	; (8000710 <console_out+0x24>)
	if ('\n' == c) {
 80006f4:	d104      	bne.n	8000700 <console_out+0x14>
 80006f6:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
 80006f8:	210d      	movs	r1, #13
 80006fa:	6843      	ldr	r3, [r0, #4]
 80006fc:	685b      	ldr	r3, [r3, #4]
 80006fe:	4798      	blx	r3
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
 8000700:	6828      	ldr	r0, [r5, #0]
 8000702:	b2e1      	uxtb	r1, r4
 8000704:	6843      	ldr	r3, [r0, #4]
 8000706:	685b      	ldr	r3, [r3, #4]
 8000708:	4798      	blx	r3

	return c;
}
 800070a:	4620      	mov	r0, r4
 800070c:	bd38      	pop	{r3, r4, r5, pc}
 800070e:	bf00      	nop
 8000710:	20020008 	.word	0x20020008

08000714 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
 8000714:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
 8000716:	4c04      	ldr	r4, [pc, #16]	; (8000728 <uart_console_hook_install+0x14>)
 8000718:	4620      	mov	r0, r4
 800071a:	f002 fc15 	bl	8002f48 <__stdout_hook_install>
	__printk_hook_install(console_out);
 800071e:	4620      	mov	r0, r4
}
 8000720:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
 8000724:	f7ff bf72 	b.w	800060c <__printk_hook_install>
 8000728:	080006ed 	.word	0x080006ed

0800072c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
 800072c:	b508      	push	{r3, lr}

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
 800072e:	4804      	ldr	r0, [pc, #16]	; (8000740 <uart_console_init+0x14>)
 8000730:	f002 fef0 	bl	8003514 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
 8000734:	4b03      	ldr	r3, [pc, #12]	; (8000744 <uart_console_init+0x18>)
 8000736:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
 8000738:	f7ff ffec 	bl	8000714 <uart_console_hook_install>

	return 0;
}
 800073c:	2000      	movs	r0, #0
 800073e:	bd08      	pop	{r3, pc}
 8000740:	08005d17 	.word	0x08005d17
 8000744:	20020008 	.word	0x20020008

08000748 <__stm32_exti_isr>:
 * @param arg isr argument
 * @param min low end of EXTI# range
 * @param max low end of EXTI# range
 */
static void __stm32_exti_isr(int min, int max, void *arg)
{
 8000748:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct device *dev = arg;
	struct stm32_exti_data *data = dev->driver_data;
 800074c:	6895      	ldr	r5, [r2, #8]
{
 800074e:	4604      	mov	r4, r0
 8000750:	460f      	mov	r7, r1
		return LL_EXTI_IsActiveFlag_0_31(1 << line);
 8000752:	f04f 0801 	mov.w	r8, #1
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
{
  return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 8000756:	4e0b      	ldr	r6, [pc, #44]	; (8000784 <__stm32_exti_isr+0x3c>)
			/* run callback only if one is registered */
			if (!data->cb[line].cb) {
				continue;
			}

			data->cb[line].cb(line, data->cb[line].data);
 8000758:	f105 0904 	add.w	r9, r5, #4
	for (line = min; line < max; line++) {
 800075c:	42bc      	cmp	r4, r7
 800075e:	db01      	blt.n	8000764 <__stm32_exti_isr+0x1c>
		}
	}
}
 8000760:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return LL_EXTI_IsActiveFlag_0_31(1 << line);
 8000764:	fa08 f304 	lsl.w	r3, r8, r4
 8000768:	6972      	ldr	r2, [r6, #20]
		if (stm32_exti_is_pending(line)) {
 800076a:	ea33 0202 	bics.w	r2, r3, r2
 800076e:	d107      	bne.n	8000780 <__stm32_exti_isr+0x38>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
  WRITE_REG(EXTI->PR, ExtiLine);
 8000770:	6173      	str	r3, [r6, #20]
			if (!data->cb[line].cb) {
 8000772:	f855 3034 	ldr.w	r3, [r5, r4, lsl #3]
 8000776:	b11b      	cbz	r3, 8000780 <__stm32_exti_isr+0x38>
			data->cb[line].cb(line, data->cb[line].data);
 8000778:	f859 1034 	ldr.w	r1, [r9, r4, lsl #3]
 800077c:	4620      	mov	r0, r4
 800077e:	4798      	blx	r3
	for (line = min; line < max; line++) {
 8000780:	3401      	adds	r4, #1
 8000782:	e7eb      	b.n	800075c <__stm32_exti_isr+0x14>
 8000784:	40013c00 	.word	0x40013c00

08000788 <stm32_exti_enable>:
	if (line < 32) {
 8000788:	281f      	cmp	r0, #31
{
 800078a:	b508      	push	{r3, lr}
	if (line < 32) {
 800078c:	dd02      	ble.n	8000794 <stm32_exti_enable+0xc>
		return -ENOTSUP;
 800078e:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
 8000792:	bd08      	pop	{r3, pc}
  SET_BIT(EXTI->IMR, ExtiLine);
 8000794:	4a07      	ldr	r2, [pc, #28]	; (80007b4 <stm32_exti_enable+0x2c>)
		LL_EXTI_EnableIT_0_31(1 << line);
 8000796:	2301      	movs	r3, #1
	if (line <= ARRAY_SIZE(exti_irq_table)) {
 8000798:	2818      	cmp	r0, #24
 800079a:	6811      	ldr	r1, [r2, #0]
		LL_EXTI_EnableIT_0_31(1 << line);
 800079c:	fa03 f300 	lsl.w	r3, r3, r0
 80007a0:	ea43 0301 	orr.w	r3, r3, r1
 80007a4:	6013      	str	r3, [r2, #0]
	if (line <= ARRAY_SIZE(exti_irq_table)) {
 80007a6:	dcf2      	bgt.n	800078e <stm32_exti_enable+0x6>
	irq_enable(irqnum);
 80007a8:	4b03      	ldr	r3, [pc, #12]	; (80007b8 <stm32_exti_enable+0x30>)
 80007aa:	5618      	ldrsb	r0, [r3, r0]
 80007ac:	f002 fa9a 	bl	8002ce4 <z_arch_irq_enable>
	return 0;
 80007b0:	2000      	movs	r0, #0
 80007b2:	e7ee      	b.n	8000792 <stm32_exti_enable+0xa>
 80007b4:	40013c00 	.word	0x40013c00
 80007b8:	08005d1e 	.word	0x08005d1e

080007bc <stm32_exti_trigger>:
	if (trigger & STM32_EXTI_TRIG_RISING) {
 80007bc:	07ca      	lsls	r2, r1, #31
{
 80007be:	b510      	push	{r4, lr}
	if (trigger & STM32_EXTI_TRIG_RISING) {
 80007c0:	d507      	bpl.n	80007d2 <stm32_exti_trigger+0x16>
		if (line < 32) {
 80007c2:	281f      	cmp	r0, #31
 80007c4:	dc05      	bgt.n	80007d2 <stm32_exti_trigger+0x16>
  SET_BIT(EXTI->RTSR, ExtiLine);
 80007c6:	4b08      	ldr	r3, [pc, #32]	; (80007e8 <stm32_exti_trigger+0x2c>)
			LL_EXTI_EnableRisingTrig_0_31(1 << line);
 80007c8:	2201      	movs	r2, #1
 80007ca:	689c      	ldr	r4, [r3, #8]
 80007cc:	4082      	lsls	r2, r0
 80007ce:	4322      	orrs	r2, r4
 80007d0:	609a      	str	r2, [r3, #8]
	if (trigger & STM32_EXTI_TRIG_FALLING) {
 80007d2:	078b      	lsls	r3, r1, #30
 80007d4:	d507      	bpl.n	80007e6 <stm32_exti_trigger+0x2a>
		if (line < 32) {
 80007d6:	281f      	cmp	r0, #31
 80007d8:	dc05      	bgt.n	80007e6 <stm32_exti_trigger+0x2a>
  SET_BIT(EXTI->FTSR, ExtiLine);
 80007da:	4a03      	ldr	r2, [pc, #12]	; (80007e8 <stm32_exti_trigger+0x2c>)
			LL_EXTI_EnableFallingTrig_0_31(1 << line);
 80007dc:	2301      	movs	r3, #1
 80007de:	68d1      	ldr	r1, [r2, #12]
 80007e0:	4083      	lsls	r3, r0
 80007e2:	430b      	orrs	r3, r1
 80007e4:	60d3      	str	r3, [r2, #12]
}
 80007e6:	bd10      	pop	{r4, pc}
 80007e8:	40013c00 	.word	0x40013c00

080007ec <stm32_exti_set_callback>:
				void *arg)
{
	struct device *dev = DEVICE_GET(exti_stm32);
	struct stm32_exti_data *data = dev->driver_data;

	if (data->cb[line].cb) {
 80007ec:	4907      	ldr	r1, [pc, #28]	; (800080c <stm32_exti_set_callback+0x20>)
{
 80007ee:	b530      	push	{r4, r5, lr}
 80007f0:	688c      	ldr	r4, [r1, #8]
	if (data->cb[line].cb) {
 80007f2:	f854 1030 	ldr.w	r1, [r4, r0, lsl #3]
 80007f6:	eb04 05c0 	add.w	r5, r4, r0, lsl #3
 80007fa:	b921      	cbnz	r1, 8000806 <stm32_exti_set_callback+0x1a>
		return -EBUSY;
	}

	data->cb[line].cb = cb;
 80007fc:	f844 2030 	str.w	r2, [r4, r0, lsl #3]
	data->cb[line].data = arg;

	return 0;
 8000800:	4608      	mov	r0, r1
	data->cb[line].data = arg;
 8000802:	606b      	str	r3, [r5, #4]
}
 8000804:	bd30      	pop	{r4, r5, pc}
		return -EBUSY;
 8000806:	f06f 000f 	mvn.w	r0, #15
 800080a:	e7fb      	b.n	8000804 <stm32_exti_set_callback+0x18>
 800080c:	20021374 	.word	0x20021374

08000810 <stm32_clock_control_on>:
{
	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);

	ARG_UNUSED(dev);

	switch (pclken->bus) {
 8000810:	680b      	ldr	r3, [r1, #0]
{
 8000812:	b084      	sub	sp, #16
	switch (pclken->bus) {
 8000814:	2b03      	cmp	r3, #3
 8000816:	d82d      	bhi.n	8000874 <stm32_clock_control_on+0x64>
 8000818:	e8df f003 	tbb	[pc, r3]
 800081c:	22180e02 	.word	0x22180e02
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000820:	4a16      	ldr	r2, [pc, #88]	; (800087c <stm32_clock_control_on+0x6c>)
	case STM32_CLOCK_BUS_AHB1:
		LL_AHB1_GRP1_EnableClock(pclken->enr);
 8000822:	684b      	ldr	r3, [r1, #4]
 8000824:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8000826:	4319      	orrs	r1, r3
 8000828:	6311      	str	r1, [r2, #48]	; 0x30
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800082a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800082c:	4013      	ands	r3, r2
 800082e:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8000830:	9b00      	ldr	r3, [sp, #0]
#endif /* CONFIG_SOC_SERIES_STM32L0X */
	default:
		return -ENOTSUP;
	}

	return 0;
 8000832:	2000      	movs	r0, #0
}
 8000834:	b004      	add	sp, #16
 8000836:	4770      	bx	lr
  * @retval None
*/
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000838:	4a10      	ldr	r2, [pc, #64]	; (800087c <stm32_clock_control_on+0x6c>)
		LL_AHB2_GRP1_EnableClock(pclken->enr);
 800083a:	684b      	ldr	r3, [r1, #4]
 800083c:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800083e:	4319      	orrs	r1, r3
 8000840:	6351      	str	r1, [r2, #52]	; 0x34
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000842:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000844:	4013      	ands	r3, r2
 8000846:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000848:	9b01      	ldr	r3, [sp, #4]
 800084a:	e7f2      	b.n	8000832 <stm32_clock_control_on+0x22>
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 800084c:	4a0b      	ldr	r2, [pc, #44]	; (800087c <stm32_clock_control_on+0x6c>)
		LL_APB1_GRP1_EnableClock(pclken->enr);
 800084e:	684b      	ldr	r3, [r1, #4]
 8000850:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8000852:	4319      	orrs	r1, r3
 8000854:	6411      	str	r1, [r2, #64]	; 0x40
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8000856:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000858:	4013      	ands	r3, r2
 800085a:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
 800085c:	9b02      	ldr	r3, [sp, #8]
 800085e:	e7e8      	b.n	8000832 <stm32_clock_control_on+0x22>
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8000860:	4a06      	ldr	r2, [pc, #24]	; (800087c <stm32_clock_control_on+0x6c>)
		LL_APB2_GRP1_EnableClock(pclken->enr);
 8000862:	684b      	ldr	r3, [r1, #4]
 8000864:	6c51      	ldr	r1, [r2, #68]	; 0x44
 8000866:	4319      	orrs	r1, r3
 8000868:	6451      	str	r1, [r2, #68]	; 0x44
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800086a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800086c:	4013      	ands	r3, r2
 800086e:	9303      	str	r3, [sp, #12]
  (void)tmpreg;
 8000870:	9b03      	ldr	r3, [sp, #12]
 8000872:	e7de      	b.n	8000832 <stm32_clock_control_on+0x22>
		return -ENOTSUP;
 8000874:	f06f 0022 	mvn.w	r0, #34	; 0x22
 8000878:	e7dc      	b.n	8000834 <stm32_clock_control_on+0x24>
 800087a:	bf00      	nop
 800087c:	40023800 	.word	0x40023800

08000880 <stm32_clock_control_off>:
{
	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);

	ARG_UNUSED(dev);

	switch (pclken->bus) {
 8000880:	680b      	ldr	r3, [r1, #0]
 8000882:	2b03      	cmp	r3, #3
 8000884:	d820      	bhi.n	80008c8 <stm32_clock_control_off+0x48>
 8000886:	e8df f003 	tbb	[pc, r3]
 800088a:	0a02      	.short	0x0a02
 800088c:	1811      	.short	0x1811
  CLEAR_BIT(RCC->AHB1ENR, Periphs);
 800088e:	4a10      	ldr	r2, [pc, #64]	; (80008d0 <stm32_clock_control_off+0x50>)
 8000890:	6849      	ldr	r1, [r1, #4]
 8000892:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000894:	ea23 0301 	bic.w	r3, r3, r1
 8000898:	6313      	str	r3, [r2, #48]	; 0x30
#endif /* CONFIG_SOC_SERIES_STM32L0X */
	default:
		return -ENOTSUP;
	}

	return 0;
 800089a:	2000      	movs	r0, #0
 800089c:	4770      	bx	lr
  CLEAR_BIT(RCC->AHB2ENR, Periphs);
 800089e:	4a0c      	ldr	r2, [pc, #48]	; (80008d0 <stm32_clock_control_off+0x50>)
 80008a0:	6849      	ldr	r1, [r1, #4]
 80008a2:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80008a4:	ea23 0301 	bic.w	r3, r3, r1
 80008a8:	6353      	str	r3, [r2, #52]	; 0x34
 80008aa:	e7f6      	b.n	800089a <stm32_clock_control_off+0x1a>
  CLEAR_BIT(RCC->APB1ENR, Periphs);
 80008ac:	4a08      	ldr	r2, [pc, #32]	; (80008d0 <stm32_clock_control_off+0x50>)
 80008ae:	6849      	ldr	r1, [r1, #4]
 80008b0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80008b2:	ea23 0301 	bic.w	r3, r3, r1
 80008b6:	6413      	str	r3, [r2, #64]	; 0x40
 80008b8:	e7ef      	b.n	800089a <stm32_clock_control_off+0x1a>
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 80008ba:	4a05      	ldr	r2, [pc, #20]	; (80008d0 <stm32_clock_control_off+0x50>)
 80008bc:	6849      	ldr	r1, [r1, #4]
 80008be:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80008c0:	ea23 0301 	bic.w	r3, r3, r1
 80008c4:	6453      	str	r3, [r2, #68]	; 0x44
 80008c6:	e7e8      	b.n	800089a <stm32_clock_control_off+0x1a>
		return -ENOTSUP;
 80008c8:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
 80008cc:	4770      	bx	lr
 80008ce:	bf00      	nop
 80008d0:	40023800 	.word	0x40023800

080008d4 <stm32_clock_control_get_subsys_rate>:
	 * Get AHB Clock (= SystemCoreClock = SYSCLK/prescaler)
	 * SystemCoreClock is preferred to CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC
	 * since it will be updated after clock configuration and hence
	 * more likely to contain actual clock speed
	 */
	u32_t ahb_clock = SystemCoreClock;
 80008d4:	4b08      	ldr	r3, [pc, #32]	; (80008f8 <stm32_clock_control_get_subsys_rate+0x24>)
				CONFIG_CLOCK_STM32_APB2_PRESCALER);
#endif /* CONFIG_SOC_SERIES_STM32F0X */

	ARG_UNUSED(clock);

	switch (pclken->bus) {
 80008d6:	6809      	ldr	r1, [r1, #0]
	u32_t ahb_clock = SystemCoreClock;
 80008d8:	681b      	ldr	r3, [r3, #0]
	switch (pclken->bus) {
 80008da:	2903      	cmp	r1, #3
 80008dc:	d809      	bhi.n	80008f2 <stm32_clock_control_get_subsys_rate+0x1e>
 80008de:	e8df f001 	tbb	[pc, r1]
 80008e2:	0303      	.short	0x0303
 80008e4:	0602      	.short	0x0602
	return clock / prescaler;
 80008e6:	089b      	lsrs	r3, r3, #2
#if defined(CONFIG_SOC_SERIES_STM32L4X) || \
	defined(CONFIG_SOC_SERIES_STM32F0X) || \
	defined(CONFIG_SOC_SERIES_STM32WBX)
	case STM32_CLOCK_BUS_APB1_2:
#endif
		*rate = apb1_clock;
 80008e8:	6013      	str	r3, [r2, #0]
#endif /* CONFIG_SOC_SERIES_STM32F0X */
	default:
		return -ENOTSUP;
	}

	return 0;
 80008ea:	2000      	movs	r0, #0
		break;
 80008ec:	4770      	bx	lr
	return clock / prescaler;
 80008ee:	085b      	lsrs	r3, r3, #1
 80008f0:	e7fa      	b.n	80008e8 <stm32_clock_control_get_subsys_rate+0x14>
		return -ENOTSUP;
 80008f2:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
 80008f6:	4770      	bx	lr
 80008f8:	200212d0 	.word	0x200212d0

080008fc <stm32_clock_control_init>:
			 mco2_prescaler(CONFIG_CLOCK_STM32_MCO2_DIV));
#endif /* CONFIG_CLOCK_STM32_MCO2_SRC_NOCLOCK */
}

static int stm32_clock_control_init(struct device *dev)
{
 80008fc:	b530      	push	{r4, r5, lr}
	clk_init->APB1CLKDivider = apb1_prescaler(
 80008fe:	2100      	movs	r1, #0
{
 8000900:	b087      	sub	sp, #28
	clk_init->APB1CLKDivider = apb1_prescaler(
 8000902:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000906:	e9cd 1300 	strd	r1, r3, [sp]
	clk_init->APB2CLKDivider = apb2_prescaler(
 800090a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800090e:	9302      	str	r3, [sp, #8]
#else
	hclk_prescaler = s_ClkInitStruct.AHBCLKDivider;
#endif /* CONFIG_SOC_SERIES_STM32WBX */

	/* Some clocks would be activated by default */
	config_enable_default_clocks();
 8000910:	f000 f838 	bl	8000984 <config_enable_default_clocks>

#ifdef CONFIG_CLOCK_STM32_SYSCLK_SRC_PLL
	LL_UTILS_PLLInitTypeDef s_PLLInitStruct;

	/* configure PLL input settings */
	config_pll_init(&s_PLLInitStruct);
 8000914:	a803      	add	r0, sp, #12
 8000916:	f003 fdc5 	bl	80044a4 <config_pll_init>
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 800091a:	4b18      	ldr	r3, [pc, #96]	; (800097c <stm32_clock_control_init+0x80>)
 800091c:	681a      	ldr	r2, [r3, #0]
	if (LL_RCC_HSI_IsReady() != 1) {
 800091e:	0790      	lsls	r0, r2, #30
 8000920:	d406      	bmi.n	8000930 <stm32_clock_control_init+0x34>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8000922:	681a      	ldr	r2, [r3, #0]
 8000924:	f042 0201 	orr.w	r2, r2, #1
 8000928:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 800092a:	681a      	ldr	r2, [r3, #0]
		while (LL_RCC_HSI_IsReady() != 1) {
 800092c:	0792      	lsls	r2, r2, #30
 800092e:	d5fc      	bpl.n	800092a <stm32_clock_control_init+0x2e>
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_PLL
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8000930:	4c12      	ldr	r4, [pc, #72]	; (800097c <stm32_clock_control_init+0x80>)
 8000932:	68a3      	ldr	r3, [r4, #8]
 8000934:	f023 0303 	bic.w	r3, r3, #3
 8000938:	60a3      	str	r3, [r4, #8]
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800093a:	68a3      	ldr	r3, [r4, #8]
 800093c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000940:	60a3      	str	r3, [r4, #8]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8000942:	68a5      	ldr	r5, [r4, #8]
	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 8000944:	f015 050c 	ands.w	r5, r5, #12
 8000948:	d1fb      	bne.n	8000942 <stm32_clock_control_init+0x46>
  * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Disable(void)
{
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 800094a:	6823      	ldr	r3, [r4, #0]
#ifdef CONFIG_CLOCK_STM32_HSE_BYPASS
	hse_bypass = LL_UTILS_HSEBYPASS_ON;
#endif /* CONFIG_CLOCK_STM32_HSE_BYPASS */

	/* Switch to PLL with HSE as clock source */
	LL_PLL_ConfigSystemClock_HSE(
 800094c:	aa03      	add	r2, sp, #12
 800094e:	4629      	mov	r1, r5
 8000950:	480b      	ldr	r0, [pc, #44]	; (8000980 <stm32_clock_control_init+0x84>)
 8000952:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8000956:	6023      	str	r3, [r4, #0]
	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ,
 8000958:	6863      	ldr	r3, [r4, #4]
 800095a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 800095e:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
 8000962:	6063      	str	r3, [r4, #4]
	LL_PLL_ConfigSystemClock_HSE(
 8000964:	466b      	mov	r3, sp
 8000966:	f001 fc2d 	bl	80021c4 <LL_PLL_ConfigSystemClock_HSE>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 800096a:	6823      	ldr	r3, [r4, #0]
 800096c:	f023 0301 	bic.w	r3, r3, #1
 8000970:	6023      	str	r3, [r4, #0]
		&s_PLLInitStruct,
		&s_ClkInitStruct);

	/* Disable other clocks */
	LL_RCC_HSI_Disable();
	LL_RCC_MSI_Disable();
 8000972:	f003 fd9f 	bl	80044b4 <LL_RCC_MSI_Disable>

	/* configure MCO1/MCO2 based on Kconfig */
	stm32_clock_control_mco_init();

	return 0;
}
 8000976:	4628      	mov	r0, r5
 8000978:	b007      	add	sp, #28
 800097a:	bd30      	pop	{r4, r5, pc}
 800097c:	40023800 	.word	0x40023800
 8000980:	017d7840 	.word	0x017d7840

08000984 <config_enable_default_clocks>:
  SET_BIT(RCC->APB1ENR, Periphs);
 8000984:	4b06      	ldr	r3, [pc, #24]	; (80009a0 <config_enable_default_clocks+0x1c>)

/**
 * @brief Activate default clocks
 */
void config_enable_default_clocks(void)
{
 8000986:	b082      	sub	sp, #8
 8000988:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800098a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800098e:	641a      	str	r2, [r3, #64]	; 0x40
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8000990:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000992:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000996:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000998:	9b01      	ldr	r3, [sp, #4]
	/* Power Interface clock enabled by default */
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
}
 800099a:	b002      	add	sp, #8
 800099c:	4770      	bx	lr
 800099e:	bf00      	nop
 80009a0:	40023800 	.word	0x40023800

080009a4 <LCD_Reset>:

}


void LCD_Reset(void)
{
 80009a4:	b538      	push	{r3, r4, r5, lr}
dev.driver_data = &otma;
 80009a6:	4b1b      	ldr	r3, [pc, #108]	; (8000a14 <LCD_Reset+0x70>)
 80009a8:	4c1b      	ldr	r4, [pc, #108]	; (8000a18 <LCD_Reset+0x74>)
	printk("Initializing display otm8009a driver\n");
 80009aa:	481c      	ldr	r0, [pc, #112]	; (8000a1c <LCD_Reset+0x78>)
dev.driver_data = &otma;
 80009ac:	609c      	str	r4, [r3, #8]
	printk("Initializing display otm8009a driver\n");
 80009ae:	f003 fce8 	bl	8004382 <printk>
 80009b2:	481b      	ldr	r0, [pc, #108]	; (8000a20 <LCD_Reset+0x7c>)
 80009b4:	f002 fdae 	bl	8003514 <z_impl_device_get_binding>
	data->reset_gpio = device_get_binding(DT_ALIAS_OTMRESET_GPIOS_CONTROLLER);
 80009b8:	6020      	str	r0, [r4, #0]
	if (data->reset_gpio == NULL) {
 80009ba:	b330      	cbz	r0, 8000a0a <LCD_Reset+0x66>
	printk("get gpio binding\n");
 80009bc:	4819      	ldr	r0, [pc, #100]	; (8000a24 <LCD_Reset+0x80>)
 80009be:	f003 fce0 	bl	8004382 <printk>
	gpio_pin_configure(data->reset_gpio,DT_ALIAS_OTMRESET_GPIO_PIN, GPIO_DIR_OUT);
 80009c2:	6820      	ldr	r0, [r4, #0]
				    u32_t pin, int flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->config(port, access_op, pin, flags);
 80009c4:	220f      	movs	r2, #15
 80009c6:	2100      	movs	r1, #0
 80009c8:	6843      	ldr	r3, [r0, #4]
 80009ca:	681d      	ldr	r5, [r3, #0]
 80009cc:	2301      	movs	r3, #1
 80009ce:	47a8      	blx	r5
	printk("pin configured\n");
 80009d0:	4815      	ldr	r0, [pc, #84]	; (8000a28 <LCD_Reset+0x84>)
 80009d2:	f003 fcd6 	bl	8004382 <printk>
	gpio_pin_write(data->reset_gpio, DT_ALIAS_OTMRESET_GPIO_PIN, 0);
 80009d6:	6820      	ldr	r0, [r4, #0]
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
 80009d8:	220f      	movs	r2, #15
 80009da:	6843      	ldr	r3, [r0, #4]
 80009dc:	685d      	ldr	r5, [r3, #4]
 80009de:	2300      	movs	r3, #0
 80009e0:	4619      	mov	r1, r3
 80009e2:	47a8      	blx	r5
	printk("pin wrote 0\n");
 80009e4:	4811      	ldr	r0, [pc, #68]	; (8000a2c <LCD_Reset+0x88>)
 80009e6:	f003 fccc 	bl	8004382 <printk>

K_SYSCALL_DECLARE1(K_SYSCALL_K_OBJECT_ALLOC, k_object_alloc, void *, enum k_objects, otype)

K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)

K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, ms)
 80009ea:	200a      	movs	r0, #10
 80009ec:	f004 fd8e 	bl	800550c <z_impl_k_sleep>
	gpio_pin_write(data->reset_gpio, DT_ALIAS_OTMRESET_GPIO_PIN, 1);
 80009f0:	6820      	ldr	r0, [r4, #0]
 80009f2:	220f      	movs	r2, #15
 80009f4:	2100      	movs	r1, #0
 80009f6:	6843      	ldr	r3, [r0, #4]
 80009f8:	685c      	ldr	r4, [r3, #4]
 80009fa:	2301      	movs	r3, #1
 80009fc:	47a0      	blx	r4
	printk("pin wrote 1 \n");
 80009fe:	480c      	ldr	r0, [pc, #48]	; (8000a30 <LCD_Reset+0x8c>)
 8000a00:	f003 fcbf 	bl	8004382 <printk>
	printk("done\n");
 8000a04:	480b      	ldr	r0, [pc, #44]	; (8000a34 <LCD_Reset+0x90>)
 8000a06:	f003 fcbc 	bl	8004382 <printk>
otm8009a_init(&dev);

//uint8_t x = otm8009a_init(&dev);

//printk("retval = %d\n",x);
printk("hello world\n");
 8000a0a:	480b      	ldr	r0, [pc, #44]	; (8000a38 <LCD_Reset+0x94>)
}
 8000a0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
printk("hello world\n");
 8000a10:	f003 bcb7 	b.w	8004382 <printk>
 8000a14:	20020178 	.word	0x20020178
 8000a18:	2002030c 	.word	0x2002030c
 8000a1c:	08005d4a 	.word	0x08005d4a
 8000a20:	08005d70 	.word	0x08005d70
 8000a24:	08005d76 	.word	0x08005d76
 8000a28:	08005d88 	.word	0x08005d88
 8000a2c:	08005d98 	.word	0x08005d98
 8000a30:	08005da5 	.word	0x08005da5
 8000a34:	08005db3 	.word	0x08005db3
 8000a38:	08005db9 	.word	0x08005db9

08000a3c <BSP_LCD_LayerDefaultInit>:
  * @brief  Gets the LCD X size.
  * @retval Used LCD X size
  */
uint32_t BSP_LCD_GetXSize(void)
{
  return (lcd_x_size);
 8000a3c:	4a17      	ldr	r2, [pc, #92]	; (8000a9c <BSP_LCD_LayerDefaultInit+0x60>)
void BSP_LCD_LayerDefaultInit(uint16_t LayerIndex, uint32_t FB_Address)
{
    LCD_LayerCfgTypeDef  Layercfg;

  /* Layer Init */
  Layercfg.WindowX0 = 0;
 8000a3e:	2300      	movs	r3, #0
{
 8000a40:	b510      	push	{r4, lr}
 8000a42:	4604      	mov	r4, r0
 8000a44:	b08e      	sub	sp, #56	; 0x38
  return (lcd_x_size);
 8000a46:	6810      	ldr	r0, [r2, #0]
  return (lcd_y_size);
 8000a48:	4a15      	ldr	r2, [pc, #84]	; (8000aa0 <BSP_LCD_LayerDefaultInit+0x64>)
  Layercfg.WindowX1 = BSP_LCD_GetXSize();
  Layercfg.WindowY0 = 0;
  Layercfg.WindowY1 = BSP_LCD_GetYSize(); 
  Layercfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
  Layercfg.FBStartAdress = FB_Address;
 8000a4a:	910a      	str	r1, [sp, #40]	; 0x28
  Layercfg.Alpha = 255;
 8000a4c:	21ff      	movs	r1, #255	; 0xff
  return (lcd_y_size);
 8000a4e:	6812      	ldr	r2, [r2, #0]
  Layercfg.WindowX0 = 0;
 8000a50:	9301      	str	r3, [sp, #4]
  Layercfg.Alpha0 = 0;
  Layercfg.Backcolor.Blue = 0;
 8000a52:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
  Layercfg.Backcolor.Green = 0;
  Layercfg.Backcolor.Red = 0;
 8000a56:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
  Layercfg.WindowY0 = 0;
 8000a5a:	e9cd 0302 	strd	r0, r3, [sp, #8]
  Layercfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
 8000a5e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  Layercfg.Alpha0 = 0;
 8000a62:	e9cd 1306 	strd	r1, r3, [sp, #24]
  Layercfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
  Layercfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8000a66:	2307      	movs	r3, #7
 8000a68:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  Layercfg.ImageWidth = BSP_LCD_GetXSize();
  Layercfg.ImageHeight = BSP_LCD_GetYSize();
 8000a6c:	e9cd 020b 	strd	r0, r2, [sp, #44]	; 0x2c
  Layercfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8000a70:	e9cd 1308 	strd	r1, r3, [sp, #32]
  
  HAL_LTDC_ConfigLayer(&hltdc_discovery, &Layercfg, LayerIndex); 
 8000a74:	4622      	mov	r2, r4
 8000a76:	a901      	add	r1, sp, #4
 8000a78:	480a      	ldr	r0, [pc, #40]	; (8000aa4 <BSP_LCD_LayerDefaultInit+0x68>)
 8000a7a:	f003 ffe5 	bl	8004a48 <HAL_LTDC_ConfigLayer>
  
  DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
 8000a7e:	200c      	movs	r0, #12
 8000a80:	4b09      	ldr	r3, [pc, #36]	; (8000aa8 <BSP_LCD_LayerDefaultInit+0x6c>)
 8000a82:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000a86:	4360      	muls	r0, r4
 8000a88:	181a      	adds	r2, r3, r0
 8000a8a:	6051      	str	r1, [r2, #4]
  DrawProp[LayerIndex].pFont     = &Font24;
 8000a8c:	4907      	ldr	r1, [pc, #28]	; (8000aac <BSP_LCD_LayerDefaultInit+0x70>)
 8000a8e:	6091      	str	r1, [r2, #8]
  DrawProp[LayerIndex].TextColor = LCD_COLOR_BLACK;
 8000a90:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000a94:	501a      	str	r2, [r3, r0]
}
 8000a96:	b00e      	add	sp, #56	; 0x38
 8000a98:	bd10      	pop	{r4, pc}
 8000a9a:	bf00      	nop
 8000a9c:	200212c8 	.word	0x200212c8
 8000aa0:	200212cc 	.word	0x200212cc
 8000aa4:	20020264 	.word	0x20020264
 8000aa8:	200200d0 	.word	0x200200d0
 8000aac:	200212d4 	.word	0x200212d4

08000ab0 <BSP_LCD_SelectLayer>:
  * @brief  Selects the LCD Layer.
  * @param  LayerIndex: Layer foreground or background
  */
void BSP_LCD_SelectLayer(uint32_t LayerIndex)
{
  ActiveLayer = LayerIndex;
 8000ab0:	4b01      	ldr	r3, [pc, #4]	; (8000ab8 <BSP_LCD_SelectLayer+0x8>)
 8000ab2:	6018      	str	r0, [r3, #0]
}
 8000ab4:	4770      	bx	lr
 8000ab6:	bf00      	nop
 8000ab8:	200200cc 	.word	0x200200cc

08000abc <BSP_LCD_SetTextColor>:
  * @brief  Sets the LCD text color.
  * @param  Color: Text color code ARGB(8-8-8-8)
  */
void BSP_LCD_SetTextColor(uint32_t Color)
{
  DrawProp[ActiveLayer].TextColor = Color;
 8000abc:	4b03      	ldr	r3, [pc, #12]	; (8000acc <BSP_LCD_SetTextColor+0x10>)
 8000abe:	681a      	ldr	r2, [r3, #0]
 8000ac0:	230c      	movs	r3, #12
 8000ac2:	4353      	muls	r3, r2
 8000ac4:	4a02      	ldr	r2, [pc, #8]	; (8000ad0 <BSP_LCD_SetTextColor+0x14>)
 8000ac6:	50d0      	str	r0, [r2, r3]
}
 8000ac8:	4770      	bx	lr
 8000aca:	bf00      	nop
 8000acc:	200200cc 	.word	0x200200cc
 8000ad0:	200200d0 	.word	0x200200d0

08000ad4 <BSP_LCD_SetBackColor>:
  * @brief  Sets the LCD background color.
  * @param  Color: Layer background color code ARGB(8-8-8-8)
  */
void BSP_LCD_SetBackColor(uint32_t Color)
{
  DrawProp[ActiveLayer].BackColor = Color;
 8000ad4:	4b03      	ldr	r3, [pc, #12]	; (8000ae4 <BSP_LCD_SetBackColor+0x10>)
 8000ad6:	210c      	movs	r1, #12
 8000ad8:	4a03      	ldr	r2, [pc, #12]	; (8000ae8 <BSP_LCD_SetBackColor+0x14>)
 8000ada:	681b      	ldr	r3, [r3, #0]
 8000adc:	fb01 2303 	mla	r3, r1, r3, r2
 8000ae0:	6058      	str	r0, [r3, #4]
}
 8000ae2:	4770      	bx	lr
 8000ae4:	200200cc 	.word	0x200200cc
 8000ae8:	200200d0 	.word	0x200200d0

08000aec <BSP_LCD_Clear>:
  * @param  Color: Color of the background
  */
void BSP_LCD_Clear(uint32_t Color)
{
  /* Clear the LCD */
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8000aec:	4b1a      	ldr	r3, [pc, #104]	; (8000b58 <BSP_LCD_Clear+0x6c>)
{
 8000aee:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8000af2:	681d      	ldr	r5, [r3, #0]
 8000af4:	2334      	movs	r3, #52	; 0x34
 8000af6:	4a19      	ldr	r2, [pc, #100]	; (8000b5c <BSP_LCD_Clear+0x70>)
{
 8000af8:	4606      	mov	r6, r0
  * @param  ColorIndex: Color index
  */
static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex)
{
  /* Register to memory mode with ARGB8888 as color Mode */
  hdma2d_discovery.Init.Mode         = DMA2D_R2M;
 8000afa:	4c19      	ldr	r4, [pc, #100]	; (8000b60 <BSP_LCD_Clear+0x74>)
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8000afc:	fb03 2305 	mla	r3, r3, r5, r2
  hdma2d_discovery.Init.ColorMode    = DMA2D_OUTPUT_ARGB8888;
 8000b00:	f44f 3240 	mov.w	r2, #196608	; 0x30000
  hdma2d_discovery.Init.OutputOffset = OffLine;

  hdma2d_discovery.Instance = DMA2D;

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hdma2d_discovery) == HAL_OK)
 8000b04:	4620      	mov	r0, r4
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8000b06:	6ddf      	ldr	r7, [r3, #92]	; 0x5c
  return (lcd_x_size);
 8000b08:	4b16      	ldr	r3, [pc, #88]	; (8000b64 <BSP_LCD_Clear+0x78>)
 8000b0a:	f8d3 8000 	ldr.w	r8, [r3]
  return (lcd_y_size);
 8000b0e:	4b16      	ldr	r3, [pc, #88]	; (8000b68 <BSP_LCD_Clear+0x7c>)
 8000b10:	f8d3 9000 	ldr.w	r9, [r3]
  hdma2d_discovery.Init.ColorMode    = DMA2D_OUTPUT_ARGB8888;
 8000b14:	2300      	movs	r3, #0
 8000b16:	e9c4 2301 	strd	r2, r3, [r4, #4]
  hdma2d_discovery.Init.OutputOffset = OffLine;
 8000b1a:	60e3      	str	r3, [r4, #12]
  hdma2d_discovery.Instance = DMA2D;
 8000b1c:	4b13      	ldr	r3, [pc, #76]	; (8000b6c <BSP_LCD_Clear+0x80>)
 8000b1e:	6023      	str	r3, [r4, #0]
  if(HAL_DMA2D_Init(&hdma2d_discovery) == HAL_OK)
 8000b20:	f003 fd39 	bl	8004596 <HAL_DMA2D_Init>
 8000b24:	b9a0      	cbnz	r0, 8000b50 <BSP_LCD_Clear+0x64>
  {
    if(HAL_DMA2D_ConfigLayer(&hdma2d_discovery, LayerIndex) == HAL_OK)
 8000b26:	4629      	mov	r1, r5
 8000b28:	4620      	mov	r0, r4
 8000b2a:	f000 fc37 	bl	800139c <HAL_DMA2D_ConfigLayer>
 8000b2e:	b978      	cbnz	r0, 8000b50 <BSP_LCD_Clear+0x64>
    {
      if (HAL_DMA2D_Start(&hdma2d_discovery, ColorIndex, (uint32_t)pDst, xSize, ySize) == HAL_OK)
 8000b30:	f8cd 9000 	str.w	r9, [sp]
 8000b34:	4643      	mov	r3, r8
 8000b36:	463a      	mov	r2, r7
 8000b38:	4631      	mov	r1, r6
 8000b3a:	4620      	mov	r0, r4
 8000b3c:	f003 fd61 	bl	8004602 <HAL_DMA2D_Start>
 8000b40:	b930      	cbnz	r0, 8000b50 <BSP_LCD_Clear+0x64>
      {
        /* Polling For DMA transfer */
        HAL_DMA2D_PollForTransfer(&hdma2d_discovery, 10);
 8000b42:	210a      	movs	r1, #10
 8000b44:	4620      	mov	r0, r4
}
 8000b46:	b003      	add	sp, #12
 8000b48:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        HAL_DMA2D_PollForTransfer(&hdma2d_discovery, 10);
 8000b4c:	f003 bd73 	b.w	8004636 <HAL_DMA2D_PollForTransfer>
}
 8000b50:	b003      	add	sp, #12
 8000b52:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000b56:	bf00      	nop
 8000b58:	200200cc 	.word	0x200200cc
 8000b5c:	20020264 	.word	0x20020264
 8000b60:	20020184 	.word	0x20020184
 8000b64:	200212c8 	.word	0x200212c8
 8000b68:	200212cc 	.word	0x200212cc
 8000b6c:	4002b000 	.word	0x4002b000

08000b70 <DSI_IO_WriteCmd>:
  if(NbrParams <= 1)
 8000b70:	2801      	cmp	r0, #1
{
 8000b72:	4603      	mov	r3, r0
 8000b74:	b507      	push	{r0, r1, r2, lr}
  if(NbrParams <= 1)
 8000b76:	d80a      	bhi.n	8000b8e <DSI_IO_WriteCmd+0x1e>
   HAL_DSI_ShortWrite(&hdsi_discovery, LCD_OTM8009A_ID, DSI_DCS_SHORT_PKT_WRITE_P1, pParams[0], pParams[1]); 
 8000b78:	784b      	ldrb	r3, [r1, #1]
 8000b7a:	2215      	movs	r2, #21
 8000b7c:	4808      	ldr	r0, [pc, #32]	; (8000ba0 <DSI_IO_WriteCmd+0x30>)
 8000b7e:	9300      	str	r3, [sp, #0]
 8000b80:	780b      	ldrb	r3, [r1, #0]
 8000b82:	2100      	movs	r1, #0
 8000b84:	f003 fe68 	bl	8004858 <HAL_DSI_ShortWrite>
}
 8000b88:	b003      	add	sp, #12
 8000b8a:	f85d fb04 	ldr.w	pc, [sp], #4
   HAL_DSI_LongWrite(&hdsi_discovery,  LCD_OTM8009A_ID, DSI_DCS_LONG_PKT_WRITE, NbrParams, pParams[NbrParams], pParams); 
 8000b8e:	9101      	str	r1, [sp, #4]
 8000b90:	5c0a      	ldrb	r2, [r1, r0]
 8000b92:	2100      	movs	r1, #0
 8000b94:	4802      	ldr	r0, [pc, #8]	; (8000ba0 <DSI_IO_WriteCmd+0x30>)
 8000b96:	9200      	str	r2, [sp, #0]
 8000b98:	2239      	movs	r2, #57	; 0x39
 8000b9a:	f003 fe6e 	bl	800487a <HAL_DSI_LongWrite>
}
 8000b9e:	e7f3      	b.n	8000b88 <DSI_IO_WriteCmd+0x18>
 8000ba0:	200201dc 	.word	0x200201dc

08000ba4 <BSP_LCD_MspInit>:
{
 8000ba4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  __HAL_RCC_LTDC_CLK_ENABLE();
 8000ba6:	4b27      	ldr	r3, [pc, #156]	; (8000c44 <BSP_LCD_MspInit+0xa0>)
  HAL_NVIC_SetPriority(LTDC_IRQn, 3, 0);
 8000ba8:	2103      	movs	r1, #3
 8000baa:	2058      	movs	r0, #88	; 0x58
  __HAL_RCC_LTDC_CLK_ENABLE();
 8000bac:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bae:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8000bb2:	645a      	str	r2, [r3, #68]	; 0x44
 8000bb4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bb6:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8000bba:	9201      	str	r2, [sp, #4]
 8000bbc:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_LTDC_FORCE_RESET();
 8000bbe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000bc0:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8000bc4:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_RCC_LTDC_RELEASE_RESET();
 8000bc6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000bc8:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8000bcc:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_RCC_DMA2D_CLK_ENABLE();
 8000bce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000bd0:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8000bd4:	631a      	str	r2, [r3, #48]	; 0x30
 8000bd6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000bd8:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 8000bdc:	9202      	str	r2, [sp, #8]
 8000bde:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_DMA2D_FORCE_RESET();
 8000be0:	691a      	ldr	r2, [r3, #16]
 8000be2:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8000be6:	611a      	str	r2, [r3, #16]
  __HAL_RCC_DMA2D_RELEASE_RESET();
 8000be8:	691a      	ldr	r2, [r3, #16]
 8000bea:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8000bee:	611a      	str	r2, [r3, #16]
  __HAL_RCC_DSI_CLK_ENABLE();
 8000bf0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bf2:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8000bf6:	645a      	str	r2, [r3, #68]	; 0x44
 8000bf8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bfa:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 8000bfe:	9203      	str	r2, [sp, #12]
 8000c00:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_DSI_FORCE_RESET();
 8000c02:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000c04:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8000c08:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_RCC_DSI_RELEASE_RESET();
 8000c0a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000c0c:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
 8000c10:	625a      	str	r2, [r3, #36]	; 0x24
  HAL_NVIC_SetPriority(LTDC_IRQn, 3, 0);
 8000c12:	2200      	movs	r2, #0
 8000c14:	f000 faee 	bl	80011f4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(LTDC_IRQn);
 8000c18:	2058      	movs	r0, #88	; 0x58
 8000c1a:	f000 fb1d 	bl	8001258 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2D_IRQn, 3, 0);
 8000c1e:	2200      	movs	r2, #0
 8000c20:	2103      	movs	r1, #3
 8000c22:	205a      	movs	r0, #90	; 0x5a
 8000c24:	f000 fae6 	bl	80011f4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8000c28:	205a      	movs	r0, #90	; 0x5a
 8000c2a:	f000 fb15 	bl	8001258 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DSI_IRQn, 3, 0);
 8000c2e:	2200      	movs	r2, #0
 8000c30:	2103      	movs	r1, #3
 8000c32:	2062      	movs	r0, #98	; 0x62
 8000c34:	f000 fade 	bl	80011f4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DSI_IRQn);
 8000c38:	2062      	movs	r0, #98	; 0x62
}
 8000c3a:	b005      	add	sp, #20
 8000c3c:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DSI_IRQn);
 8000c40:	f000 bb0a 	b.w	8001258 <HAL_NVIC_EnableIRQ>
 8000c44:	40023800 	.word	0x40023800

08000c48 <BSP_LCD_InitEx>:
{
 8000c48:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  hdsi_discovery.Instance = DSI;
 8000c4c:	4c59      	ldr	r4, [pc, #356]	; (8000db4 <BSP_LCD_InitEx+0x16c>)
{
 8000c4e:	4607      	mov	r7, r0
    LCD_Reset();
 8000c50:	f7ff fea8 	bl	80009a4 <LCD_Reset>
  hdsi_discovery.Init.TXEscapeCkdiv = laneByteClk_kHz/15620; 
 8000c54:	f04f 0801 	mov.w	r8, #1
  BSP_LCD_MspInit();
 8000c58:	f7ff ffa4 	bl	8000ba4 <BSP_LCD_MspInit>
  hdsi_discovery.Instance = DSI;
 8000c5c:	4b56      	ldr	r3, [pc, #344]	; (8000db8 <BSP_LCD_InitEx+0x170>)
  HAL_DSI_DeInit(&(hdsi_discovery));
 8000c5e:	4620      	mov	r0, r4
 8000c60:	f8df 9174 	ldr.w	r9, [pc, #372]	; 8000dd8 <BSP_LCD_InitEx+0x190>
  hdsi_discovery.Instance = DSI;
 8000c64:	6023      	str	r3, [r4, #0]
  HAL_DSI_DeInit(&(hdsi_discovery));
 8000c66:	f003 fd8a 	bl	800477e <HAL_DSI_DeInit>
  dsiPllInit.PLLIDF   = DSI_PLL_IN_DIV5;
 8000c6a:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8000c6e:	2305      	movs	r3, #5
  HAL_DSI_Init(&(hdsi_discovery), &(dsiPllInit));
 8000c70:	4620      	mov	r0, r4
  dsiPllInit.PLLIDF   = DSI_PLL_IN_DIV5;
 8000c72:	e9cd e301 	strd	lr, r3, [sp, #4]
  dsiPllInit.PLLODF  = DSI_PLL_OUT_DIV1;
 8000c76:	2300      	movs	r3, #0
 8000c78:	9303      	str	r3, [sp, #12]
  hdsi_discovery.Init.TXEscapeCkdiv = laneByteClk_kHz/15620; 
 8000c7a:	2304      	movs	r3, #4
  HAL_DSI_Init(&(hdsi_discovery), &(dsiPllInit));
 8000c7c:	eb0d 0103 	add.w	r1, sp, r3
  hdsi_discovery.Init.TXEscapeCkdiv = laneByteClk_kHz/15620; 
 8000c80:	e9c4 3802 	strd	r3, r8, [r4, #8]
  HAL_DSI_Init(&(hdsi_discovery), &(dsiPllInit));
 8000c84:	f000 fbda 	bl	800143c <HAL_DSI_Init>
  if(orientation == LCD_ORIENTATION_PORTRAIT)
 8000c88:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8000ddc <BSP_LCD_InitEx+0x194>
 8000c8c:	2f00      	cmp	r7, #0
 8000c8e:	f040 808a 	bne.w	8000da6 <BSP_LCD_InitEx+0x15e>
    lcd_x_size = OTM8009A_480X800_WIDTH;  /* 480 */
 8000c92:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8000c96:	f8c9 3000 	str.w	r3, [r9]
    lcd_y_size = OTM8009A_480X800_HEIGHT; /* 800 */                                
 8000c9a:	f44f 7348 	mov.w	r3, #800	; 0x320
  hdsivideo_handle.VirtualChannelID = LCD_OTM8009A_ID;
 8000c9e:	4c47      	ldr	r4, [pc, #284]	; (8000dbc <BSP_LCD_InitEx+0x174>)
  hdsivideo_handle.ColorCoding = LCD_DSI_PIXEL_DATA_FMT_RBG888;
 8000ca0:	2500      	movs	r5, #0
 8000ca2:	2105      	movs	r1, #5
    lcd_y_size = OTM8009A_800X480_HEIGHT; /* 480 */                                
 8000ca4:	f8c8 3000 	str.w	r3, [r8]
  hdsivideo_handle.HorizontalBackPorch       = (HBP * laneByteClk_kHz)/LcdClock;
 8000ca8:	2604      	movs	r6, #4
  HACT = lcd_x_size;
 8000caa:	f8d9 3000 	ldr.w	r3, [r9]
  hdsivideo_handle.VerticalBackPorch         = VBP;
 8000cae:	f04f 0a01 	mov.w	sl, #1
  VACT = lcd_y_size;
 8000cb2:	f8d8 2000 	ldr.w	r2, [r8]
  hdsivideo_handle.PacketSize                = HACT; /* Value depending on display orientation choice portrait/landscape */ 
 8000cb6:	6123      	str	r3, [r4, #16]
  hdsivideo_handle.LPHorizontalBackPorchEnable  = DSI_LP_HBP_ENABLE;   /* Allow sending LP commands during HBP period */
 8000cb8:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
  hdsivideo_handle.LPVerticalFrontPorchEnable = DSI_LP_VFP_ENABLE;   /* Allow sending LP commands during VFP period */
 8000cbc:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  HAL_DSI_ConfigVideoMode(&(hdsi_discovery), &(hdsivideo_handle));
 8000cc0:	483c      	ldr	r0, [pc, #240]	; (8000db4 <BSP_LCD_InitEx+0x16c>)
  hdsivideo_handle.DEPolarity = DSI_DATA_ENABLE_ACTIVE_HIGH;  
 8000cc2:	6265      	str	r5, [r4, #36]	; 0x24
  hdsivideo_handle.LPVACTLargestPacketSize = 0;
 8000cc4:	64e5      	str	r5, [r4, #76]	; 0x4c
  hdsivideo_handle.ColorCoding = LCD_DSI_PIXEL_DATA_FMT_RBG888;
 8000cc6:	e9c4 5100 	strd	r5, r1, [r4]
  hdsivideo_handle.Mode = DSI_VID_MODE_BURST; /* Mode Video burst ie : one LgP per line */
 8000cca:	2102      	movs	r1, #2
 8000ccc:	60e1      	str	r1, [r4, #12]
  hdsivideo_handle.NullPacketSize = 0xFFF;
 8000cce:	f640 71ff 	movw	r1, #4095	; 0xfff
  hdsivideo_handle.NumberOfChunks = 0;
 8000cd2:	e9c4 5105 	strd	r5, r1, [r4, #20]
  hdsivideo_handle.HorizontalBackPorch       = (HBP * laneByteClk_kHz)/LcdClock;
 8000cd6:	214d      	movs	r1, #77	; 0x4d
 8000cd8:	e9c4 610a 	strd	r6, r1, [r4, #40]	; 0x28
  hdsivideo_handle.HorizontalLine            = ((HACT + HSA + HBP + HFP) * laneByteClk_kHz)/LcdClock; /* Value depending on display orientation choice portrait/landscape */
 8000cdc:	f103 0146 	add.w	r1, r3, #70	; 0x46
 8000ce0:	f24f 4324 	movw	r3, #62500	; 0xf424
  hltdc_discovery.Init.HorizontalSync = (HSA - 1);
 8000ce4:	4e36      	ldr	r6, [pc, #216]	; (8000dc0 <BSP_LCD_InitEx+0x178>)
  hdsivideo_handle.HorizontalLine            = ((HACT + HSA + HBP + HFP) * laneByteClk_kHz)/LcdClock; /* Value depending on display orientation choice portrait/landscape */
 8000ce6:	434b      	muls	r3, r1
 8000ce8:	f646 3125 	movw	r1, #27429	; 0x6b25
 8000cec:	fbb3 f3f1 	udiv	r3, r3, r1
 8000cf0:	6323      	str	r3, [r4, #48]	; 0x30
  hdsivideo_handle.VerticalBackPorch         = VBP;
 8000cf2:	230f      	movs	r3, #15
  HAL_DSI_ConfigVideoMode(&(hdsi_discovery), &(hdsivideo_handle));
 8000cf4:	4621      	mov	r1, r4
  hdsivideo_handle.VerticalBackPorch         = VBP;
 8000cf6:	e9c4 a30d 	strd	sl, r3, [r4, #52]	; 0x34
  hdsivideo_handle.VerticalFrontPorch        = VFP;
 8000cfa:	2310      	movs	r3, #16
  hdsivideo_handle.VerticalActive            = VACT; /* Value depending on display orientation choice portrait/landscape */
 8000cfc:	e9c4 320f 	strd	r3, r2, [r4, #60]	; 0x3c
  hdsivideo_handle.LPCommandEnable = DSI_LP_COMMAND_ENABLE; /* Enable sending commands in mode LP (Low Power) */
 8000d00:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  hdsivideo_handle.LPLargestPacketSize = 16;
 8000d04:	e9c4 2311 	strd	r2, r3, [r4, #68]	; 0x44
  hdsivideo_handle.LPHorizontalBackPorchEnable  = DSI_LP_HBP_ENABLE;   /* Allow sending LP commands during HBP period */
 8000d08:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  hdsivideo_handle.LPVerticalSyncActiveEnable = DSI_LP_VSYNC_ENABLE; /* Allow sending LP commands during VSync = VSA period */
 8000d0c:	f44f 7200 	mov.w	r2, #512	; 0x200
  hdsivideo_handle.LPHorizontalBackPorchEnable  = DSI_LP_HBP_ENABLE;   /* Allow sending LP commands during HBP period */
 8000d10:	e9c4 c314 	strd	ip, r3, [r4, #80]	; 0x50
  hdsivideo_handle.LPVerticalFrontPorchEnable = DSI_LP_VFP_ENABLE;   /* Allow sending LP commands during VFP period */
 8000d14:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000d18:	e9c4 e316 	strd	lr, r3, [r4, #88]	; 0x58
  hdsivideo_handle.LPVerticalSyncActiveEnable = DSI_LP_VSYNC_ENABLE; /* Allow sending LP commands during VSync = VSA period */
 8000d1c:	f44f 7380 	mov.w	r3, #256	; 0x100
  hdsivideo_handle.HSPolarity = DSI_HSYNC_ACTIVE_HIGH;
 8000d20:	e9c4 5507 	strd	r5, r5, [r4, #28]
  hdsivideo_handle.LPVerticalSyncActiveEnable = DSI_LP_VSYNC_ENABLE; /* Allow sending LP commands during VSync = VSA period */
 8000d24:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  HAL_DSI_ConfigVideoMode(&(hdsi_discovery), &(hdsivideo_handle));
 8000d28:	f000 fc38 	bl	800159c <HAL_DSI_ConfigVideoMode>
  hltdc_discovery.Init.AccumulatedHBP = (HSA + HBP - 1);
 8000d2c:	2323      	movs	r3, #35	; 0x23
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8000d2e:	4825      	ldr	r0, [pc, #148]	; (8000dc4 <BSP_LCD_InitEx+0x17c>)
  hltdc_discovery.Init.AccumulatedHBP = (HSA + HBP - 1);
 8000d30:	61f3      	str	r3, [r6, #28]
  hltdc_discovery.Init.AccumulatedActiveW = (lcd_x_size + HSA + HBP - 1);
 8000d32:	f8d9 3000 	ldr.w	r3, [r9]
  hltdc_discovery.Init.HorizontalSync = (HSA - 1);
 8000d36:	f8c6 a014 	str.w	sl, [r6, #20]
  hltdc_discovery.Init.AccumulatedActiveW = (lcd_x_size + HSA + HBP - 1);
 8000d3a:	f103 0223 	add.w	r2, r3, #35	; 0x23
  hltdc_discovery.LayerCfg->ImageWidth  = lcd_x_size;
 8000d3e:	6633      	str	r3, [r6, #96]	; 0x60
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_2;
 8000d40:	62c5      	str	r5, [r0, #44]	; 0x2c
  hltdc_discovery.Init.AccumulatedActiveW = (lcd_x_size + HSA + HBP - 1);
 8000d42:	6272      	str	r2, [r6, #36]	; 0x24
  hltdc_discovery.Init.TotalWidth = (lcd_x_size + HSA + HBP + HFP - 1);
 8000d44:	f103 0245 	add.w	r2, r3, #69	; 0x45
  hltdc_discovery.LayerCfg->ImageHeight = lcd_y_size;   
 8000d48:	f8d8 3000 	ldr.w	r3, [r8]
  hltdc_discovery.Init.TotalWidth = (lcd_x_size + HSA + HBP + HFP - 1);
 8000d4c:	62f2      	str	r2, [r6, #44]	; 0x2c
  hltdc_discovery.LayerCfg->ImageHeight = lcd_y_size;   
 8000d4e:	6673      	str	r3, [r6, #100]	; 0x64
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8000d50:	2308      	movs	r3, #8
 8000d52:	6003      	str	r3, [r0, #0]
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
 8000d54:	f44f 73c0 	mov.w	r3, #384	; 0x180
 8000d58:	6143      	str	r3, [r0, #20]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 7;
 8000d5a:	2307      	movs	r3, #7
 8000d5c:	61c3      	str	r3, [r0, #28]
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8000d5e:	f000 fe79 	bl	8001a54 <HAL_RCCEx_PeriphCLKConfig>
  hltdc_discovery.Instance = LTDC;
 8000d62:	4b19      	ldr	r3, [pc, #100]	; (8000dc8 <BSP_LCD_InitEx+0x180>)
  HAL_LTDC_StructInitFromVideoConfig(&(hltdc_discovery), &(hdsivideo_handle));
 8000d64:	4621      	mov	r1, r4
  hltdc_discovery.Init.Backcolor.Blue = 0;
 8000d66:	86b5      	strh	r5, [r6, #52]	; 0x34
  HAL_LTDC_StructInitFromVideoConfig(&(hltdc_discovery), &(hdsivideo_handle));
 8000d68:	4630      	mov	r0, r6
  hltdc_discovery.Instance = LTDC;
 8000d6a:	6033      	str	r3, [r6, #0]
  hltdc_discovery.Init.Backcolor.Red = 0;
 8000d6c:	f886 5036 	strb.w	r5, [r6, #54]	; 0x36
  hltdc_discovery.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 8000d70:	6135      	str	r5, [r6, #16]
  HAL_LTDC_StructInitFromVideoConfig(&(hltdc_discovery), &(hdsivideo_handle));
 8000d72:	f003 fe92 	bl	8004a9a <HAL_LTDCEx_StructInitFromVideoConfig>
  HAL_LTDC_Init(&hltdc_discovery);
 8000d76:	4630      	mov	r0, r6
 8000d78:	f000 fe00 	bl	800197c <HAL_LTDC_Init>
  HAL_DSI_Start(&hdsi_discovery);
 8000d7c:	480d      	ldr	r0, [pc, #52]	; (8000db4 <BSP_LCD_InitEx+0x16c>)
 8000d7e:	f003 fd48 	bl	8004812 <HAL_DSI_Start>
  BSP_SDRAM_Init();
 8000d82:	f001 fdbb 	bl	80028fc <BSP_SDRAM_Init>
  DrawProp[ActiveLayer].pFont = fonts;
 8000d86:	4b11      	ldr	r3, [pc, #68]	; (8000dcc <BSP_LCD_InitEx+0x184>)
 8000d88:	4a11      	ldr	r2, [pc, #68]	; (8000dd0 <BSP_LCD_InitEx+0x188>)
 8000d8a:	210c      	movs	r1, #12
 8000d8c:	681b      	ldr	r3, [r3, #0]
  OTM8009A_Init(OTM8009A_FORMAT_RGB888, orientation);
 8000d8e:	4628      	mov	r0, r5
  DrawProp[ActiveLayer].pFont = fonts;
 8000d90:	fb01 2303 	mla	r3, r1, r3, r2
 8000d94:	4a0f      	ldr	r2, [pc, #60]	; (8000dd4 <BSP_LCD_InitEx+0x18c>)
  OTM8009A_Init(OTM8009A_FORMAT_RGB888, orientation);
 8000d96:	4639      	mov	r1, r7
  DrawProp[ActiveLayer].pFont = fonts;
 8000d98:	609a      	str	r2, [r3, #8]
  OTM8009A_Init(OTM8009A_FORMAT_RGB888, orientation);
 8000d9a:	f001 fa5b 	bl	8002254 <OTM8009A_Init>
}
 8000d9e:	4628      	mov	r0, r5
 8000da0:	b004      	add	sp, #16
 8000da2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lcd_x_size = OTM8009A_800X480_WIDTH;  /* 800 */
 8000da6:	f44f 7348 	mov.w	r3, #800	; 0x320
 8000daa:	f8c9 3000 	str.w	r3, [r9]
    lcd_y_size = OTM8009A_800X480_HEIGHT; /* 480 */                                
 8000dae:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8000db2:	e774      	b.n	8000c9e <BSP_LCD_InitEx+0x56>
 8000db4:	200201dc 	.word	0x200201dc
 8000db8:	40016c00 	.word	0x40016c00
 8000dbc:	200201f8 	.word	0x200201f8
 8000dc0:	20020264 	.word	0x20020264
 8000dc4:	200200e8 	.word	0x200200e8
 8000dc8:	40016800 	.word	0x40016800
 8000dcc:	200200cc 	.word	0x200200cc
 8000dd0:	200200d0 	.word	0x200200d0
 8000dd4:	200212d4 	.word	0x200212d4
 8000dd8:	200212c8 	.word	0x200212c8
 8000ddc:	200212cc 	.word	0x200212cc

08000de0 <BSP_LCD_DrawPixel>:
  return (lcd_x_size);
 8000de0:	4b07      	ldr	r3, [pc, #28]	; (8000e00 <BSP_LCD_DrawPixel+0x20>)
  *(__IO uint32_t*) (hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 8000de2:	681b      	ldr	r3, [r3, #0]
 8000de4:	fb03 0101 	mla	r1, r3, r1, r0
 8000de8:	4b06      	ldr	r3, [pc, #24]	; (8000e04 <BSP_LCD_DrawPixel+0x24>)
 8000dea:	4807      	ldr	r0, [pc, #28]	; (8000e08 <BSP_LCD_DrawPixel+0x28>)
 8000dec:	681b      	ldr	r3, [r3, #0]
{
 8000dee:	b510      	push	{r4, lr}
  *(__IO uint32_t*) (hltdc_discovery.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 8000df0:	2434      	movs	r4, #52	; 0x34
 8000df2:	fb04 0303 	mla	r3, r4, r3, r0
 8000df6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8000df8:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
}
 8000dfc:	bd10      	pop	{r4, pc}
 8000dfe:	bf00      	nop
 8000e00:	200212c8 	.word	0x200212c8
 8000e04:	200200cc 	.word	0x200200cc
 8000e08:	20020264 	.word	0x20020264

08000e0c <BSP_LCD_DisplayChar>:
{
 8000e0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e10:	b087      	sub	sp, #28
  DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 8000e12:	4f30      	ldr	r7, [pc, #192]	; (8000ed4 <BSP_LCD_DisplayChar+0xc8>)
 8000e14:	3a20      	subs	r2, #32
  for(i = 0; i < height; i++)
 8000e16:	f04f 0900 	mov.w	r9, #0
{
 8000e1a:	e9cd 0102 	strd	r0, r1, [sp, #8]
  DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 8000e1e:	482e      	ldr	r0, [pc, #184]	; (8000ed8 <BSP_LCD_DisplayChar+0xcc>)
 8000e20:	210c      	movs	r1, #12
 8000e22:	6803      	ldr	r3, [r0, #0]
 8000e24:	9005      	str	r0, [sp, #20]
 8000e26:	fb01 7303 	mla	r3, r1, r3, r7
 8000e2a:	6899      	ldr	r1, [r3, #8]
    DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
 8000e2c:	f8b1 b004 	ldrh.w	fp, [r1, #4]
 8000e30:	88cb      	ldrh	r3, [r1, #6]
 8000e32:	f10b 0607 	add.w	r6, fp, #7
 8000e36:	6809      	ldr	r1, [r1, #0]
 8000e38:	9300      	str	r3, [sp, #0]
 8000e3a:	10f6      	asrs	r6, r6, #3
  offset =  8 *((width + 7)/8) -  width ;
 8000e3c:	ebcb 04c6 	rsb	r4, fp, r6, lsl #3
 8000e40:	b2e3      	uxtb	r3, r4
 8000e42:	9301      	str	r3, [sp, #4]
    DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
 8000e44:	9b00      	ldr	r3, [sp, #0]
 8000e46:	fb06 f503 	mul.w	r5, r6, r3
 8000e4a:	fb05 1502 	mla	r5, r5, r2, r1
 8000e4e:	9b03      	ldr	r3, [sp, #12]
 8000e50:	eb03 0a09 	add.w	sl, r3, r9
  for(i = 0; i < height; i++)
 8000e54:	9b00      	ldr	r3, [sp, #0]
 8000e56:	4599      	cmp	r9, r3
 8000e58:	fa1f fa8a 	uxth.w	sl, sl
 8000e5c:	d302      	bcc.n	8000e64 <BSP_LCD_DisplayChar+0x58>
}
 8000e5e:	b007      	add	sp, #28
 8000e60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(((width + 7)/8))
 8000e64:	2e01      	cmp	r6, #1
 8000e66:	782c      	ldrb	r4, [r5, #0]
 8000e68:	d004      	beq.n	8000e74 <BSP_LCD_DisplayChar+0x68>
 8000e6a:	2e02      	cmp	r6, #2
 8000e6c:	d10f      	bne.n	8000e8e <BSP_LCD_DisplayChar+0x82>
      line =  (pchar[0]<< 8) | pchar[1];
 8000e6e:	882c      	ldrh	r4, [r5, #0]
 8000e70:	ba64      	rev16	r4, r4
 8000e72:	b2a4      	uxth	r4, r4
      if(line & (1 << (width- j + offset- 1)))
 8000e74:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
 8000e78:	9b01      	ldr	r3, [sp, #4]
    for (j = 0; j < width; j++)
 8000e7a:	f04f 0800 	mov.w	r8, #0
      if(line & (1 << (width- j + offset- 1)))
 8000e7e:	18d3      	adds	r3, r2, r3
 8000e80:	9304      	str	r3, [sp, #16]
    for (j = 0; j < width; j++)
 8000e82:	45c3      	cmp	fp, r8
 8000e84:	d80a      	bhi.n	8000e9c <BSP_LCD_DisplayChar+0x90>
  for(i = 0; i < height; i++)
 8000e86:	f109 0901 	add.w	r9, r9, #1
 8000e8a:	4435      	add	r5, r6
 8000e8c:	e7df      	b.n	8000e4e <BSP_LCD_DisplayChar+0x42>
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
 8000e8e:	786a      	ldrb	r2, [r5, #1]
 8000e90:	0424      	lsls	r4, r4, #16
 8000e92:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
 8000e96:	78aa      	ldrb	r2, [r5, #2]
 8000e98:	4314      	orrs	r4, r2
      break;
 8000e9a:	e7eb      	b.n	8000e74 <BSP_LCD_DisplayChar+0x68>
      if(line & (1 << (width- j + offset- 1)))
 8000e9c:	9b02      	ldr	r3, [sp, #8]
 8000e9e:	2101      	movs	r1, #1
 8000ea0:	eb03 0008 	add.w	r0, r3, r8
 8000ea4:	9b05      	ldr	r3, [sp, #20]
 8000ea6:	681a      	ldr	r2, [r3, #0]
 8000ea8:	b280      	uxth	r0, r0
 8000eaa:	9b04      	ldr	r3, [sp, #16]
 8000eac:	eba3 0c08 	sub.w	ip, r3, r8
    for (j = 0; j < width; j++)
 8000eb0:	f108 0801 	add.w	r8, r8, #1
      if(line & (1 << (width- j + offset- 1)))
 8000eb4:	fa01 f10c 	lsl.w	r1, r1, ip
 8000eb8:	4221      	tst	r1, r4
 8000eba:	f04f 010c 	mov.w	r1, #12
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
 8000ebe:	bf14      	ite	ne
 8000ec0:	434a      	mulne	r2, r1
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].BackColor);
 8000ec2:	fb01 7202 	mlaeq	r2, r1, r2, r7
 8000ec6:	4651      	mov	r1, sl
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
 8000ec8:	bf14      	ite	ne
 8000eca:	58ba      	ldrne	r2, [r7, r2]
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].BackColor);
 8000ecc:	6852      	ldreq	r2, [r2, #4]
 8000ece:	f7ff ff87 	bl	8000de0 <BSP_LCD_DrawPixel>
 8000ed2:	e7d6      	b.n	8000e82 <BSP_LCD_DisplayChar+0x76>
 8000ed4:	200200d0 	.word	0x200200d0
 8000ed8:	200200cc 	.word	0x200200cc

08000edc <BSP_LCD_DisplayStringAt>:
{
 8000edc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000ee0:	460f      	mov	r7, r1
 8000ee2:	4604      	mov	r4, r0
 8000ee4:	4616      	mov	r6, r2
  uint8_t  *ptr = Text;
 8000ee6:	4611      	mov	r1, r2
 8000ee8:	460a      	mov	r2, r1
  while (*ptr++) size ++ ;
 8000eea:	f811 0b01 	ldrb.w	r0, [r1], #1
 8000eee:	2800      	cmp	r0, #0
 8000ef0:	d1fa      	bne.n	8000ee8 <BSP_LCD_DisplayStringAt+0xc>
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8000ef2:	4922      	ldr	r1, [pc, #136]	; (8000f7c <BSP_LCD_DisplayStringAt+0xa0>)
 8000ef4:	250c      	movs	r5, #12
 8000ef6:	4822      	ldr	r0, [pc, #136]	; (8000f80 <BSP_LCD_DisplayStringAt+0xa4>)
  switch (Mode)
 8000ef8:	2b01      	cmp	r3, #1
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8000efa:	6809      	ldr	r1, [r1, #0]
 8000efc:	fb05 0101 	mla	r1, r5, r1, r0
  return (lcd_x_size);
 8000f00:	4d20      	ldr	r5, [pc, #128]	; (8000f84 <BSP_LCD_DisplayStringAt+0xa8>)
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8000f02:	f8d1 8008 	ldr.w	r8, [r1, #8]
 8000f06:	6828      	ldr	r0, [r5, #0]
 8000f08:	f8b8 c004 	ldrh.w	ip, [r8, #4]
 8000f0c:	fbb0 f1fc 	udiv	r1, r0, ip
  switch (Mode)
 8000f10:	d01d      	beq.n	8000f4e <BSP_LCD_DisplayStringAt+0x72>
 8000f12:	2b02      	cmp	r3, #2
 8000f14:	d023      	beq.n	8000f5e <BSP_LCD_DisplayStringAt+0x82>
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
 8000f16:	b223      	sxth	r3, r4
    refcolumn = 1;
 8000f18:	f04f 0900 	mov.w	r9, #0
 8000f1c:	2b00      	cmp	r3, #0
 8000f1e:	bfd8      	it	le
 8000f20:	2401      	movle	r4, #1
  while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 8000f22:	6829      	ldr	r1, [r5, #0]
 8000f24:	fa1f f389 	uxth.w	r3, r9
 8000f28:	f8b8 0004 	ldrh.w	r0, [r8, #4]
 8000f2c:	f816 2009 	ldrb.w	r2, [r6, r9]
  return (lcd_x_size);
 8000f30:	f109 0901 	add.w	r9, r9, #1
  while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 8000f34:	fb00 1313 	mls	r3, r0, r3, r1
 8000f38:	b29b      	uxth	r3, r3
 8000f3a:	4283      	cmp	r3, r0
 8000f3c:	bf34      	ite	cc
 8000f3e:	2100      	movcc	r1, #0
 8000f40:	2101      	movcs	r1, #1
 8000f42:	2a00      	cmp	r2, #0
 8000f44:	bf08      	it	eq
 8000f46:	2100      	moveq	r1, #0
 8000f48:	b979      	cbnz	r1, 8000f6a <BSP_LCD_DisplayStringAt+0x8e>
}
 8000f4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      refcolumn = Xpos + ((xsize - size)* DrawProp[ActiveLayer].pFont->Width) / 2;
 8000f4e:	1ab2      	subs	r2, r6, r2
 8000f50:	1850      	adds	r0, r2, r1
 8000f52:	fb0c f000 	mul.w	r0, ip, r0
 8000f56:	eb04 0050 	add.w	r0, r4, r0, lsr #1
      refcolumn = - Xpos + ((xsize - size)*DrawProp[ActiveLayer].pFont->Width);
 8000f5a:	b284      	uxth	r4, r0
      break;
 8000f5c:	e7db      	b.n	8000f16 <BSP_LCD_DisplayStringAt+0x3a>
      refcolumn = - Xpos + ((xsize - size)*DrawProp[ActiveLayer].pFont->Width);
 8000f5e:	1ab0      	subs	r0, r6, r2
 8000f60:	4408      	add	r0, r1
 8000f62:	fb10 f00c 	smulbb	r0, r0, ip
 8000f66:	1b00      	subs	r0, r0, r4
 8000f68:	e7f7      	b.n	8000f5a <BSP_LCD_DisplayStringAt+0x7e>
    BSP_LCD_DisplayChar(refcolumn, Ypos, *Text);
 8000f6a:	4620      	mov	r0, r4
 8000f6c:	4639      	mov	r1, r7
 8000f6e:	f7ff ff4d 	bl	8000e0c <BSP_LCD_DisplayChar>
    refcolumn += DrawProp[ActiveLayer].pFont->Width;
 8000f72:	f8b8 0004 	ldrh.w	r0, [r8, #4]
 8000f76:	4420      	add	r0, r4
 8000f78:	b284      	uxth	r4, r0
    i++;
 8000f7a:	e7d2      	b.n	8000f22 <BSP_LCD_DisplayStringAt+0x46>
 8000f7c:	200200cc 	.word	0x200200cc
 8000f80:	200200d0 	.word	0x200200d0
 8000f84:	200212c8 	.word	0x200212c8

08000f88 <z_pinmux_stm32_set>:
 *
 * @return 0 on success, error otherwise
 */
int z_pinmux_stm32_set(u32_t pin, u32_t func,
				struct device *clk)
{
 8000f88:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8000f8a:	4604      	mov	r4, r0
	/* make sure to enable port clock first */
	if (enable_port(STM32_PORT(pin), clk)) {
 8000f8c:	0906      	lsrs	r6, r0, #4
{
 8000f8e:	460d      	mov	r5, r1
	if (!clk) {
 8000f90:	4610      	mov	r0, r2
 8000f92:	b912      	cbnz	r2, 8000f9a <z_pinmux_stm32_set+0x12>
 8000f94:	4811      	ldr	r0, [pc, #68]	; (8000fdc <z_pinmux_stm32_set+0x54>)
 8000f96:	f002 fabd 	bl	8003514 <z_impl_device_get_binding>
	pclken.bus = STM32_CLOCK_BUS_GPIO;
 8000f9a:	2300      	movs	r3, #0
 8000f9c:	9300      	str	r3, [sp, #0]
	pclken.enr = ports_enable[port];
 8000f9e:	4b10      	ldr	r3, [pc, #64]	; (8000fe0 <z_pinmux_stm32_set+0x58>)
 8000fa0:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8000fa4:	9301      	str	r3, [sp, #4]
	if (pclken.enr == STM32_PORT_NOT_AVAILABLE) {
 8000fa6:	3301      	adds	r3, #1
 8000fa8:	d102      	bne.n	8000fb0 <z_pinmux_stm32_set+0x28>
		return -EIO;
 8000faa:	f06f 0004 	mvn.w	r0, #4
 8000fae:	e012      	b.n	8000fd6 <z_pinmux_stm32_set+0x4e>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
 8000fb0:	6843      	ldr	r3, [r0, #4]
 8000fb2:	4669      	mov	r1, sp
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	4798      	blx	r3
	if (enable_port(STM32_PORT(pin), clk)) {
 8000fb8:	2800      	cmp	r0, #0
 8000fba:	d1f6      	bne.n	8000faa <z_pinmux_stm32_set+0x22>
	u32_t offset = STM32_PORT(pin) * GPIO_REG_SIZE;
 8000fbc:	1120      	asrs	r0, r4, #4
	return gpio_stm32_configure((u32_t *)port_base,
 8000fbe:	f005 030f 	and.w	r3, r5, #15
 8000fc2:	462a      	mov	r2, r5
 8000fc4:	f004 010f 	and.w	r1, r4, #15
	u32_t offset = STM32_PORT(pin) * GPIO_REG_SIZE;
 8000fc8:	0280      	lsls	r0, r0, #10
	return gpio_stm32_configure((u32_t *)port_base,
 8000fca:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8000fce:	f500 3000 	add.w	r0, r0, #131072	; 0x20000
 8000fd2:	f003 ff33 	bl	8004e3c <gpio_stm32_configure>
	}

	return stm32_pin_configure(pin, func, func & STM32_AFR_MASK);
}
 8000fd6:	b002      	add	sp, #8
 8000fd8:	bd70      	pop	{r4, r5, r6, pc}
 8000fda:	bf00      	nop
 8000fdc:	08005d41 	.word	0x08005d41
 8000fe0:	08005afc 	.word	0x08005afc

08000fe4 <stm32_setup_pins>:
 * @param pinconf  board pin configuration array
 * @param pins     array size
 */
void stm32_setup_pins(const struct pin_config *pinconf,
		      size_t pins)
{
 8000fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000fe6:	4604      	mov	r4, r0
 8000fe8:	4809      	ldr	r0, [pc, #36]	; (8001010 <stm32_setup_pins+0x2c>)
 8000fea:	460e      	mov	r6, r1
	struct device *clk;
	int i;

	clk = device_get_binding(STM32_CLOCK_CONTROL_NAME);

	for (i = 0; i < pins; i++) {
 8000fec:	2500      	movs	r5, #0
 8000fee:	f002 fa91 	bl	8003514 <z_impl_device_get_binding>
 8000ff2:	4607      	mov	r7, r0
 8000ff4:	42b5      	cmp	r5, r6
 8000ff6:	f104 0408 	add.w	r4, r4, #8
 8000ffa:	d100      	bne.n	8000ffe <stm32_setup_pins+0x1a>
		z_pinmux_stm32_set(pinconf[i].pin_num,
				  pinconf[i].mode,
				  clk);
	}
}
 8000ffc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		z_pinmux_stm32_set(pinconf[i].pin_num,
 8000ffe:	463a      	mov	r2, r7
 8001000:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8001004:	f814 0c08 	ldrb.w	r0, [r4, #-8]
	for (i = 0; i < pins; i++) {
 8001008:	3501      	adds	r5, #1
		z_pinmux_stm32_set(pinconf[i].pin_num,
 800100a:	f7ff ffbd 	bl	8000f88 <z_pinmux_stm32_set>
 800100e:	e7f1      	b.n	8000ff4 <stm32_setup_pins+0x10>
 8001010:	08005d41 	.word	0x08005d41

08001014 <elapsed>:
	 * the double-overflow if called at the end of a cycle.  There
	 * is no safe algorithm here, so we split the difference by
	 * reading CTRL twice, suppressing the second overflow bit if
	 * VAL was "about to overflow".
	 */
	ctrl1 = SysTick->CTRL;
 8001014:	4b0f      	ldr	r3, [pc, #60]	; (8001054 <elapsed+0x40>)
{
 8001016:	b530      	push	{r4, r5, lr}
	ctrl1 = SysTick->CTRL;
 8001018:	681a      	ldr	r2, [r3, #0]
	val = SysTick->VAL & COUNTER_MAX;
 800101a:	6899      	ldr	r1, [r3, #8]
	ctrl2 = SysTick->CTRL;
 800101c:	681d      	ldr	r5, [r3, #0]

	overflow_cyc += (ctrl1 & SysTick_CTRL_COUNTFLAG_Msk) ? last_load : 0;
 800101e:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
 8001022:	4b0d      	ldr	r3, [pc, #52]	; (8001058 <elapsed+0x44>)
	val = SysTick->VAL & COUNTER_MAX;
 8001024:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	overflow_cyc += (ctrl1 & SysTick_CTRL_COUNTFLAG_Msk) ? last_load : 0;
 8001028:	681c      	ldr	r4, [r3, #0]
 800102a:	4b0c      	ldr	r3, [pc, #48]	; (800105c <elapsed+0x48>)
 800102c:	bf18      	it	ne
 800102e:	4622      	movne	r2, r4
	if (val > VAL_ABOUT_TO_WRAP) {
 8001030:	2908      	cmp	r1, #8
	overflow_cyc += (ctrl1 & SysTick_CTRL_COUNTFLAG_Msk) ? last_load : 0;
 8001032:	6818      	ldr	r0, [r3, #0]
 8001034:	4402      	add	r2, r0
 8001036:	601a      	str	r2, [r3, #0]
	if (val > VAL_ABOUT_TO_WRAP) {
 8001038:	d907      	bls.n	800104a <elapsed+0x36>
		int wrap = ctrl2 & SysTick_CTRL_COUNTFLAG_Msk;

		overflow_cyc += (wrap != 0) ? last_load : 0;
 800103a:	f415 3f80 	tst.w	r5, #65536	; 0x10000
 800103e:	681a      	ldr	r2, [r3, #0]
 8001040:	bf14      	ite	ne
 8001042:	4620      	movne	r0, r4
 8001044:	2000      	moveq	r0, #0
 8001046:	4402      	add	r2, r0
 8001048:	601a      	str	r2, [r3, #0]
	}

	return (last_load - val) + overflow_cyc;
 800104a:	6818      	ldr	r0, [r3, #0]
 800104c:	4420      	add	r0, r4
}
 800104e:	1a40      	subs	r0, r0, r1
 8001050:	bd30      	pop	{r4, r5, pc}
 8001052:	bf00      	nop
 8001054:	e000e010 	.word	0xe000e010
 8001058:	2002031c 	.word	0x2002031c
 800105c:	20020320 	.word	0x20020320

08001060 <z_clock_isr>:

/* Callout out of platform assembly, not hooked via IRQ_CONNECT... */
void z_clock_isr(void *arg)
{
 8001060:	b508      	push	{r3, lr}
	ARG_UNUSED(arg);
	u32_t dticks;

	cycle_count += last_load;
 8001062:	4a0d      	ldr	r2, [pc, #52]	; (8001098 <z_clock_isr+0x38>)
 8001064:	4b0d      	ldr	r3, [pc, #52]	; (800109c <z_clock_isr+0x3c>)
 8001066:	6812      	ldr	r2, [r2, #0]
 8001068:	6818      	ldr	r0, [r3, #0]
 800106a:	4410      	add	r0, r2
	dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
 800106c:	4a0c      	ldr	r2, [pc, #48]	; (80010a0 <z_clock_isr+0x40>)
 800106e:	6811      	ldr	r1, [r2, #0]
	cycle_count += last_load;
 8001070:	6018      	str	r0, [r3, #0]
	dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
 8001072:	1a40      	subs	r0, r0, r1
 8001074:	4b0b      	ldr	r3, [pc, #44]	; (80010a4 <z_clock_isr+0x44>)
 8001076:	fbb0 f0f3 	udiv	r0, r0, r3
	announced_cycles += dticks * CYC_PER_TICK;
 800107a:	fb03 1300 	mla	r3, r3, r0, r1
 800107e:	6013      	str	r3, [r2, #0]

	overflow_cyc = SysTick->CTRL; /* Reset overflow flag */
 8001080:	4b09      	ldr	r3, [pc, #36]	; (80010a8 <z_clock_isr+0x48>)
 8001082:	681a      	ldr	r2, [r3, #0]
 8001084:	4b09      	ldr	r3, [pc, #36]	; (80010ac <z_clock_isr+0x4c>)
 8001086:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
 8001088:	2200      	movs	r2, #0
 800108a:	601a      	str	r2, [r3, #0]

	z_clock_announce(TICKLESS ? dticks : 1);
 800108c:	f002 fef8 	bl	8003e80 <z_clock_announce>
	z_ExcExit();
}
 8001090:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_ExcExit();
 8001094:	f001 bc6e 	b.w	8002974 <_IntExit>
 8001098:	2002031c 	.word	0x2002031c
 800109c:	20020318 	.word	0x20020318
 80010a0:	20020314 	.word	0x20020314
 80010a4:	00034bc0 	.word	0x00034bc0
 80010a8:	e000e010 	.word	0xe000e010
 80010ac:	20020320 	.word	0x20020320

080010b0 <z_clock_driver_init>:
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80010b0:	4b08      	ldr	r3, [pc, #32]	; (80010d4 <z_clock_driver_init+0x24>)
 80010b2:	2210      	movs	r2, #16

int z_clock_driver_init(struct device *device)
{
	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
	overflow_cyc = 0U;
 80010b4:	2000      	movs	r0, #0
 80010b6:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	last_load = CYC_PER_TICK - 1;
 80010ba:	4a07      	ldr	r2, [pc, #28]	; (80010d8 <z_clock_driver_init+0x28>)
 80010bc:	4b07      	ldr	r3, [pc, #28]	; (80010dc <z_clock_driver_init+0x2c>)
 80010be:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
 80010c0:	4b07      	ldr	r3, [pc, #28]	; (80010e0 <z_clock_driver_init+0x30>)
 80010c2:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
 80010c4:	4b07      	ldr	r3, [pc, #28]	; (80010e4 <z_clock_driver_init+0x34>)
 80010c6:	605a      	str	r2, [r3, #4]
	SysTick->VAL = 0; /* resets timer to last_load */
 80010c8:	6098      	str	r0, [r3, #8]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 80010ca:	681a      	ldr	r2, [r3, #0]
 80010cc:	f042 0207 	orr.w	r2, r2, #7
 80010d0:	601a      	str	r2, [r3, #0]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
 80010d2:	4770      	bx	lr
 80010d4:	e000ed00 	.word	0xe000ed00
 80010d8:	00034bbf 	.word	0x00034bbf
 80010dc:	2002031c 	.word	0x2002031c
 80010e0:	20020320 	.word	0x20020320
 80010e4:	e000e010 	.word	0xe000e010

080010e8 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
 80010e8:	b570      	push	{r4, r5, r6, lr}
 80010ea:	4c21      	ldr	r4, [pc, #132]	; (8001170 <z_clock_set_timeout+0x88>)
	 * need to wake up multiple times per second.  If the kernel
	 * allows us to miss tick announcements in idle, then shut off
	 * the counter. (Note: we can assume if idle==true that
	 * interrupts are already disabled)
	 */
	if (IS_ENABLED(CONFIG_TICKLESS_IDLE) && idle && ticks == K_FOREVER) {
 80010ec:	b151      	cbz	r1, 8001104 <z_clock_set_timeout+0x1c>
 80010ee:	1c43      	adds	r3, r0, #1
 80010f0:	d108      	bne.n	8001104 <z_clock_set_timeout+0x1c>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 80010f2:	4a20      	ldr	r2, [pc, #128]	; (8001174 <z_clock_set_timeout+0x8c>)
 80010f4:	6813      	ldr	r3, [r2, #0]
 80010f6:	f023 0301 	bic.w	r3, r3, #1
 80010fa:	6013      	str	r3, [r2, #0]
		last_load = TIMER_STOPPED;
 80010fc:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
 8001100:	6023      	str	r3, [r4, #0]
	SysTick->LOAD = last_load - 1;
	SysTick->VAL = 0; /* resets timer to last_load */

	k_spin_unlock(&lock, key);
#endif
}
 8001102:	bd70      	pop	{r4, r5, r6, pc}
	ticks = MIN(MAX_TICKS, MAX(ticks - 1, 0));
 8001104:	3801      	subs	r0, #1
 8001106:	284c      	cmp	r0, #76	; 0x4c
 8001108:	dc2c      	bgt.n	8001164 <z_clock_set_timeout+0x7c>
	delay = (ticks == 0) ? MIN_DELAY : ticks * CYC_PER_TICK;
 800110a:	2800      	cmp	r0, #0
 800110c:	dd2c      	ble.n	8001168 <z_clock_set_timeout+0x80>
 800110e:	4e1a      	ldr	r6, [pc, #104]	; (8001178 <z_clock_set_timeout+0x90>)
 8001110:	4346      	muls	r6, r0
	__asm__ volatile(
 8001112:	f04f 0310 	mov.w	r3, #16
 8001116:	f3ef 8511 	mrs	r5, BASEPRI
 800111a:	f383 8811 	msr	BASEPRI, r3
 800111e:	f3bf 8f6f 	isb	sy
	cycle_count += elapsed();
 8001122:	f7ff ff77 	bl	8001014 <elapsed>
 8001126:	4b15      	ldr	r3, [pc, #84]	; (800117c <z_clock_set_timeout+0x94>)
	delay = ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
 8001128:	4913      	ldr	r1, [pc, #76]	; (8001178 <z_clock_set_timeout+0x90>)
	cycle_count += elapsed();
 800112a:	681a      	ldr	r2, [r3, #0]
 800112c:	4410      	add	r0, r2
 800112e:	6018      	str	r0, [r3, #0]
	delay = delay + (cycle_count - announced_cycles);
 8001130:	4b13      	ldr	r3, [pc, #76]	; (8001180 <z_clock_set_timeout+0x98>)
 8001132:	681a      	ldr	r2, [r3, #0]
	delay = ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
 8001134:	f5c2 3352 	rsb	r3, r2, #215040	; 0x34800
 8001138:	f203 33bf 	addw	r3, r3, #959	; 0x3bf
 800113c:	4433      	add	r3, r6
 800113e:	4403      	add	r3, r0
	last_load = delay - (cycle_count - announced_cycles);
 8001140:	1a10      	subs	r0, r2, r0
	overflow_cyc = 0U;
 8001142:	2200      	movs	r2, #0
	delay = ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
 8001144:	fbb3 f3f1 	udiv	r3, r3, r1
	last_load = delay - (cycle_count - announced_cycles);
 8001148:	fb01 0003 	mla	r0, r1, r3, r0
	overflow_cyc = 0U;
 800114c:	4b0d      	ldr	r3, [pc, #52]	; (8001184 <z_clock_set_timeout+0x9c>)
	last_load = delay - (cycle_count - announced_cycles);
 800114e:	6020      	str	r0, [r4, #0]
	SysTick->LOAD = last_load - 1;
 8001150:	3801      	subs	r0, #1
	overflow_cyc = 0U;
 8001152:	601a      	str	r2, [r3, #0]
	SysTick->LOAD = last_load - 1;
 8001154:	4b07      	ldr	r3, [pc, #28]	; (8001174 <z_clock_set_timeout+0x8c>)
 8001156:	6058      	str	r0, [r3, #4]
	SysTick->VAL = 0; /* resets timer to last_load */
 8001158:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
 800115a:	f385 8811 	msr	BASEPRI, r5
 800115e:	f3bf 8f6f 	isb	sy
 8001162:	e7ce      	b.n	8001102 <z_clock_set_timeout+0x1a>
	ticks = MIN(MAX_TICKS, MAX(ticks - 1, 0));
 8001164:	204c      	movs	r0, #76	; 0x4c
 8001166:	e7d2      	b.n	800110e <z_clock_set_timeout+0x26>
	delay = (ticks == 0) ? MIN_DELAY : ticks * CYC_PER_TICK;
 8001168:	f243 46bc 	movw	r6, #13500	; 0x34bc
 800116c:	e7d1      	b.n	8001112 <z_clock_set_timeout+0x2a>
 800116e:	bf00      	nop
 8001170:	2002031c 	.word	0x2002031c
 8001174:	e000e010 	.word	0xe000e010
 8001178:	00034bc0 	.word	0x00034bc0
 800117c:	20020318 	.word	0x20020318
 8001180:	20020314 	.word	0x20020314
 8001184:	20020320 	.word	0x20020320

08001188 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
 8001188:	b510      	push	{r4, lr}
	__asm__ volatile(
 800118a:	f04f 0310 	mov.w	r3, #16
 800118e:	f3ef 8411 	mrs	r4, BASEPRI
 8001192:	f383 8811 	msr	BASEPRI, r3
 8001196:	f3bf 8f6f 	isb	sy
	if (!TICKLESS) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc = elapsed() + cycle_count - announced_cycles;
 800119a:	f7ff ff3b 	bl	8001014 <elapsed>
 800119e:	4b07      	ldr	r3, [pc, #28]	; (80011bc <z_clock_elapsed+0x34>)
 80011a0:	4a07      	ldr	r2, [pc, #28]	; (80011c0 <z_clock_elapsed+0x38>)
 80011a2:	681b      	ldr	r3, [r3, #0]
 80011a4:	6812      	ldr	r2, [r2, #0]
 80011a6:	1a9b      	subs	r3, r3, r2
 80011a8:	4418      	add	r0, r3
	__asm__ volatile(
 80011aa:	f384 8811 	msr	BASEPRI, r4
 80011ae:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return cyc / CYC_PER_TICK;
}
 80011b2:	4b04      	ldr	r3, [pc, #16]	; (80011c4 <z_clock_elapsed+0x3c>)
 80011b4:	fbb0 f0f3 	udiv	r0, r0, r3
 80011b8:	bd10      	pop	{r4, pc}
 80011ba:	bf00      	nop
 80011bc:	20020318 	.word	0x20020318
 80011c0:	20020314 	.word	0x20020314
 80011c4:	00034bc0 	.word	0x00034bc0

080011c8 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
 80011c8:	b510      	push	{r4, lr}
	__asm__ volatile(
 80011ca:	f04f 0310 	mov.w	r3, #16
 80011ce:	f3ef 8411 	mrs	r4, BASEPRI
 80011d2:	f383 8811 	msr	BASEPRI, r3
 80011d6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = elapsed() + cycle_count;
 80011da:	f7ff ff1b 	bl	8001014 <elapsed>
 80011de:	4b04      	ldr	r3, [pc, #16]	; (80011f0 <z_timer_cycle_get_32+0x28>)
 80011e0:	681b      	ldr	r3, [r3, #0]
 80011e2:	4418      	add	r0, r3
	__asm__ volatile(
 80011e4:	f384 8811 	msr	BASEPRI, r4
 80011e8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
 80011ec:	bd10      	pop	{r4, pc}
 80011ee:	bf00      	nop
 80011f0:	20020318 	.word	0x20020318

080011f4 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80011f4:	4b16      	ldr	r3, [pc, #88]	; (8001250 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80011f6:	b570      	push	{r4, r5, r6, lr}
 80011f8:	68dc      	ldr	r4, [r3, #12]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80011fa:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80011fe:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001202:	f1c4 0507 	rsb	r5, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001206:	1d23      	adds	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001208:	2d04      	cmp	r5, #4
 800120a:	bf28      	it	cs
 800120c:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800120e:	2b06      	cmp	r3, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001210:	fa06 f505 	lsl.w	r5, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001214:	bf8c      	ite	hi
 8001216:	3c03      	subhi	r4, #3
 8001218:	2400      	movls	r4, #0
  if ((int32_t)(IRQn) >= 0)
 800121a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800121c:	ea21 0105 	bic.w	r1, r1, r5
 8001220:	fa01 f104 	lsl.w	r1, r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001224:	fa06 f404 	lsl.w	r4, r6, r4
 8001228:	ea22 0304 	bic.w	r3, r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800122c:	ea43 0301 	orr.w	r3, r3, r1
 8001230:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001234:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 8001236:	db06      	blt.n	8001246 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001238:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800123c:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8001240:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001244:	bd70      	pop	{r4, r5, r6, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001246:	f000 000f 	and.w	r0, r0, #15
 800124a:	4a02      	ldr	r2, [pc, #8]	; (8001254 <HAL_NVIC_SetPriority+0x60>)
 800124c:	5413      	strb	r3, [r2, r0]
 800124e:	e7f9      	b.n	8001244 <HAL_NVIC_SetPriority+0x50>
 8001250:	e000ed00 	.word	0xe000ed00
 8001254:	e000ed14 	.word	0xe000ed14

08001258 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001258:	2800      	cmp	r0, #0
 800125a:	db08      	blt.n	800126e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800125c:	0942      	lsrs	r2, r0, #5
 800125e:	2301      	movs	r3, #1
 8001260:	f000 001f 	and.w	r0, r0, #31
 8001264:	fa03 f000 	lsl.w	r0, r3, r0
 8001268:	4b01      	ldr	r3, [pc, #4]	; (8001270 <HAL_NVIC_EnableIRQ+0x18>)
 800126a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800126e:	4770      	bx	lr
 8001270:	e000e100 	.word	0xe000e100

08001274 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001274:	6803      	ldr	r3, [r0, #0]
 8001276:	2118      	movs	r1, #24
 8001278:	b2da      	uxtb	r2, r3
 800127a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 800127e:	3a10      	subs	r2, #16

  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001280:	f023 0303 	bic.w	r3, r3, #3
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001284:	fbb2 f1f1 	udiv	r1, r2, r1
{
 8001288:	b510      	push	{r4, lr}

  if (stream_number > 3U)
 800128a:	2a5f      	cmp	r2, #95	; 0x5f
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800128c:	4c03      	ldr	r4, [pc, #12]	; (800129c <DMA_CalcBaseAndBitshift+0x28>)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800128e:	bf88      	it	hi
 8001290:	3304      	addhi	r3, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001292:	5c61      	ldrb	r1, [r4, r1]
 8001294:	6583      	str	r3, [r0, #88]	; 0x58
 8001296:	65c1      	str	r1, [r0, #92]	; 0x5c
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }

  return hdma->StreamBaseAddress;
}
 8001298:	4618      	mov	r0, r3
 800129a:	bd10      	pop	{r4, pc}
 800129c:	08005de0 	.word	0x08005de0

080012a0 <HAL_DMA_Init>:
{
 80012a0:	b570      	push	{r4, r5, r6, lr}
 80012a2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80012a4:	f003 f87b 	bl	800439e <HAL_GetTick>
 80012a8:	4605      	mov	r5, r0
  if(hdma == NULL)
 80012aa:	2c00      	cmp	r4, #0
 80012ac:	d071      	beq.n	8001392 <HAL_DMA_Init+0xf2>
  __HAL_UNLOCK(hdma);
 80012ae:	2300      	movs	r3, #0
  __HAL_DMA_DISABLE(hdma);
 80012b0:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hdma);
 80012b2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 80012b6:	2302      	movs	r3, #2
 80012b8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 80012bc:	6813      	ldr	r3, [r2, #0]
 80012be:	f023 0301 	bic.w	r3, r3, #1
 80012c2:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80012c4:	6821      	ldr	r1, [r4, #0]
 80012c6:	680b      	ldr	r3, [r1, #0]
 80012c8:	07da      	lsls	r2, r3, #31
 80012ca:	d43b      	bmi.n	8001344 <HAL_DMA_Init+0xa4>
  tmp = hdma->Instance->CR;
 80012cc:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80012ce:	4d32      	ldr	r5, [pc, #200]	; (8001398 <HAL_DMA_Init+0xf8>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80012d0:	69a0      	ldr	r0, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80012d2:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80012d4:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 80012d8:	4313      	orrs	r3, r2
 80012da:	68e2      	ldr	r2, [r4, #12]
 80012dc:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80012de:	6922      	ldr	r2, [r4, #16]
 80012e0:	4313      	orrs	r3, r2
 80012e2:	6962      	ldr	r2, [r4, #20]
 80012e4:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80012e6:	69e2      	ldr	r2, [r4, #28]
 80012e8:	4303      	orrs	r3, r0
 80012ea:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 80012ec:	6a22      	ldr	r2, [r4, #32]
 80012ee:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80012f0:	432b      	orrs	r3, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80012f2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80012f4:	2d04      	cmp	r5, #4
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80012f6:	bf02      	ittt	eq
 80012f8:	e9d4 260b 	ldrdeq	r2, r6, [r4, #44]	; 0x2c
 80012fc:	4332      	orreq	r2, r6
 80012fe:	4313      	orreq	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001300:	2d04      	cmp	r5, #4
  hdma->Instance->CR = tmp;
 8001302:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
 8001304:	694a      	ldr	r2, [r1, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001306:	f022 0207 	bic.w	r2, r2, #7
  tmp |= hdma->Init.FIFOMode;
 800130a:	ea42 0205 	orr.w	r2, r2, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800130e:	d10b      	bne.n	8001328 <HAL_DMA_Init+0x88>
    tmp |= hdma->Init.FIFOThreshold;
 8001310:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001312:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8001314:	431a      	orrs	r2, r3
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001316:	b13d      	cbz	r5, 8001328 <HAL_DMA_Init+0x88>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;

  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8001318:	b9f8      	cbnz	r0, 800135a <HAL_DMA_Init+0xba>
  {
    switch (tmp)
 800131a:	2b01      	cmp	r3, #1
 800131c:	d02e      	beq.n	800137c <HAL_DMA_Init+0xdc>
 800131e:	b10b      	cbz	r3, 8001324 <HAL_DMA_Init+0x84>
 8001320:	2b02      	cmp	r3, #2
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8001322:	d101      	bne.n	8001328 <HAL_DMA_Init+0x88>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8001324:	01eb      	lsls	r3, r5, #7
 8001326:	d42c      	bmi.n	8001382 <HAL_DMA_Init+0xe2>
  hdma->Instance->FCR = tmp;
 8001328:	614a      	str	r2, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800132a:	4620      	mov	r0, r4
 800132c:	f7ff ffa2 	bl	8001274 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001330:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001332:	233f      	movs	r3, #63	; 0x3f
 8001334:	4093      	lsls	r3, r2
 8001336:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001338:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 800133a:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800133c:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 800133e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8001342:	e009      	b.n	8001358 <HAL_DMA_Init+0xb8>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8001344:	f003 f82b 	bl	800439e <HAL_GetTick>
 8001348:	1b40      	subs	r0, r0, r5
 800134a:	2805      	cmp	r0, #5
 800134c:	d9ba      	bls.n	80012c4 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800134e:	2320      	movs	r3, #32
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001350:	2003      	movs	r0, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001352:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8001354:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8001358:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800135a:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 800135e:	d114      	bne.n	800138a <HAL_DMA_Init+0xea>
    switch (tmp)
 8001360:	2b03      	cmp	r3, #3
 8001362:	d8e1      	bhi.n	8001328 <HAL_DMA_Init+0x88>
 8001364:	a001      	add	r0, pc, #4	; (adr r0, 800136c <HAL_DMA_Init+0xcc>)
 8001366:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 800136a:	bf00      	nop
 800136c:	08001383 	.word	0x08001383
 8001370:	08001325 	.word	0x08001325
 8001374:	08001383 	.word	0x08001383
 8001378:	0800137d 	.word	0x0800137d
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800137c:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 8001380:	d1d2      	bne.n	8001328 <HAL_DMA_Init+0x88>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001382:	2340      	movs	r3, #64	; 0x40
        hdma->State = HAL_DMA_STATE_READY;
 8001384:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001386:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8001388:	e7e4      	b.n	8001354 <HAL_DMA_Init+0xb4>
    switch (tmp)
 800138a:	2b02      	cmp	r3, #2
 800138c:	d9f9      	bls.n	8001382 <HAL_DMA_Init+0xe2>
 800138e:	2b03      	cmp	r3, #3
 8001390:	e7c7      	b.n	8001322 <HAL_DMA_Init+0x82>
    return HAL_ERROR;
 8001392:	2001      	movs	r0, #1
 8001394:	e7e0      	b.n	8001358 <HAL_DMA_Init+0xb8>
 8001396:	bf00      	nop
 8001398:	e010803f 	.word	0xe010803f

0800139c <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */

  /* Process locked */
  __HAL_LOCK(hdma2d);
 800139c:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 80013a0:	2b01      	cmp	r3, #1
 80013a2:	f04f 0302 	mov.w	r3, #2
{
 80013a6:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma2d);
 80013a8:	d031      	beq.n	800140e <HAL_DMA2D_ConfigLayer+0x72>

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
#if defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
 80013aa:	2418      	movs	r4, #24
  __HAL_LOCK(hdma2d);
 80013ac:	2201      	movs	r2, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 80013ae:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
 80013b2:	fb04 0401 	mla	r4, r4, r1, r0
 80013b6:	4f20      	ldr	r7, [pc, #128]	; (8001438 <HAL_DMA2D_ConfigLayer+0x9c>)
  __HAL_LOCK(hdma2d);
 80013b8:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
 80013bc:	6b22      	ldr	r2, [r4, #48]	; 0x30
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
 80013be:	e9d4 5609 	ldrd	r5, r6, [r4, #36]	; 0x24
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
 80013c2:	0513      	lsls	r3, r2, #20
 80013c4:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80013c6:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
 80013c8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 80013cc:	432b      	orrs	r3, r5
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
  regMask  = DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA;
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 80013ce:	3d09      	subs	r5, #9
 80013d0:	2d01      	cmp	r5, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
 80013d2:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 80013d6:	bf96      	itet	ls
 80013d8:	f004 427f 	andls.w	r2, r4, #4278190080	; 0xff000000
  }
  else
  {
    regValue |=  (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 80013dc:	ea43 6304 	orrhi.w	r3, r3, r4, lsl #24
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 80013e0:	4313      	orrls	r3, r2
  }

  /* Configure the background DMA2D layer */
  if(LayerIdx == DMA2D_BACKGROUND_LAYER)
 80013e2:	6802      	ldr	r2, [r0, #0]
 80013e4:	b9a9      	cbnz	r1, 8001412 <HAL_DMA2D_ConfigLayer+0x76>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 80013e6:	6a56      	ldr	r6, [r2, #36]	; 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 80013e8:	2d01      	cmp	r5, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 80013ea:	ea06 0607 	and.w	r6, r6, r7
 80013ee:	ea43 0306 	orr.w	r3, r3, r6
 80013f2:	6253      	str	r3, [r2, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 80013f4:	6a03      	ldr	r3, [r0, #32]
 80013f6:	6193      	str	r3, [r2, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 80013f8:	d803      	bhi.n	8001402 <HAL_DMA2D_ConfigLayer+0x66>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 80013fa:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80013fc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8001400:	6293      	str	r3, [r2, #40]	; 0x28
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001402:	2301      	movs	r3, #1
 8001404:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
 8001408:	2300      	movs	r3, #0
 800140a:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  __HAL_LOCK(hdma2d);
 800140e:	4618      	mov	r0, r3

  return HAL_OK;
}
 8001410:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001412:	69d6      	ldr	r6, [r2, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001414:	2d01      	cmp	r5, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001416:	ea06 0607 	and.w	r6, r6, r7
 800141a:	ea43 0306 	orr.w	r3, r3, r6
 800141e:	61d3      	str	r3, [r2, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8001420:	f04f 0318 	mov.w	r3, #24
 8001424:	fb03 0101 	mla	r1, r3, r1, r0
 8001428:	6a0b      	ldr	r3, [r1, #32]
 800142a:	6113      	str	r3, [r2, #16]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 800142c:	d8e9      	bhi.n	8001402 <HAL_DMA2D_ConfigLayer+0x66>
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
 800142e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8001432:	6214      	str	r4, [r2, #32]
 8001434:	e7e5      	b.n	8001402 <HAL_DMA2D_ConfigLayer+0x66>
 8001436:	bf00      	nop
 8001438:	00ccfff0 	.word	0x00ccfff0

0800143c <HAL_DSI_Init>:
  * @param  PLLInit  pointer to a DSI_PLLInitTypeDef structure that contains
  *                  the PLL Clock structure definition for the DSI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DSI_Init(DSI_HandleTypeDef *hdsi, DSI_PLLInitTypeDef *PLLInit)
{
 800143c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800143e:	460d      	mov	r5, r1
  uint32_t tickstart;
  uint32_t unitIntervalx4;
  uint32_t tempIDF;

  /* Check the DSI handle allocation */
  if (hdsi == NULL)
 8001440:	4604      	mov	r4, r0
 8001442:	2800      	cmp	r0, #0
 8001444:	f000 80a6 	beq.w	8001594 <HAL_DSI_Init+0x158>
    }
    /* Initialize the low level hardware */
    hdsi->MspInitCallback(hdsi);
  }
#else
  if (hdsi->State == HAL_DSI_STATE_RESET)
 8001448:	7c43      	ldrb	r3, [r0, #17]
 800144a:	b90b      	cbnz	r3, 8001450 <HAL_DSI_Init+0x14>
  {
    /* Initialize the low level hardware */
    HAL_DSI_MspInit(hdsi);
 800144c:	f003 f995 	bl	800477a <HAL_DSI_MspInit>
  }
#endif /* USE_HAL_DSI_REGISTER_CALLBACKS */

  /* Change DSI peripheral state */
  hdsi->State = HAL_DSI_STATE_BUSY;
 8001450:	2303      	movs	r3, #3
 8001452:	7463      	strb	r3, [r4, #17]

  /**************** Turn on the regulator and enable the DSI PLL ****************/

  /* Enable the regulator */
  __HAL_DSI_REG_ENABLE(hdsi);
 8001454:	2300      	movs	r3, #0
 8001456:	9300      	str	r3, [sp, #0]
 8001458:	6823      	ldr	r3, [r4, #0]
 800145a:	f8d3 2430 	ldr.w	r2, [r3, #1072]	; 0x430
 800145e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001462:	f8c3 2430 	str.w	r2, [r3, #1072]	; 0x430
 8001466:	f8d3 3430 	ldr.w	r3, [r3, #1072]	; 0x430
 800146a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800146e:	9300      	str	r3, [sp, #0]
 8001470:	9b00      	ldr	r3, [sp, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8001472:	f002 ff94 	bl	800439e <HAL_GetTick>
 8001476:	4606      	mov	r6, r0

  /* Wait until the regulator is ready */
  while (__HAL_DSI_GET_FLAG(hdsi, DSI_FLAG_RRS) == 0U)
 8001478:	6822      	ldr	r2, [r4, #0]
 800147a:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
 800147e:	04d9      	lsls	r1, r3, #19
 8001480:	d577      	bpl.n	8001572 <HAL_DSI_Init+0x136>
      return HAL_TIMEOUT;
    }
  }

  /* Set the PLL division factors */
  hdsi->Instance->WRPCR &= ~(DSI_WRPCR_PLL_NDIV | DSI_WRPCR_PLL_IDF | DSI_WRPCR_PLL_ODF);
 8001482:	f8d2 3430 	ldr.w	r3, [r2, #1072]	; 0x430
 8001486:	f423 335e 	bic.w	r3, r3, #227328	; 0x37800
 800148a:	f423 73fe 	bic.w	r3, r3, #508	; 0x1fc
 800148e:	f8c2 3430 	str.w	r3, [r2, #1072]	; 0x430
  hdsi->Instance->WRPCR |= (((PLLInit->PLLNDIV) << 2U) | ((PLLInit->PLLIDF) << 11U) | ((PLLInit->PLLODF) << 16U));
 8001492:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
 8001496:	e9d5 0300 	ldrd	r0, r3, [r5]
 800149a:	02db      	lsls	r3, r3, #11
 800149c:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
 80014a0:	68a8      	ldr	r0, [r5, #8]
 80014a2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80014a6:	430b      	orrs	r3, r1
 80014a8:	f8c2 3430 	str.w	r3, [r2, #1072]	; 0x430

  /* Enable the DSI PLL */
  __HAL_DSI_PLL_ENABLE(hdsi);
 80014ac:	2300      	movs	r3, #0
 80014ae:	9301      	str	r3, [sp, #4]
 80014b0:	f8d2 3430 	ldr.w	r3, [r2, #1072]	; 0x430
 80014b4:	f043 0301 	orr.w	r3, r3, #1
 80014b8:	f8c2 3430 	str.w	r3, [r2, #1072]	; 0x430
 80014bc:	f8d2 3430 	ldr.w	r3, [r2, #1072]	; 0x430
 80014c0:	f003 0301 	and.w	r3, r3, #1
 80014c4:	9301      	str	r3, [sp, #4]
 80014c6:	9b01      	ldr	r3, [sp, #4]

  /* Get tick */
  tickstart = HAL_GetTick();
 80014c8:	f002 ff69 	bl	800439e <HAL_GetTick>
 80014cc:	4606      	mov	r6, r0

  /* Wait for the lock of the PLL */
  while (__HAL_DSI_GET_FLAG(hdsi, DSI_FLAG_PLLLS) == 0U)
 80014ce:	6823      	ldr	r3, [r4, #0]
 80014d0:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
 80014d4:	05d2      	lsls	r2, r2, #23
 80014d6:	d556      	bpl.n	8001586 <HAL_DSI_Init+0x14a>
  }

  /*************************** Set the PHY parameters ***************************/

  /* D-PHY clock and digital enable*/
  hdsi->Instance->PCTLR |= (DSI_PCTLR_CKE | DSI_PCTLR_DEN);
 80014d8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0

  /* Clock lane configuration */
  hdsi->Instance->CLCR &= ~(DSI_CLCR_DPCC | DSI_CLCR_ACR);
  hdsi->Instance->CLCR |= (DSI_CLCR_DPCC | hdsi->Init.AutomaticClockLaneControl);
 80014dc:	6861      	ldr	r1, [r4, #4]
  hdsi->Instance->PCTLR |= (DSI_PCTLR_CKE | DSI_PCTLR_DEN);
 80014de:	f042 0206 	orr.w	r2, r2, #6

  /* Calculate the bit period in high-speed mode in unit of 0.25 ns (UIX4) */
  /* The equation is : UIX4 = IntegerPart( (1000/F_PHY_Mhz) * 4 )          */
  /* Where : F_PHY_Mhz = (NDIV * HSE_Mhz) / (IDF * ODF)                    */
  tempIDF = (PLLInit->PLLIDF > 0U) ? PLLInit->PLLIDF : 1U;
  unitIntervalx4 = (4000000U * tempIDF * ((1UL << (0x3U & PLLInit->PLLODF)))) / ((HSE_VALUE / 1000U) * PLLInit->PLLNDIV);
 80014e2:	6828      	ldr	r0, [r5, #0]
  hdsi->Instance->PCTLR |= (DSI_PCTLR_CKE | DSI_PCTLR_DEN);
 80014e4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  hdsi->Instance->CLCR &= ~(DSI_CLCR_DPCC | DSI_CLCR_ACR);
 80014e8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80014ec:	f022 0203 	bic.w	r2, r2, #3
 80014f0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  hdsi->Instance->CLCR |= (DSI_CLCR_DPCC | hdsi->Init.AutomaticClockLaneControl);
 80014f4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80014f8:	430a      	orrs	r2, r1
  hdsi->Instance->PCONFR |= hdsi->Init.NumberOfLanes;
 80014fa:	68e1      	ldr	r1, [r4, #12]
  hdsi->Instance->CLCR |= (DSI_CLCR_DPCC | hdsi->Init.AutomaticClockLaneControl);
 80014fc:	f042 0201 	orr.w	r2, r2, #1
 8001500:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  hdsi->Instance->PCONFR &= ~DSI_PCONFR_NL;
 8001504:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8001508:	f022 0203 	bic.w	r2, r2, #3
 800150c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  hdsi->Instance->PCONFR |= hdsi->Init.NumberOfLanes;
 8001510:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8001514:	430a      	orrs	r2, r1
  hdsi->Instance->CCR |= hdsi->Init.TXEscapeCkdiv;
 8001516:	68a1      	ldr	r1, [r4, #8]
  hdsi->Instance->PCONFR |= hdsi->Init.NumberOfLanes;
 8001518:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  hdsi->Instance->CCR &= ~DSI_CCR_TXECKDIV;
 800151c:	689a      	ldr	r2, [r3, #8]
 800151e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001522:	609a      	str	r2, [r3, #8]
  hdsi->Instance->CCR |= hdsi->Init.TXEscapeCkdiv;
 8001524:	689a      	ldr	r2, [r3, #8]
 8001526:	430a      	orrs	r2, r1
  tempIDF = (PLLInit->PLLIDF > 0U) ? PLLInit->PLLIDF : 1U;
 8001528:	6869      	ldr	r1, [r5, #4]
 800152a:	2900      	cmp	r1, #0
  hdsi->Instance->CCR |= hdsi->Init.TXEscapeCkdiv;
 800152c:	609a      	str	r2, [r3, #8]
  unitIntervalx4 = (4000000U * tempIDF * ((1UL << (0x3U & PLLInit->PLLODF)))) / ((HSE_VALUE / 1000U) * PLLInit->PLLNDIV);
 800152e:	4a1a      	ldr	r2, [pc, #104]	; (8001598 <HAL_DSI_Init+0x15c>)
  tempIDF = (PLLInit->PLLIDF > 0U) ? PLLInit->PLLIDF : 1U;
 8001530:	bf08      	it	eq
 8001532:	2101      	moveq	r1, #1
  unitIntervalx4 = (4000000U * tempIDF * ((1UL << (0x3U & PLLInit->PLLODF)))) / ((HSE_VALUE / 1000U) * PLLInit->PLLNDIV);
 8001534:	434a      	muls	r2, r1
 8001536:	68a9      	ldr	r1, [r5, #8]
 8001538:	f001 0103 	and.w	r1, r1, #3
 800153c:	408a      	lsls	r2, r1
 800153e:	f246 11a8 	movw	r1, #25000	; 0x61a8
 8001542:	4341      	muls	r1, r0
  hdsi->Instance->WPCR[0U] |= unitIntervalx4;

  /****************************** Error management *****************************/

  /* Disable all error interrupts and reset the Error Mask */
  hdsi->Instance->IER[0U] = 0U;
 8001544:	2000      	movs	r0, #0
  unitIntervalx4 = (4000000U * tempIDF * ((1UL << (0x3U & PLLInit->PLLODF)))) / ((HSE_VALUE / 1000U) * PLLInit->PLLNDIV);
 8001546:	fbb2 f2f1 	udiv	r2, r2, r1
  hdsi->Instance->WPCR[0U] &= ~DSI_WPCR0_UIX4;
 800154a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
 800154e:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 8001552:	f8c3 1418 	str.w	r1, [r3, #1048]	; 0x418
  hdsi->Instance->WPCR[0U] |= unitIntervalx4;
 8001556:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
 800155a:	430a      	orrs	r2, r1
 800155c:	f8c3 2418 	str.w	r2, [r3, #1048]	; 0x418
  hdsi->Instance->IER[0U] = 0U;
 8001560:	f8c3 00c4 	str.w	r0, [r3, #196]	; 0xc4
  hdsi->Instance->IER[1U] = 0U;
 8001564:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8

  /* Initialise the error code */
  hdsi->ErrorCode = HAL_DSI_ERROR_NONE;

  /* Initialize the DSI state*/
  hdsi->State = HAL_DSI_STATE_READY;
 8001568:	2301      	movs	r3, #1
  hdsi->ErrorCode = HAL_DSI_ERROR_NONE;
 800156a:	6160      	str	r0, [r4, #20]
  hdsi->ErrorMsk = 0U;
 800156c:	61a0      	str	r0, [r4, #24]
  hdsi->State = HAL_DSI_STATE_READY;
 800156e:	7463      	strb	r3, [r4, #17]

  return HAL_OK;
 8001570:	e007      	b.n	8001582 <HAL_DSI_Init+0x146>
    if ((HAL_GetTick() - tickstart) > DSI_TIMEOUT_VALUE)
 8001572:	f002 ff14 	bl	800439e <HAL_GetTick>
 8001576:	1b80      	subs	r0, r0, r6
 8001578:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800157c:	f67f af7c 	bls.w	8001478 <HAL_DSI_Init+0x3c>
      return HAL_TIMEOUT;
 8001580:	2003      	movs	r0, #3
}
 8001582:	b002      	add	sp, #8
 8001584:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_GetTick() - tickstart) > DSI_TIMEOUT_VALUE)
 8001586:	f002 ff0a 	bl	800439e <HAL_GetTick>
 800158a:	1b80      	subs	r0, r0, r6
 800158c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001590:	d99d      	bls.n	80014ce <HAL_DSI_Init+0x92>
 8001592:	e7f5      	b.n	8001580 <HAL_DSI_Init+0x144>
    return HAL_ERROR;
 8001594:	2001      	movs	r0, #1
 8001596:	e7f4      	b.n	8001582 <HAL_DSI_Init+0x146>
 8001598:	003d0900 	.word	0x003d0900

0800159c <HAL_DSI_ConfigVideoMode>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DSI_ConfigVideoMode(DSI_HandleTypeDef *hdsi, DSI_VidCfgTypeDef *VidCfg)
{
  /* Process locked */
  __HAL_LOCK(hdsi);
 800159c:	7c03      	ldrb	r3, [r0, #16]
 800159e:	2b01      	cmp	r3, #1
{
 80015a0:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdsi);
 80015a2:	f000 80f9 	beq.w	8001798 <HAL_DSI_ConfigVideoMode+0x1fc>
 80015a6:	2301      	movs	r3, #1
  assert_param(IS_DSI_FBTAA(VidCfg->FrameBTAAcknowledgeEnable));
  assert_param(IS_DSI_DE_POLARITY(VidCfg->DEPolarity));
  assert_param(IS_DSI_VSYNC_POLARITY(VidCfg->VSPolarity));
  assert_param(IS_DSI_HSYNC_POLARITY(VidCfg->HSPolarity));
  /* Check the LooselyPacked variant only in 18-bit mode */
  if (VidCfg->ColorCoding == DSI_RGB666)
 80015a8:	684c      	ldr	r4, [r1, #4]
  hdsi->Instance->MCR &= ~DSI_MCR_CMDM;
  hdsi->Instance->WCFGR &= ~DSI_WCFGR_DSIM;

  /* Configure the video mode transmission type */
  hdsi->Instance->VMCR &= ~DSI_VMCR_VMT;
  hdsi->Instance->VMCR |= VidCfg->Mode;
 80015aa:	68cd      	ldr	r5, [r1, #12]
  __HAL_LOCK(hdsi);
 80015ac:	7403      	strb	r3, [r0, #16]
  /* Select the color coding for the wrapper */
  hdsi->Instance->WCFGR &= ~DSI_WCFGR_COLMUX;
  hdsi->Instance->WCFGR |= ((VidCfg->ColorCoding) << 1U);

  /* Enable/disable the loosely packed variant to 18-bit configuration */
  if (VidCfg->ColorCoding == DSI_RGB666)
 80015ae:	2c03      	cmp	r4, #3
  hdsi->Instance->MCR &= ~DSI_MCR_CMDM;
 80015b0:	6803      	ldr	r3, [r0, #0]
  hdsi->Instance->VCCR &= ~DSI_VCCR_NUMC;
 80015b2:	4e7a      	ldr	r6, [pc, #488]	; (800179c <HAL_DSI_ConfigVideoMode+0x200>)
  hdsi->Instance->MCR &= ~DSI_MCR_CMDM;
 80015b4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80015b6:	f022 0201 	bic.w	r2, r2, #1
 80015ba:	635a      	str	r2, [r3, #52]	; 0x34
  hdsi->Instance->WCFGR &= ~DSI_WCFGR_DSIM;
 80015bc:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 80015c0:	f022 0201 	bic.w	r2, r2, #1
 80015c4:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  hdsi->Instance->VMCR &= ~DSI_VMCR_VMT;
 80015c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80015ca:	f022 0203 	bic.w	r2, r2, #3
 80015ce:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->Mode;
 80015d0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80015d2:	ea42 0205 	orr.w	r2, r2, r5
  hdsi->Instance->VPCR |= VidCfg->PacketSize;
 80015d6:	690d      	ldr	r5, [r1, #16]
  hdsi->Instance->VMCR |= VidCfg->Mode;
 80015d8:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VPCR &= ~DSI_VPCR_VPSIZE;
 80015da:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80015dc:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 80015e0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80015e4:	63da      	str	r2, [r3, #60]	; 0x3c
  hdsi->Instance->VPCR |= VidCfg->PacketSize;
 80015e6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80015e8:	ea42 0205 	orr.w	r2, r2, r5
 80015ec:	63da      	str	r2, [r3, #60]	; 0x3c
  hdsi->Instance->VCCR &= ~DSI_VCCR_NUMC;
 80015ee:	6c1d      	ldr	r5, [r3, #64]	; 0x40
  hdsi->Instance->VCCR |= VidCfg->NumberOfChunks;
 80015f0:	694a      	ldr	r2, [r1, #20]
  hdsi->Instance->VCCR &= ~DSI_VCCR_NUMC;
 80015f2:	ea05 0506 	and.w	r5, r5, r6
 80015f6:	641d      	str	r5, [r3, #64]	; 0x40
  hdsi->Instance->VCCR |= VidCfg->NumberOfChunks;
 80015f8:	6c1d      	ldr	r5, [r3, #64]	; 0x40
 80015fa:	ea45 0502 	orr.w	r5, r5, r2
 80015fe:	641d      	str	r5, [r3, #64]	; 0x40
  hdsi->Instance->VNPCR &= ~DSI_VNPCR_NPSIZE;
 8001600:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  hdsi->Instance->VNPCR |= VidCfg->NullPacketSize;
 8001602:	698d      	ldr	r5, [r1, #24]
  hdsi->Instance->VNPCR &= ~DSI_VNPCR_NPSIZE;
 8001604:	ea02 0206 	and.w	r2, r2, r6
 8001608:	645a      	str	r2, [r3, #68]	; 0x44
  hdsi->Instance->VNPCR |= VidCfg->NullPacketSize;
 800160a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800160c:	ea42 0205 	orr.w	r2, r2, r5
  hdsi->Instance->LVCIDR |= VidCfg->VirtualChannelID;
 8001610:	680d      	ldr	r5, [r1, #0]
  hdsi->Instance->VNPCR |= VidCfg->NullPacketSize;
 8001612:	645a      	str	r2, [r3, #68]	; 0x44
  hdsi->Instance->LVCIDR &= ~DSI_LVCIDR_VCID;
 8001614:	68da      	ldr	r2, [r3, #12]
 8001616:	f022 0203 	bic.w	r2, r2, #3
 800161a:	60da      	str	r2, [r3, #12]
  hdsi->Instance->LVCIDR |= VidCfg->VirtualChannelID;
 800161c:	68da      	ldr	r2, [r3, #12]
 800161e:	ea42 0205 	orr.w	r2, r2, r5
 8001622:	60da      	str	r2, [r3, #12]
  hdsi->Instance->LPCR &= ~(DSI_LPCR_DEP | DSI_LPCR_VSP | DSI_LPCR_HSP);
 8001624:	695a      	ldr	r2, [r3, #20]
 8001626:	f022 0207 	bic.w	r2, r2, #7
 800162a:	615a      	str	r2, [r3, #20]
  hdsi->Instance->LPCR |= (VidCfg->DEPolarity | VidCfg->VSPolarity | VidCfg->HSPolarity);
 800162c:	695d      	ldr	r5, [r3, #20]
 800162e:	e9d1 6208 	ldrd	r6, r2, [r1, #32]
 8001632:	ea42 0206 	orr.w	r2, r2, r6
 8001636:	69ce      	ldr	r6, [r1, #28]
 8001638:	ea42 0206 	orr.w	r2, r2, r6
 800163c:	ea42 0205 	orr.w	r2, r2, r5
 8001640:	615a      	str	r2, [r3, #20]
  hdsi->Instance->LCOLCR &= ~DSI_LCOLCR_COLC;
 8001642:	691a      	ldr	r2, [r3, #16]
 8001644:	f022 020f 	bic.w	r2, r2, #15
 8001648:	611a      	str	r2, [r3, #16]
  hdsi->Instance->LCOLCR |= VidCfg->ColorCoding;
 800164a:	691a      	ldr	r2, [r3, #16]
 800164c:	ea42 0204 	orr.w	r2, r2, r4
 8001650:	611a      	str	r2, [r3, #16]
  hdsi->Instance->WCFGR &= ~DSI_WCFGR_COLMUX;
 8001652:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 8001656:	f022 020e 	bic.w	r2, r2, #14
 800165a:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  hdsi->Instance->WCFGR |= ((VidCfg->ColorCoding) << 1U);
 800165e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 8001662:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 8001666:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  if (VidCfg->ColorCoding == DSI_RGB666)
 800166a:	d107      	bne.n	800167c <HAL_DSI_ConfigVideoMode+0xe0>
  {
    hdsi->Instance->LCOLCR &= ~DSI_LCOLCR_LPE;
 800166c:	691a      	ldr	r2, [r3, #16]
    hdsi->Instance->LCOLCR |= VidCfg->LooselyPacked;
 800166e:	688c      	ldr	r4, [r1, #8]
    hdsi->Instance->LCOLCR &= ~DSI_LCOLCR_LPE;
 8001670:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001674:	611a      	str	r2, [r3, #16]
    hdsi->Instance->LCOLCR |= VidCfg->LooselyPacked;
 8001676:	691a      	ldr	r2, [r3, #16]
 8001678:	4322      	orrs	r2, r4
 800167a:	611a      	str	r2, [r3, #16]
  }

  /* Set the Horizontal Synchronization Active (HSA) in lane byte clock cycles */
  hdsi->Instance->VHSACR &= ~DSI_VHSACR_HSA;
 800167c:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 800167e:	4d48      	ldr	r5, [pc, #288]	; (80017a0 <HAL_DSI_ConfigVideoMode+0x204>)
  hdsi->Instance->VHSACR |= VidCfg->HorizontalSyncActive;
 8001680:	6a8a      	ldr	r2, [r1, #40]	; 0x28
  hdsi->Instance->VHSACR &= ~DSI_VHSACR_HSA;
 8001682:	402c      	ands	r4, r5
 8001684:	649c      	str	r4, [r3, #72]	; 0x48
  hdsi->Instance->VHSACR |= VidCfg->HorizontalSyncActive;
 8001686:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8001688:	4314      	orrs	r4, r2
 800168a:	649c      	str	r4, [r3, #72]	; 0x48

  /* Set the Horizontal Back Porch (HBP) in lane byte clock cycles */
  hdsi->Instance->VHBPCR &= ~DSI_VHBPCR_HBP;
 800168c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  hdsi->Instance->VHBPCR |= VidCfg->HorizontalBackPorch;
 800168e:	6acc      	ldr	r4, [r1, #44]	; 0x2c
  hdsi->Instance->VHBPCR &= ~DSI_VHBPCR_HBP;
 8001690:	402a      	ands	r2, r5
  hdsi->Instance->VLCR &= ~DSI_VLCR_HLINE;
  hdsi->Instance->VLCR |= VidCfg->HorizontalLine;

  /* Set the Vertical Synchronization Active (VSA) */
  hdsi->Instance->VVSACR &= ~DSI_VVSACR_VSA;
  hdsi->Instance->VVSACR |= VidCfg->VerticalSyncActive;
 8001692:	6b4d      	ldr	r5, [r1, #52]	; 0x34
  hdsi->Instance->VHBPCR &= ~DSI_VHBPCR_HBP;
 8001694:	64da      	str	r2, [r3, #76]	; 0x4c
  hdsi->Instance->VHBPCR |= VidCfg->HorizontalBackPorch;
 8001696:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001698:	4322      	orrs	r2, r4
  hdsi->Instance->VLCR |= VidCfg->HorizontalLine;
 800169a:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  hdsi->Instance->VHBPCR |= VidCfg->HorizontalBackPorch;
 800169c:	64da      	str	r2, [r3, #76]	; 0x4c
  hdsi->Instance->VLCR &= ~DSI_VLCR_HLINE;
 800169e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80016a0:	f422 42ff 	bic.w	r2, r2, #32640	; 0x7f80
 80016a4:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 80016a8:	651a      	str	r2, [r3, #80]	; 0x50
  hdsi->Instance->VLCR |= VidCfg->HorizontalLine;
 80016aa:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80016ac:	4322      	orrs	r2, r4
  hdsi->Instance->VVSACR &= ~DSI_VVSACR_VSA;
 80016ae:	4c3d      	ldr	r4, [pc, #244]	; (80017a4 <HAL_DSI_ConfigVideoMode+0x208>)
  hdsi->Instance->VLCR |= VidCfg->HorizontalLine;
 80016b0:	651a      	str	r2, [r3, #80]	; 0x50
  hdsi->Instance->VVSACR &= ~DSI_VVSACR_VSA;
 80016b2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80016b4:	4022      	ands	r2, r4
 80016b6:	655a      	str	r2, [r3, #84]	; 0x54
  hdsi->Instance->VVSACR |= VidCfg->VerticalSyncActive;
 80016b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80016ba:	432a      	orrs	r2, r5

  /* Set the Vertical Back Porch (VBP)*/
  hdsi->Instance->VVBPCR &= ~DSI_VVBPCR_VBP;
  hdsi->Instance->VVBPCR |= VidCfg->VerticalBackPorch;
 80016bc:	6b8d      	ldr	r5, [r1, #56]	; 0x38
  hdsi->Instance->VVSACR |= VidCfg->VerticalSyncActive;
 80016be:	655a      	str	r2, [r3, #84]	; 0x54
  hdsi->Instance->VVBPCR &= ~DSI_VVBPCR_VBP;
 80016c0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80016c2:	4022      	ands	r2, r4
 80016c4:	659a      	str	r2, [r3, #88]	; 0x58
  hdsi->Instance->VVBPCR |= VidCfg->VerticalBackPorch;
 80016c6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80016c8:	432a      	orrs	r2, r5
 80016ca:	659a      	str	r2, [r3, #88]	; 0x58

  /* Set the Vertical Front Porch (VFP)*/
  hdsi->Instance->VVFPCR &= ~DSI_VVFPCR_VFP;
 80016cc:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80016ce:	4022      	ands	r2, r4
  hdsi->Instance->VVFPCR |= VidCfg->VerticalFrontPorch;
 80016d0:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
  hdsi->Instance->VVFPCR &= ~DSI_VVFPCR_VFP;
 80016d2:	65da      	str	r2, [r3, #92]	; 0x5c
  hdsi->Instance->VVFPCR |= VidCfg->VerticalFrontPorch;
 80016d4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80016d6:	4322      	orrs	r2, r4
 80016d8:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Set the Vertical Active period*/
  hdsi->Instance->VVACR &= ~DSI_VVACR_VA;
 80016da:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80016dc:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 80016e0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80016e4:	661a      	str	r2, [r3, #96]	; 0x60
  hdsi->Instance->VVACR |= VidCfg->VerticalActive;
 80016e6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80016e8:	6c0c      	ldr	r4, [r1, #64]	; 0x40
 80016ea:	4322      	orrs	r2, r4

  /* Configure the command transmission mode */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPCE;
  hdsi->Instance->VMCR |= VidCfg->LPCommandEnable;
 80016ec:	6c4c      	ldr	r4, [r1, #68]	; 0x44
  hdsi->Instance->VVACR |= VidCfg->VerticalActive;
 80016ee:	661a      	str	r2, [r3, #96]	; 0x60
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPCE;
 80016f0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80016f2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80016f6:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPCommandEnable;
 80016f8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80016fa:	4322      	orrs	r2, r4

  /* Low power largest packet size */
  hdsi->Instance->LPMCR &= ~DSI_LPMCR_LPSIZE;
  hdsi->Instance->LPMCR |= ((VidCfg->LPLargestPacketSize) << 16U);
 80016fc:	6c8c      	ldr	r4, [r1, #72]	; 0x48
  hdsi->Instance->VMCR |= VidCfg->LPCommandEnable;
 80016fe:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->LPMCR &= ~DSI_LPMCR_LPSIZE;
 8001700:	699a      	ldr	r2, [r3, #24]
 8001702:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8001706:	619a      	str	r2, [r3, #24]
  hdsi->Instance->LPMCR |= ((VidCfg->LPLargestPacketSize) << 16U);
 8001708:	699a      	ldr	r2, [r3, #24]
 800170a:	ea42 4204 	orr.w	r2, r2, r4, lsl #16

  /* Low power VACT largest packet size */
  hdsi->Instance->LPMCR &= ~DSI_LPMCR_VLPSIZE;
  hdsi->Instance->LPMCR |= VidCfg->LPVACTLargestPacketSize;
 800170e:	6ccc      	ldr	r4, [r1, #76]	; 0x4c
  hdsi->Instance->LPMCR |= ((VidCfg->LPLargestPacketSize) << 16U);
 8001710:	619a      	str	r2, [r3, #24]
  hdsi->Instance->LPMCR &= ~DSI_LPMCR_VLPSIZE;
 8001712:	699a      	ldr	r2, [r3, #24]
 8001714:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001718:	619a      	str	r2, [r3, #24]
  hdsi->Instance->LPMCR |= VidCfg->LPVACTLargestPacketSize;
 800171a:	699a      	ldr	r2, [r3, #24]
 800171c:	4322      	orrs	r2, r4

  /* Enable LP transition in HFP period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPHFPE;
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalFrontPorchEnable;
 800171e:	6d0c      	ldr	r4, [r1, #80]	; 0x50
  hdsi->Instance->LPMCR |= VidCfg->LPVACTLargestPacketSize;
 8001720:	619a      	str	r2, [r3, #24]
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPHFPE;
 8001722:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001724:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001728:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalFrontPorchEnable;
 800172a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800172c:	4322      	orrs	r2, r4

  /* Enable LP transition in HBP period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPHBPE;
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalBackPorchEnable;
 800172e:	6d4c      	ldr	r4, [r1, #84]	; 0x54
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalFrontPorchEnable;
 8001730:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPHBPE;
 8001732:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001734:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001738:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalBackPorchEnable;
 800173a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800173c:	4322      	orrs	r2, r4

  /* Enable LP transition in VACT period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVAE;
  hdsi->Instance->VMCR |= VidCfg->LPVerticalActiveEnable;
 800173e:	6d8c      	ldr	r4, [r1, #88]	; 0x58
  hdsi->Instance->VMCR |= VidCfg->LPHorizontalBackPorchEnable;
 8001740:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVAE;
 8001742:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001744:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001748:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPVerticalActiveEnable;
 800174a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800174c:	4322      	orrs	r2, r4
 800174e:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable LP transition in VFP period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVFPE;
 8001750:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPVerticalFrontPorchEnable;
 8001752:	6dcc      	ldr	r4, [r1, #92]	; 0x5c
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVFPE;
 8001754:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001758:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPVerticalFrontPorchEnable;
 800175a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800175c:	4322      	orrs	r2, r4

  /* Enable LP transition in VBP period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVBPE;
  hdsi->Instance->VMCR |= VidCfg->LPVerticalBackPorchEnable;
 800175e:	6e0c      	ldr	r4, [r1, #96]	; 0x60
  hdsi->Instance->VMCR |= VidCfg->LPVerticalFrontPorchEnable;
 8001760:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVBPE;
 8001762:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001764:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001768:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPVerticalBackPorchEnable;
 800176a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800176c:	4322      	orrs	r2, r4

  /* Enable LP transition in vertical sync period */
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVSAE;
  hdsi->Instance->VMCR |= VidCfg->LPVerticalSyncActiveEnable;
 800176e:	6e4c      	ldr	r4, [r1, #100]	; 0x64

  /* Enable the request for an acknowledge response at the end of a frame */
  hdsi->Instance->VMCR &= ~DSI_VMCR_FBTAAE;
  hdsi->Instance->VMCR |= VidCfg->FrameBTAAcknowledgeEnable;
 8001770:	6e89      	ldr	r1, [r1, #104]	; 0x68
  hdsi->Instance->VMCR |= VidCfg->LPVerticalBackPorchEnable;
 8001772:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR &= ~DSI_VMCR_LPVSAE;
 8001774:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001776:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800177a:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->LPVerticalSyncActiveEnable;
 800177c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800177e:	4322      	orrs	r2, r4
 8001780:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR &= ~DSI_VMCR_FBTAAE;
 8001782:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001784:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001788:	639a      	str	r2, [r3, #56]	; 0x38
  hdsi->Instance->VMCR |= VidCfg->FrameBTAAcknowledgeEnable;
 800178a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800178c:	430a      	orrs	r2, r1
 800178e:	639a      	str	r2, [r3, #56]	; 0x38

  /* Process unlocked */
  __HAL_UNLOCK(hdsi);
 8001790:	2300      	movs	r3, #0
 8001792:	7403      	strb	r3, [r0, #16]

  return HAL_OK;
 8001794:	4618      	mov	r0, r3
}
 8001796:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdsi);
 8001798:	2002      	movs	r0, #2
 800179a:	e7fc      	b.n	8001796 <HAL_DSI_ConfigVideoMode+0x1fa>
 800179c:	ffffe000 	.word	0xffffe000
 80017a0:	fffff000 	.word	0xfffff000
 80017a4:	fffffc00 	.word	0xfffffc00

080017a8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80017a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80017ac:	680b      	ldr	r3, [r1, #0]
{
 80017ae:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80017b0:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8001974 <HAL_GPIO_Init+0x1cc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80017b4:	9301      	str	r3, [sp, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
 80017b6:	2300      	movs	r3, #0
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80017b8:	4a6c      	ldr	r2, [pc, #432]	; (800196c <HAL_GPIO_Init+0x1c4>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80017ba:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 8001978 <HAL_GPIO_Init+0x1d0>
    ioposition = ((uint32_t)0x01) << position;
 80017be:	f04f 0c01 	mov.w	ip, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80017c2:	9c01      	ldr	r4, [sp, #4]
    ioposition = ((uint32_t)0x01) << position;
 80017c4:	fa0c fc03 	lsl.w	ip, ip, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80017c8:	ea04 060c 	and.w	r6, r4, ip
    if(iocurrent == ioposition)
 80017cc:	45b4      	cmp	ip, r6
 80017ce:	f040 80b3 	bne.w	8001938 <HAL_GPIO_Init+0x190>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80017d2:	684c      	ldr	r4, [r1, #4]
 80017d4:	f024 0710 	bic.w	r7, r4, #16
 80017d8:	2f02      	cmp	r7, #2
 80017da:	d116      	bne.n	800180a <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3];
 80017dc:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80017e0:	f003 0b07 	and.w	fp, r3, #7
 80017e4:	f04f 0e0f 	mov.w	lr, #15
 80017e8:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
 80017ec:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3];
 80017f0:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80017f4:	fa0e fe0b 	lsl.w	lr, lr, fp
 80017f8:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 80017fc:	690d      	ldr	r5, [r1, #16]
 80017fe:	fa05 f50b 	lsl.w	r5, r5, fp
 8001802:	ea45 050e 	orr.w	r5, r5, lr
        GPIOx->AFR[position >> 3] = temp;
 8001806:	f8ca 5020 	str.w	r5, [sl, #32]
      temp = GPIOx->MODER;
 800180a:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800180e:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8001810:	f8d0 b000 	ldr.w	fp, [r0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001814:	f004 0e03 	and.w	lr, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001818:	fa05 f50a 	lsl.w	r5, r5, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800181c:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800181e:	fa0e fe0a 	lsl.w	lr, lr, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001822:	43ed      	mvns	r5, r5
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001824:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001826:	ea05 0b0b 	and.w	fp, r5, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800182a:	ea4e 0e0b 	orr.w	lr, lr, fp
      GPIOx->MODER = temp;
 800182e:	f8c0 e000 	str.w	lr, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001832:	d811      	bhi.n	8001858 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR;
 8001834:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001836:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 800183a:	68cf      	ldr	r7, [r1, #12]
 800183c:	fa07 fe0a 	lsl.w	lr, r7, sl
 8001840:	ea4e 070b 	orr.w	r7, lr, fp
        GPIOx->OSPEEDR = temp;
 8001844:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8001846:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001848:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800184c:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8001850:	409f      	lsls	r7, r3
 8001852:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 8001856:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8001858:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800185a:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800185c:	688f      	ldr	r7, [r1, #8]
 800185e:	fa07 f70a 	lsl.w	r7, r7, sl
 8001862:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8001864:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001866:	00e5      	lsls	r5, r4, #3
 8001868:	d566      	bpl.n	8001938 <HAL_GPIO_Init+0x190>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800186a:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 800186e:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001872:	f003 0c03 	and.w	ip, r3, #3
 8001876:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800187a:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
 800187e:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001882:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001886:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
 800188a:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 800188e:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8001892:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
 8001896:	9503      	str	r5, [sp, #12]
 8001898:	9d03      	ldr	r5, [sp, #12]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800189a:	fa0e f50c 	lsl.w	r5, lr, ip
        temp = SYSCFG->EXTICR[position >> 2];
 800189e:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80018a2:	ea2a 0e05 	bic.w	lr, sl, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80018a6:	4d32      	ldr	r5, [pc, #200]	; (8001970 <HAL_GPIO_Init+0x1c8>)
 80018a8:	42a8      	cmp	r0, r5
 80018aa:	d04c      	beq.n	8001946 <HAL_GPIO_Init+0x19e>
 80018ac:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018b0:	42a8      	cmp	r0, r5
 80018b2:	d04a      	beq.n	800194a <HAL_GPIO_Init+0x1a2>
 80018b4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018b8:	42a8      	cmp	r0, r5
 80018ba:	d048      	beq.n	800194e <HAL_GPIO_Init+0x1a6>
 80018bc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018c0:	42a8      	cmp	r0, r5
 80018c2:	d046      	beq.n	8001952 <HAL_GPIO_Init+0x1aa>
 80018c4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018c8:	42a8      	cmp	r0, r5
 80018ca:	d044      	beq.n	8001956 <HAL_GPIO_Init+0x1ae>
 80018cc:	4548      	cmp	r0, r9
 80018ce:	d044      	beq.n	800195a <HAL_GPIO_Init+0x1b2>
 80018d0:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80018d4:	42a8      	cmp	r0, r5
 80018d6:	d042      	beq.n	800195e <HAL_GPIO_Init+0x1b6>
 80018d8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018dc:	42a8      	cmp	r0, r5
 80018de:	d040      	beq.n	8001962 <HAL_GPIO_Init+0x1ba>
 80018e0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018e4:	42a8      	cmp	r0, r5
 80018e6:	d03e      	beq.n	8001966 <HAL_GPIO_Init+0x1be>
 80018e8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80018ec:	42a8      	cmp	r0, r5
 80018ee:	bf0c      	ite	eq
 80018f0:	2509      	moveq	r5, #9
 80018f2:	250a      	movne	r5, #10
 80018f4:	fa05 f50c 	lsl.w	r5, r5, ip
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80018f8:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80018fc:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8001900:	60bd      	str	r5, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
 8001902:	ea6f 0706 	mvn.w	r7, r6
        temp = EXTI->IMR;
 8001906:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8001908:	bf0c      	ite	eq
 800190a:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 800190c:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800190e:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        EXTI->IMR = temp;
 8001912:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8001914:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
 8001916:	bf0c      	ite	eq
 8001918:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 800191a:	4335      	orrne	r5, r6
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800191c:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        EXTI->EMR = temp;
 8001920:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 8001922:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8001924:	bf0c      	ite	eq
 8001926:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8001928:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800192a:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
 800192c:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 800192e:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
 8001930:	bf54      	ite	pl
 8001932:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 8001934:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 8001936:	60d5      	str	r5, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8001938:	3301      	adds	r3, #1
 800193a:	2b10      	cmp	r3, #16
 800193c:	f47f af3f 	bne.w	80017be <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 8001940:	b005      	add	sp, #20
 8001942:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001946:	2500      	movs	r5, #0
 8001948:	e7d4      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 800194a:	2501      	movs	r5, #1
 800194c:	e7d2      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 800194e:	2502      	movs	r5, #2
 8001950:	e7d0      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 8001952:	2503      	movs	r5, #3
 8001954:	e7ce      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 8001956:	2504      	movs	r5, #4
 8001958:	e7cc      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 800195a:	2505      	movs	r5, #5
 800195c:	e7ca      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 800195e:	2506      	movs	r5, #6
 8001960:	e7c8      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 8001962:	2507      	movs	r5, #7
 8001964:	e7c6      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 8001966:	2508      	movs	r5, #8
 8001968:	e7c4      	b.n	80018f4 <HAL_GPIO_Init+0x14c>
 800196a:	bf00      	nop
 800196c:	40013c00 	.word	0x40013c00
 8001970:	40020000 	.word	0x40020000
 8001974:	40023800 	.word	0x40023800
 8001978:	40021400 	.word	0x40021400

0800197c <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
 800197c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmp, tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
 800197e:	4604      	mov	r4, r0
 8001980:	2800      	cmp	r0, #0
 8001982:	d063      	beq.n	8001a4c <HAL_LTDC_Init+0xd0>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
 8001984:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
 8001988:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800198c:	b91b      	cbnz	r3, 8001996 <HAL_LTDC_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
 800198e:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
 8001992:	f003 f858 	bl	8004a46 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8001996:	2302      	movs	r3, #2
 8001998:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 800199c:	6823      	ldr	r3, [r4, #0]
 800199e:	699a      	ldr	r2, [r3, #24]
 80019a0:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80019a4:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 80019a6:	6999      	ldr	r1, [r3, #24]
 80019a8:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 80019ac:	4302      	orrs	r2, r0
 80019ae:	68e0      	ldr	r0, [r4, #12]
 80019b0:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 80019b2:	6920      	ldr	r0, [r4, #16]
 80019b4:	4302      	orrs	r2, r0

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
  tmp = (hltdc->Init.HorizontalSync << 16U);
 80019b6:	6960      	ldr	r0, [r4, #20]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 80019b8:	430a      	orrs	r2, r1
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 80019ba:	4925      	ldr	r1, [pc, #148]	; (8001a50 <HAL_LTDC_Init+0xd4>)
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 80019bc:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 80019be:	689a      	ldr	r2, [r3, #8]
 80019c0:	400a      	ands	r2, r1
 80019c2:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 80019c4:	689a      	ldr	r2, [r3, #8]
 80019c6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80019ca:	69a0      	ldr	r0, [r4, #24]
 80019cc:	4302      	orrs	r2, r0

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
 80019ce:	69e0      	ldr	r0, [r4, #28]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 80019d0:	609a      	str	r2, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 80019d2:	68da      	ldr	r2, [r3, #12]
 80019d4:	400a      	ands	r2, r1
 80019d6:	60da      	str	r2, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 80019d8:	68da      	ldr	r2, [r3, #12]
 80019da:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80019de:	6a20      	ldr	r0, [r4, #32]
 80019e0:	4302      	orrs	r2, r0

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
 80019e2:	6a60      	ldr	r0, [r4, #36]	; 0x24
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 80019e4:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 80019e6:	691a      	ldr	r2, [r3, #16]
 80019e8:	400a      	ands	r2, r1
 80019ea:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 80019ec:	691a      	ldr	r2, [r3, #16]
 80019ee:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80019f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80019f4:	4302      	orrs	r2, r0
 80019f6:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 80019f8:	695a      	ldr	r2, [r3, #20]
 80019fa:	4011      	ands	r1, r2
 80019fc:	6159      	str	r1, [r3, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
 80019fe:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8001a00:	695a      	ldr	r2, [r3, #20]
 8001a02:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8001a06:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001a08:	430a      	orrs	r2, r1
 8001a0a:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8001a0c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8001a0e:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8001a12:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8001a16:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8001a1a:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8001a1c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001a1e:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8001a22:	430a      	orrs	r2, r1
 8001a24:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 8001a28:	ea42 4200 	orr.w	r2, r2, r0, lsl #16

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8001a2c:	2000      	movs	r0, #0
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8001a2e:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8001a30:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001a32:	f042 0206 	orr.w	r2, r2, #6
 8001a36:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
 8001a38:	699a      	ldr	r2, [r3, #24]
 8001a3a:	f042 0201 	orr.w	r2, r2, #1
 8001a3e:	619a      	str	r2, [r3, #24]

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8001a40:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8001a42:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 8001a46:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1

  return HAL_OK;
}
 8001a4a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001a4c:	2001      	movs	r0, #1
 8001a4e:	e7fc      	b.n	8001a4a <HAL_LTDC_Init+0xce>
 8001a50:	f000f800 	.word	0xf000f800

08001a54 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001a54:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001a58:	6802      	ldr	r2, [r0, #0]
{
 8001a5a:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001a5c:	f012 0601 	ands.w	r6, r2, #1
 8001a60:	d00b      	beq.n	8001a7a <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001a62:	4bbb      	ldr	r3, [pc, #748]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001a64:	6899      	ldr	r1, [r3, #8]
 8001a66:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 8001a6a:	6099      	str	r1, [r3, #8]
 8001a6c:	6b46      	ldr	r6, [r0, #52]	; 0x34
 8001a6e:	6899      	ldr	r1, [r3, #8]
 8001a70:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8001a72:	fab6 f686 	clz	r6, r6
 8001a76:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001a78:	6099      	str	r1, [r3, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8001a7a:	f412 2500 	ands.w	r5, r2, #524288	; 0x80000
 8001a7e:	d012      	beq.n	8001aa6 <HAL_RCCEx_PeriphCLKConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001a80:	49b3      	ldr	r1, [pc, #716]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001a82:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8001a84:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8001a88:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001a8c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    {
      plli2sused = 1;
 8001a90:	bf08      	it	eq
 8001a92:	2601      	moveq	r6, #1
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001a94:	ea43 0305 	orr.w	r3, r3, r5
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001a98:	bf16      	itet	ne
 8001a9a:	fab5 f585 	clzne	r5, r5
  uint32_t pllsaiused = 0;
 8001a9e:	2500      	moveq	r5, #0
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001aa0:	096d      	lsrne	r5, r5, #5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001aa2:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8001aa6:	02d1      	lsls	r1, r2, #11
 8001aa8:	d510      	bpl.n	8001acc <HAL_RCCEx_PeriphCLKConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8001aaa:	48a9      	ldr	r0, [pc, #676]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001aac:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001aae:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001ab2:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8001ab6:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8001aba:	ea43 0301 	orr.w	r3, r3, r1
 8001abe:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001ac2:	f000 81aa 	beq.w	8001e1a <HAL_RCCEx_PeriphCLKConfig+0x3c6>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8001ac6:	2900      	cmp	r1, #0
 8001ac8:	bf08      	it	eq
 8001aca:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 8001acc:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 8001ad0:	bf18      	it	ne
 8001ad2:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8001ad4:	0692      	lsls	r2, r2, #26
 8001ad6:	d531      	bpl.n	8001b3c <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001ad8:	4b9d      	ldr	r3, [pc, #628]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8001ada:	4f9e      	ldr	r7, [pc, #632]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x300>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8001adc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001ade:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001ae2:	641a      	str	r2, [r3, #64]	; 0x40
 8001ae4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ae6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001aea:	9301      	str	r3, [sp, #4]
 8001aec:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8001aee:	683b      	ldr	r3, [r7, #0]
 8001af0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001af4:	603b      	str	r3, [r7, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001af6:	f002 fc52 	bl	800439e <HAL_GetTick>
 8001afa:	4680      	mov	r8, r0

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001afc:	683b      	ldr	r3, [r7, #0]
 8001afe:	05db      	lsls	r3, r3, #23
 8001b00:	f140 818d 	bpl.w	8001e1e <HAL_RCCEx_PeriphCLKConfig+0x3ca>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8001b04:	4f92      	ldr	r7, [pc, #584]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b06:	6f3b      	ldr	r3, [r7, #112]	; 0x70

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001b08:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001b0c:	f040 8192 	bne.w	8001e34 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001b10:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001b12:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8001b16:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8001b1a:	4a8d      	ldr	r2, [pc, #564]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b1c:	f040 81b0 	bne.w	8001e80 <HAL_RCCEx_PeriphCLKConfig+0x42c>
 8001b20:	6891      	ldr	r1, [r2, #8]
 8001b22:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
 8001b26:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8001b2a:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8001b2e:	4301      	orrs	r1, r0
 8001b30:	6091      	str	r1, [r2, #8]
 8001b32:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8001b36:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8001b38:	430b      	orrs	r3, r1
 8001b3a:	6713      	str	r3, [r2, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8001b3c:	6823      	ldr	r3, [r4, #0]
 8001b3e:	06da      	lsls	r2, r3, #27
 8001b40:	d50c      	bpl.n	8001b5c <HAL_RCCEx_PeriphCLKConfig+0x108>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8001b42:	4a83      	ldr	r2, [pc, #524]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b44:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001b48:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8001b4c:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8001b50:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001b54:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001b56:	4301      	orrs	r1, r0
 8001b58:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001b5c:	045f      	lsls	r7, r3, #17
 8001b5e:	d508      	bpl.n	8001b72 <HAL_RCCEx_PeriphCLKConfig+0x11e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001b60:	497b      	ldr	r1, [pc, #492]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b62:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8001b64:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001b68:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8001b6c:	4302      	orrs	r2, r0
 8001b6e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001b72:	0418      	lsls	r0, r3, #16
 8001b74:	d508      	bpl.n	8001b88 <HAL_RCCEx_PeriphCLKConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001b76:	4976      	ldr	r1, [pc, #472]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b78:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8001b7a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001b7e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001b82:	4302      	orrs	r2, r0
 8001b84:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001b88:	03d9      	lsls	r1, r3, #15
 8001b8a:	d508      	bpl.n	8001b9e <HAL_RCCEx_PeriphCLKConfig+0x14a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001b8c:	4970      	ldr	r1, [pc, #448]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001b8e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001b90:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001b94:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001b98:	4302      	orrs	r2, r0
 8001b9a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8001b9e:	039a      	lsls	r2, r3, #14
 8001ba0:	d508      	bpl.n	8001bb4 <HAL_RCCEx_PeriphCLKConfig+0x160>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8001ba2:	496b      	ldr	r1, [pc, #428]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001ba4:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8001ba6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001baa:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8001bae:	4302      	orrs	r2, r0
 8001bb0:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001bb4:	065f      	lsls	r7, r3, #25
 8001bb6:	d508      	bpl.n	8001bca <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001bb8:	4965      	ldr	r1, [pc, #404]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001bba:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8001bbc:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001bc0:	f022 0203 	bic.w	r2, r2, #3
 8001bc4:	4302      	orrs	r2, r0
 8001bc6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001bca:	0618      	lsls	r0, r3, #24
 8001bcc:	d508      	bpl.n	8001be0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001bce:	4960      	ldr	r1, [pc, #384]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001bd0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8001bd2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001bd6:	f022 020c 	bic.w	r2, r2, #12
 8001bda:	4302      	orrs	r2, r0
 8001bdc:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8001be0:	05d9      	lsls	r1, r3, #23
 8001be2:	d508      	bpl.n	8001bf6 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8001be4:	495a      	ldr	r1, [pc, #360]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001be6:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8001be8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001bec:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8001bf0:	4302      	orrs	r2, r0
 8001bf2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8001bf6:	059a      	lsls	r2, r3, #22
 8001bf8:	d508      	bpl.n	8001c0c <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8001bfa:	4955      	ldr	r1, [pc, #340]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001bfc:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8001bfe:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c02:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8001c06:	4302      	orrs	r2, r0
 8001c08:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8001c0c:	055f      	lsls	r7, r3, #21
 8001c0e:	d508      	bpl.n	8001c22 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8001c10:	494f      	ldr	r1, [pc, #316]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c12:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8001c14:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c18:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001c1c:	4302      	orrs	r2, r0
 8001c1e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8001c22:	0518      	lsls	r0, r3, #20
 8001c24:	d508      	bpl.n	8001c38 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8001c26:	494a      	ldr	r1, [pc, #296]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c28:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8001c2a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c2e:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8001c32:	4302      	orrs	r2, r0
 8001c34:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8001c38:	04d9      	lsls	r1, r3, #19
 8001c3a:	d508      	bpl.n	8001c4e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8001c3c:	4944      	ldr	r1, [pc, #272]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c3e:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8001c40:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c44:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001c48:	4302      	orrs	r2, r0
 8001c4a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8001c4e:	049a      	lsls	r2, r3, #18
 8001c50:	d508      	bpl.n	8001c64 <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8001c52:	493f      	ldr	r1, [pc, #252]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c54:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8001c56:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c5a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8001c5e:	4302      	orrs	r2, r0
 8001c60:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8001c64:	025f      	lsls	r7, r3, #9
 8001c66:	d508      	bpl.n	8001c7a <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8001c68:	4939      	ldr	r1, [pc, #228]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c6a:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8001c6c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c70:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001c74:	4302      	orrs	r2, r0
 8001c76:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8001c7a:	0298      	lsls	r0, r3, #10
 8001c7c:	d50c      	bpl.n	8001c98 <HAL_RCCEx_PeriphCLKConfig+0x244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001c7e:	4834      	ldr	r0, [pc, #208]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001c80:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8001c82:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 8001c86:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001c8a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
 8001c8e:	bf08      	it	eq
 8001c90:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001c92:	430a      	orrs	r2, r1
 8001c94:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 8001c98:	f013 0f08 	tst.w	r3, #8
 8001c9c:	bf18      	it	ne
 8001c9e:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8001ca0:	0359      	lsls	r1, r3, #13
 8001ca2:	d508      	bpl.n	8001cb6 <HAL_RCCEx_PeriphCLKConfig+0x262>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001ca4:	492a      	ldr	r1, [pc, #168]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001ca6:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8001ca8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cac:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001cb0:	4302      	orrs	r2, r0
 8001cb2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8001cb6:	021a      	lsls	r2, r3, #8
 8001cb8:	d509      	bpl.n	8001cce <HAL_RCCEx_PeriphCLKConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001cba:	4925      	ldr	r1, [pc, #148]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001cbc:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8001cc0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cc4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8001cc8:	4302      	orrs	r2, r0
 8001cca:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 8001cce:	015f      	lsls	r7, r3, #5
 8001cd0:	d509      	bpl.n	8001ce6 <HAL_RCCEx_PeriphCLKConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 8001cd2:	491f      	ldr	r1, [pc, #124]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001cd4:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8001cd8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cdc:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 8001ce0:	4302      	orrs	r2, r0
 8001ce2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8001ce6:	0118      	lsls	r0, r3, #4
 8001ce8:	d509      	bpl.n	8001cfe <HAL_RCCEx_PeriphCLKConfig+0x2aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8001cea:	4919      	ldr	r1, [pc, #100]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001cec:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8001cf0:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8001cf4:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 8001cf8:	4302      	orrs	r2, r0
 8001cfa:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 8001cfe:	00d9      	lsls	r1, r3, #3
 8001d00:	d509      	bpl.n	8001d16 <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8001d02:	4913      	ldr	r1, [pc, #76]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001d04:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8001d08:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8001d0c:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001d10:	4302      	orrs	r2, r0
 8001d12:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8001d16:	2e01      	cmp	r6, #1
 8001d18:	f000 80b6 	beq.w	8001e88 <HAL_RCCEx_PeriphCLKConfig+0x434>
 8001d1c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8001d20:	f000 80b2 	beq.w	8001e88 <HAL_RCCEx_PeriphCLKConfig+0x434>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8001d24:	2d01      	cmp	r5, #1
 8001d26:	d176      	bne.n	8001e16 <HAL_RCCEx_PeriphCLKConfig+0x3c2>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 8001d28:	4d09      	ldr	r5, [pc, #36]	; (8001d50 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8001d2a:	682b      	ldr	r3, [r5, #0]
 8001d2c:	462e      	mov	r6, r5
 8001d2e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001d32:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001d34:	f002 fb33 	bl	800439e <HAL_GetTick>
 8001d38:	4607      	mov	r7, r0

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8001d3a:	682b      	ldr	r3, [r5, #0]
 8001d3c:	009b      	lsls	r3, r3, #2
 8001d3e:	f100 8127 	bmi.w	8001f90 <HAL_RCCEx_PeriphCLKConfig+0x53c>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8001d42:	6822      	ldr	r2, [r4, #0]
 8001d44:	0315      	lsls	r5, r2, #12
 8001d46:	d507      	bpl.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x304>
 8001d48:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001d4a:	b14b      	cbz	r3, 8001d60 <HAL_RCCEx_PeriphCLKConfig+0x30c>
 8001d4c:	e004      	b.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x304>
 8001d4e:	bf00      	nop
 8001d50:	40023800 	.word	0x40023800
 8001d54:	40007000 	.word	0x40007000
 8001d58:	02d0      	lsls	r0, r2, #11
 8001d5a:	d51c      	bpl.n	8001d96 <HAL_RCCEx_PeriphCLKConfig+0x342>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8001d5c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001d5e:	b9d3      	cbnz	r3, 8001d96 <HAL_RCCEx_PeriphCLKConfig+0x342>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8001d60:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8001d64:	f8d6 1088 	ldr.w	r1, [r6, #136]	; 0x88
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001d68:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001d6c:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8001d70:	430b      	orrs	r3, r1
 8001d72:	6961      	ldr	r1, [r4, #20]
 8001d74:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8001d78:	69a1      	ldr	r1, [r4, #24]
 8001d7a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8001d7e:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8001d82:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 8001d86:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001d88:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8001d8c:	3901      	subs	r1, #1
 8001d8e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001d92:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8001d96:	0291      	lsls	r1, r2, #10
 8001d98:	d515      	bpl.n	8001dc6 <HAL_RCCEx_PeriphCLKConfig+0x372>
 8001d9a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8001d9c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8001da0:	d111      	bne.n	8001dc6 <HAL_RCCEx_PeriphCLKConfig+0x372>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001da2:	4982      	ldr	r1, [pc, #520]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001da4:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8001da8:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8001dac:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8001db0:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8001db4:	4303      	orrs	r3, r0
 8001db6:	6960      	ldr	r0, [r4, #20]
 8001db8:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8001dbc:	6a20      	ldr	r0, [r4, #32]
 8001dbe:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8001dc2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8001dc6:	0712      	lsls	r2, r2, #28
 8001dc8:	d519      	bpl.n	8001dfe <HAL_RCCEx_PeriphCLKConfig+0x3aa>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001dca:	4978      	ldr	r1, [pc, #480]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001dcc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8001dd0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8001dd4:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8001dd8:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001ddc:	4313      	orrs	r3, r2
 8001dde:	6962      	ldr	r2, [r4, #20]
 8001de0:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001de4:	69e2      	ldr	r2, [r4, #28]
 8001de6:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8001dea:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8001dee:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
 8001df2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001df4:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001df8:	4313      	orrs	r3, r2
 8001dfa:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 8001dfe:	4c6b      	ldr	r4, [pc, #428]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001e00:	6823      	ldr	r3, [r4, #0]
 8001e02:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001e06:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001e08:	f002 fac9 	bl	800439e <HAL_GetTick>
 8001e0c:	4605      	mov	r5, r0

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8001e0e:	6823      	ldr	r3, [r4, #0]
 8001e10:	009b      	lsls	r3, r3, #2
 8001e12:	f140 80c4 	bpl.w	8001f9e <HAL_RCCEx_PeriphCLKConfig+0x54a>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8001e16:	2000      	movs	r0, #0
 8001e18:	e009      	b.n	8001e2e <HAL_RCCEx_PeriphCLKConfig+0x3da>
      plli2sused = 1;
 8001e1a:	2601      	movs	r6, #1
 8001e1c:	e656      	b.n	8001acc <HAL_RCCEx_PeriphCLKConfig+0x78>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001e1e:	f002 fabe 	bl	800439e <HAL_GetTick>
 8001e22:	eba0 0008 	sub.w	r0, r0, r8
 8001e26:	2864      	cmp	r0, #100	; 0x64
 8001e28:	f67f ae68 	bls.w	8001afc <HAL_RCCEx_PeriphCLKConfig+0xa8>
        return HAL_TIMEOUT;
 8001e2c:	2003      	movs	r0, #3
}
 8001e2e:	b003      	add	sp, #12
 8001e30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001e34:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001e36:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001e3a:	4293      	cmp	r3, r2
 8001e3c:	f43f ae68 	beq.w	8001b10 <HAL_RCCEx_PeriphCLKConfig+0xbc>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8001e40:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8001e42:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8001e44:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8001e48:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001e4c:	673a      	str	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001e4e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001e50:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001e54:	673a      	str	r2, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 8001e56:	673b      	str	r3, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8001e58:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001e5a:	07d8      	lsls	r0, r3, #31
 8001e5c:	f57f ae58 	bpl.w	8001b10 <HAL_RCCEx_PeriphCLKConfig+0xbc>
        tickstart = HAL_GetTick();
 8001e60:	f002 fa9d 	bl	800439e <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001e64:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8001e68:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001e6a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001e6c:	0799      	lsls	r1, r3, #30
 8001e6e:	f53f ae4f 	bmi.w	8001b10 <HAL_RCCEx_PeriphCLKConfig+0xbc>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001e72:	f002 fa94 	bl	800439e <HAL_GetTick>
 8001e76:	eba0 0008 	sub.w	r0, r0, r8
 8001e7a:	4548      	cmp	r0, r9
 8001e7c:	d9f5      	bls.n	8001e6a <HAL_RCCEx_PeriphCLKConfig+0x416>
 8001e7e:	e7d5      	b.n	8001e2c <HAL_RCCEx_PeriphCLKConfig+0x3d8>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001e80:	6891      	ldr	r1, [r2, #8]
 8001e82:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8001e86:	e653      	b.n	8001b30 <HAL_RCCEx_PeriphCLKConfig+0xdc>
    __HAL_RCC_PLLI2S_DISABLE();
 8001e88:	4e48      	ldr	r6, [pc, #288]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001e8a:	6833      	ldr	r3, [r6, #0]
 8001e8c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001e90:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8001e92:	f002 fa84 	bl	800439e <HAL_GetTick>
 8001e96:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001e98:	6833      	ldr	r3, [r6, #0]
 8001e9a:	011a      	lsls	r2, r3, #4
 8001e9c:	d472      	bmi.n	8001f84 <HAL_RCCEx_PeriphCLKConfig+0x530>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8001e9e:	6822      	ldr	r2, [r4, #0]
 8001ea0:	07d3      	lsls	r3, r2, #31
 8001ea2:	d512      	bpl.n	8001eca <HAL_RCCEx_PeriphCLKConfig+0x476>
 8001ea4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001ea6:	b983      	cbnz	r3, 8001eca <HAL_RCCEx_PeriphCLKConfig+0x476>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8001ea8:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8001eac:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8001eb0:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001eb4:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8001eb8:	430b      	orrs	r3, r1
 8001eba:	6861      	ldr	r1, [r4, #4]
 8001ebc:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8001ec0:	68a1      	ldr	r1, [r4, #8]
 8001ec2:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8001ec6:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8001eca:	0317      	lsls	r7, r2, #12
 8001ecc:	d503      	bpl.n	8001ed6 <HAL_RCCEx_PeriphCLKConfig+0x482>
 8001ece:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001ed0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8001ed4:	d005      	beq.n	8001ee2 <HAL_RCCEx_PeriphCLKConfig+0x48e>
 8001ed6:	02d6      	lsls	r6, r2, #11
 8001ed8:	d51e      	bpl.n	8001f18 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8001eda:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001edc:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8001ee0:	d11a      	bne.n	8001f18 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8001ee2:	4932      	ldr	r1, [pc, #200]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001ee4:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8001ee8:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8001eec:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001ef0:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8001ef4:	4303      	orrs	r3, r0
 8001ef6:	6860      	ldr	r0, [r4, #4]
 8001ef8:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8001efc:	68e0      	ldr	r0, [r4, #12]
 8001efe:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8001f02:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8001f06:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
 8001f0a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f0c:	f020 001f 	bic.w	r0, r0, #31
 8001f10:	3b01      	subs	r3, #1
 8001f12:	4303      	orrs	r3, r0
 8001f14:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8001f18:	01d0      	lsls	r0, r2, #7
 8001f1a:	d511      	bpl.n	8001f40 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8001f1c:	4923      	ldr	r1, [pc, #140]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001f1e:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8001f22:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001f26:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8001f2a:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8001f2e:	4303      	orrs	r3, r0
 8001f30:	6860      	ldr	r0, [r4, #4]
 8001f32:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8001f36:	6920      	ldr	r0, [r4, #16]
 8001f38:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8001f3c:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8001f40:	0191      	lsls	r1, r2, #6
 8001f42:	d50d      	bpl.n	8001f60 <HAL_RCCEx_PeriphCLKConfig+0x50c>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8001f44:	6923      	ldr	r3, [r4, #16]
 8001f46:	6862      	ldr	r2, [r4, #4]
 8001f48:	041b      	lsls	r3, r3, #16
 8001f4a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001f4e:	68e2      	ldr	r2, [r4, #12]
 8001f50:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001f54:	68a2      	ldr	r2, [r4, #8]
 8001f56:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8001f5a:	4a14      	ldr	r2, [pc, #80]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001f5c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8001f60:	4e12      	ldr	r6, [pc, #72]	; (8001fac <HAL_RCCEx_PeriphCLKConfig+0x558>)
 8001f62:	6833      	ldr	r3, [r6, #0]
 8001f64:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001f68:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8001f6a:	f002 fa18 	bl	800439e <HAL_GetTick>
 8001f6e:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001f70:	6833      	ldr	r3, [r6, #0]
 8001f72:	011a      	lsls	r2, r3, #4
 8001f74:	f53f aed6 	bmi.w	8001d24 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001f78:	f002 fa11 	bl	800439e <HAL_GetTick>
 8001f7c:	1bc0      	subs	r0, r0, r7
 8001f7e:	2864      	cmp	r0, #100	; 0x64
 8001f80:	d9f6      	bls.n	8001f70 <HAL_RCCEx_PeriphCLKConfig+0x51c>
 8001f82:	e753      	b.n	8001e2c <HAL_RCCEx_PeriphCLKConfig+0x3d8>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001f84:	f002 fa0b 	bl	800439e <HAL_GetTick>
 8001f88:	1bc0      	subs	r0, r0, r7
 8001f8a:	2864      	cmp	r0, #100	; 0x64
 8001f8c:	d984      	bls.n	8001e98 <HAL_RCCEx_PeriphCLKConfig+0x444>
 8001f8e:	e74d      	b.n	8001e2c <HAL_RCCEx_PeriphCLKConfig+0x3d8>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001f90:	f002 fa05 	bl	800439e <HAL_GetTick>
 8001f94:	1bc0      	subs	r0, r0, r7
 8001f96:	2864      	cmp	r0, #100	; 0x64
 8001f98:	f67f aecf 	bls.w	8001d3a <HAL_RCCEx_PeriphCLKConfig+0x2e6>
 8001f9c:	e746      	b.n	8001e2c <HAL_RCCEx_PeriphCLKConfig+0x3d8>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001f9e:	f002 f9fe 	bl	800439e <HAL_GetTick>
 8001fa2:	1b40      	subs	r0, r0, r5
 8001fa4:	2864      	cmp	r0, #100	; 0x64
 8001fa6:	f67f af32 	bls.w	8001e0e <HAL_RCCEx_PeriphCLKConfig+0x3ba>
 8001faa:	e73f      	b.n	8001e2c <HAL_RCCEx_PeriphCLKConfig+0x3d8>
 8001fac:	40023800 	.word	0x40023800

08001fb0 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 8001fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001fb4:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001fb6:	e9d1 3807 	ldrd	r3, r8, [r1, #28]
 8001fba:	e9d1 4e01 	ldrd	r4, lr, [r1, #4]
 8001fbe:	e9d1 c703 	ldrd	ip, r7, [r1, #12]
 8001fc2:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2)
 8001fc6:	6809      	ldr	r1, [r1, #0]
 8001fc8:	ea43 0308 	orr.w	r3, r3, r8
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8001fcc:	f8d0 8000 	ldr.w	r8, [r0]
  if (Init->SDBank != FMC_SDRAM_BANK2)
 8001fd0:	2901      	cmp	r1, #1
 8001fd2:	4912      	ldr	r1, [pc, #72]	; (800201c <FMC_SDRAM_Init+0x6c>)
 8001fd4:	d00f      	beq.n	8001ff6 <FMC_SDRAM_Init+0x46>
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8001fd6:	431a      	orrs	r2, r3
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8001fd8:	ea08 0101 	and.w	r1, r8, r1
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8001fdc:	4322      	orrs	r2, r4
 8001fde:	ea42 030e 	orr.w	r3, r2, lr
 8001fe2:	ea43 030c 	orr.w	r3, r3, ip
 8001fe6:	433b      	orrs	r3, r7
 8001fe8:	4333      	orrs	r3, r6
 8001fea:	432b      	orrs	r3, r5
 8001fec:	430b      	orrs	r3, r1
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8001fee:	6003      	str	r3, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }

  return HAL_OK;
}
 8001ff0:	2000      	movs	r0, #0
 8001ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8001ff6:	4313      	orrs	r3, r2
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 8001ff8:	6842      	ldr	r2, [r0, #4]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 8001ffa:	f428 48f8 	bic.w	r8, r8, #31744	; 0x7c00
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8001ffe:	4011      	ands	r1, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002000:	ea44 020e 	orr.w	r2, r4, lr
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8002004:	ea43 0308 	orr.w	r3, r3, r8
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002008:	ea42 020c 	orr.w	r2, r2, ip
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800200c:	6003      	str	r3, [r0, #0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800200e:	433a      	orrs	r2, r7
 8002010:	4332      	orrs	r2, r6
 8002012:	432a      	orrs	r2, r5
 8002014:	430a      	orrs	r2, r1
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8002016:	6042      	str	r2, [r0, #4]
 8002018:	e7ea      	b.n	8001ff0 <FMC_SDRAM_Init+0x40>
 800201a:	bf00      	nop
 800201c:	ffff8000 	.word	0xffff8000

08002020 <UTILS_PLL_IsBusy>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8002020:	4b08      	ldr	r3, [pc, #32]	; (8002044 <UTILS_PLL_IsBusy+0x24>)
 8002022:	6819      	ldr	r1, [r3, #0]
  * @rmtoll CR           PLLSAIRDY    LL_RCC_PLLSAI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLLSAI_IsReady(void)
{
  return (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) == (RCC_CR_PLLSAIRDY));
 8002024:	681a      	ldr	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8002026:	f001 7100 	and.w	r1, r1, #33554432	; 0x2000000
  return (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) == (RCC_CR_PLLI2SRDY));
 800202a:	681b      	ldr	r3, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) == (RCC_CR_PLLSAIRDY));
 800202c:	f002 5200 	and.w	r2, r2, #536870912	; 0x20000000
static ErrorStatus UTILS_PLL_IsBusy(void)
{
  ErrorStatus status = SUCCESS;

  /* Check if PLL is busy*/
  if(LL_RCC_PLL_IsReady() != 0U)
 8002030:	430a      	orrs	r2, r1
 8002032:	bf14      	ite	ne
 8002034:	2001      	movne	r0, #1
 8002036:	2000      	moveq	r0, #0
  {
    /* PLLSAI1 configuration cannot be modified */
    status = ERROR;
  }
  /* Check if PLLI2S is busy*/
  if(LL_RCC_PLLI2S_IsReady() != 0U)
 8002038:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  {
    /* PLLI2S configuration cannot be modified */
    status = ERROR;
  }
  return status;
}
 800203c:	bf18      	it	ne
 800203e:	2001      	movne	r0, #1
 8002040:	4770      	bx	lr
 8002042:	bf00      	nop
 8002044:	40023800 	.word	0x40023800

08002048 <UTILS_SetFlashLatency.part.0>:
  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE2
  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE3
  */
__STATIC_INLINE uint32_t LL_PWR_GetRegulVoltageScaling(void)
{
  return (uint32_t)(READ_BIT(PWR->CR1, PWR_CR1_VOS));
 8002048:	4b2e      	ldr	r3, [pc, #184]	; (8002104 <UTILS_SetFlashLatency.part.0+0xbc>)
 800204a:	681a      	ldr	r2, [r3, #0]
  return (READ_BIT(PWR->CR1, PWR_CR1_ODEN) == (PWR_CR1_ODEN));
 800204c:	681b      	ldr	r3, [r3, #0]
  return (uint32_t)(READ_BIT(PWR->CR1, PWR_CR1_VOS));
 800204e:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 8002052:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
 8002056:	d123      	bne.n	80020a0 <UTILS_SetFlashLatency.part.0+0x58>
      if(LL_PWR_IsEnabledOverDriveMode() != 0U)
 8002058:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 800205c:	d03c      	beq.n	80020d8 <UTILS_SetFlashLatency.part.0+0x90>
          if(HCLK_Frequency > UTILS_SCALE1_LATENCY7_FREQ)
 800205e:	4b2a      	ldr	r3, [pc, #168]	; (8002108 <UTILS_SetFlashLatency.part.0+0xc0>)
 8002060:	4298      	cmp	r0, r3
 8002062:	d83e      	bhi.n	80020e2 <UTILS_SetFlashLatency.part.0+0x9a>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ) && (latency == LL_FLASH_LATENCY_0))
 8002064:	4b29      	ldr	r3, [pc, #164]	; (800210c <UTILS_SetFlashLatency.part.0+0xc4>)
 8002066:	4298      	cmp	r0, r3
 8002068:	d83d      	bhi.n	80020e6 <UTILS_SetFlashLatency.part.0+0x9e>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ) && (latency == LL_FLASH_LATENCY_0))
 800206a:	4b29      	ldr	r3, [pc, #164]	; (8002110 <UTILS_SetFlashLatency.part.0+0xc8>)
 800206c:	4298      	cmp	r0, r3
 800206e:	d83a      	bhi.n	80020e6 <UTILS_SetFlashLatency.part.0+0x9e>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ) && (latency == LL_FLASH_LATENCY_0))
 8002070:	4b28      	ldr	r3, [pc, #160]	; (8002114 <UTILS_SetFlashLatency.part.0+0xcc>)
 8002072:	4298      	cmp	r0, r3
            latency = LL_FLASH_LATENCY_6;
 8002074:	f04f 0306 	mov.w	r3, #6
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ) && (latency == LL_FLASH_LATENCY_0))
 8002078:	d805      	bhi.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
        if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (latency == LL_FLASH_LATENCY_0))
 800207a:	4a27      	ldr	r2, [pc, #156]	; (8002118 <UTILS_SetFlashLatency.part.0+0xd0>)
 800207c:	4290      	cmp	r0, r2
 800207e:	d902      	bls.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
 8002080:	2b00      	cmp	r3, #0
          latency = LL_FLASH_LATENCY_1;
 8002082:	bf08      	it	eq
 8002084:	2301      	moveq	r3, #1
  *         @arg @ref LL_FLASH_LATENCY_15
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8002086:	4925      	ldr	r1, [pc, #148]	; (800211c <UTILS_SetFlashLatency.part.0+0xd4>)
 8002088:	680a      	ldr	r2, [r1, #0]
 800208a:	f022 020f 	bic.w	r2, r2, #15
 800208e:	431a      	orrs	r2, r3
 8002090:	600a      	str	r2, [r1, #0]
  *         @arg @ref LL_FLASH_LATENCY_14
  *         @arg @ref LL_FLASH_LATENCY_15
  */
__STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
{
  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 8002092:	6808      	ldr	r0, [r1, #0]
 8002094:	f000 000f 	and.w	r0, r0, #15
  return status;
 8002098:	1ac0      	subs	r0, r0, r3
 800209a:	bf18      	it	ne
 800209c:	2001      	movne	r0, #1
}
 800209e:	4770      	bx	lr
 80020a0:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    else if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 80020a4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80020a8:	d105      	bne.n	80020b6 <UTILS_SetFlashLatency.part.0+0x6e>
      if(HCLK_Frequency > UTILS_SCALE2_LATENCY5_FREQ)
 80020aa:	f103 630f 	add.w	r3, r3, #149946368	; 0x8f00000
 80020ae:	f503 43a3 	add.w	r3, r3, #20864	; 0x5180
 80020b2:	4298      	cmp	r0, r3
 80020b4:	d813      	bhi.n	80020de <UTILS_SetFlashLatency.part.0+0x96>
      if(HCLK_Frequency > UTILS_SCALE3_LATENCY4_FREQ)
 80020b6:	4b15      	ldr	r3, [pc, #84]	; (800210c <UTILS_SetFlashLatency.part.0+0xc4>)
 80020b8:	4298      	cmp	r0, r3
 80020ba:	d80b      	bhi.n	80020d4 <UTILS_SetFlashLatency.part.0+0x8c>
      else if(HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)
 80020bc:	4b14      	ldr	r3, [pc, #80]	; (8002110 <UTILS_SetFlashLatency.part.0+0xc8>)
 80020be:	4298      	cmp	r0, r3
 80020c0:	d819      	bhi.n	80020f6 <UTILS_SetFlashLatency.part.0+0xae>
      else if(HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)
 80020c2:	4b14      	ldr	r3, [pc, #80]	; (8002114 <UTILS_SetFlashLatency.part.0+0xcc>)
 80020c4:	4298      	cmp	r0, r3
 80020c6:	d81b      	bhi.n	8002100 <UTILS_SetFlashLatency.part.0+0xb8>
        if(HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)
 80020c8:	4b13      	ldr	r3, [pc, #76]	; (8002118 <UTILS_SetFlashLatency.part.0+0xd0>)
 80020ca:	4298      	cmp	r0, r3
 80020cc:	bf94      	ite	ls
 80020ce:	2300      	movls	r3, #0
 80020d0:	2301      	movhi	r3, #1
 80020d2:	e7d8      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
        latency = LL_FLASH_LATENCY_4;
 80020d4:	2304      	movs	r3, #4
 80020d6:	e7d6      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
      if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ) && (latency == LL_FLASH_LATENCY_0))
 80020d8:	4a11      	ldr	r2, [pc, #68]	; (8002120 <UTILS_SetFlashLatency.part.0+0xd8>)
 80020da:	4290      	cmp	r0, r2
 80020dc:	d905      	bls.n	80020ea <UTILS_SetFlashLatency.part.0+0xa2>
        latency = LL_FLASH_LATENCY_5;
 80020de:	2305      	movs	r3, #5
 80020e0:	e7d1      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
            latency = LL_FLASH_LATENCY_7;
 80020e2:	2307      	movs	r3, #7
 80020e4:	e7cf      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
            latency = LL_FLASH_LATENCY_6;
 80020e6:	2306      	movs	r3, #6
 80020e8:	e7cd      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ) && (latency == LL_FLASH_LATENCY_0))
 80020ea:	4a08      	ldr	r2, [pc, #32]	; (800210c <UTILS_SetFlashLatency.part.0+0xc4>)
 80020ec:	4290      	cmp	r0, r2
 80020ee:	d8f1      	bhi.n	80020d4 <UTILS_SetFlashLatency.part.0+0x8c>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ) && (latency == LL_FLASH_LATENCY_0))
 80020f0:	4a07      	ldr	r2, [pc, #28]	; (8002110 <UTILS_SetFlashLatency.part.0+0xc8>)
 80020f2:	4290      	cmp	r0, r2
 80020f4:	d901      	bls.n	80020fa <UTILS_SetFlashLatency.part.0+0xb2>
        latency = LL_FLASH_LATENCY_3;
 80020f6:	2303      	movs	r3, #3
 80020f8:	e7c5      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ) && (latency == LL_FLASH_LATENCY_0))
 80020fa:	4a06      	ldr	r2, [pc, #24]	; (8002114 <UTILS_SetFlashLatency.part.0+0xcc>)
 80020fc:	4290      	cmp	r0, r2
 80020fe:	d9bc      	bls.n	800207a <UTILS_SetFlashLatency.part.0+0x32>
        latency = LL_FLASH_LATENCY_2;
 8002100:	2302      	movs	r3, #2
 8002102:	e7c0      	b.n	8002086 <UTILS_SetFlashLatency.part.0+0x3e>
 8002104:	40007000 	.word	0x40007000
 8002108:	0c845880 	.word	0x0c845880
 800210c:	07270e00 	.word	0x07270e00
 8002110:	055d4a80 	.word	0x055d4a80
 8002114:	03938700 	.word	0x03938700
 8002118:	01c9c380 	.word	0x01c9c380
 800211c:	40023c00 	.word	0x40023c00
 8002120:	08f0d180 	.word	0x08f0d180

08002124 <UTILS_EnablePLLAndSwitchSystem>:
  assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
  assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
  assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));

  /* Calculate HCLK frequency */
  hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);
 8002124:	680b      	ldr	r3, [r1, #0]
 8002126:	4a24      	ldr	r2, [pc, #144]	; (80021b8 <UTILS_EnablePLLAndSwitchSystem+0x94>)
 8002128:	f3c3 1303 	ubfx	r3, r3, #4, #4
{
 800212c:	b570      	push	{r4, r5, r6, lr}
  hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);
 800212e:	5cd4      	ldrb	r4, [r2, r3]
{
 8002130:	460e      	mov	r6, r1

  /* Increasing the number of wait states because of higher CPU frequency */
  if(SystemCoreClock < hclk_frequency)
 8002132:	4d22      	ldr	r5, [pc, #136]	; (80021bc <UTILS_EnablePLLAndSwitchSystem+0x98>)
  hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);
 8002134:	fa20 f404 	lsr.w	r4, r0, r4
  if(SystemCoreClock < hclk_frequency)
 8002138:	682b      	ldr	r3, [r5, #0]
 800213a:	42a3      	cmp	r3, r4
 800213c:	d327      	bcc.n	800218e <UTILS_EnablePLLAndSwitchSystem+0x6a>
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 800213e:	4b20      	ldr	r3, [pc, #128]	; (80021c0 <UTILS_EnablePLLAndSwitchSystem+0x9c>)
 8002140:	681a      	ldr	r2, [r3, #0]
 8002142:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002146:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8002148:	681a      	ldr	r2, [r3, #0]
  /* Update system clock configuration */
  if(status == SUCCESS)
  {
    /* Enable PLL */
    LL_RCC_PLL_Enable();
    while (LL_RCC_PLL_IsReady() != 1U)
 800214a:	0192      	lsls	r2, r2, #6
 800214c:	d5fc      	bpl.n	8002148 <UTILS_EnablePLLAndSwitchSystem+0x24>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800214e:	689a      	ldr	r2, [r3, #8]
 8002150:	6831      	ldr	r1, [r6, #0]
 8002152:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002156:	430a      	orrs	r2, r1
 8002158:	609a      	str	r2, [r3, #8]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800215a:	689a      	ldr	r2, [r3, #8]
 800215c:	f022 0203 	bic.w	r2, r2, #3
 8002160:	f042 0202 	orr.w	r2, r2, #2
 8002164:	609a      	str	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8002166:	4b16      	ldr	r3, [pc, #88]	; (80021c0 <UTILS_EnablePLLAndSwitchSystem+0x9c>)
 8002168:	689a      	ldr	r2, [r3, #8]
 800216a:	f002 020c 	and.w	r2, r2, #12
    }

    /* Sysclk activation on the main PLL */
    LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
    LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
    while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 800216e:	2a08      	cmp	r2, #8
 8002170:	d1fa      	bne.n	8002168 <UTILS_EnablePLLAndSwitchSystem+0x44>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8002172:	689a      	ldr	r2, [r3, #8]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8002174:	2000      	movs	r0, #0
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8002176:	6871      	ldr	r1, [r6, #4]
 8002178:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 800217c:	430a      	orrs	r2, r1
 800217e:	609a      	str	r2, [r3, #8]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8002180:	689a      	ldr	r2, [r3, #8]
 8002182:	68b1      	ldr	r1, [r6, #8]
 8002184:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8002188:	430a      	orrs	r2, r1
 800218a:	609a      	str	r2, [r3, #8]
 800218c:	e005      	b.n	800219a <UTILS_EnablePLLAndSwitchSystem+0x76>
  if(HCLK_Frequency == 0U)
 800218e:	b174      	cbz	r4, 80021ae <UTILS_EnablePLLAndSwitchSystem+0x8a>
 8002190:	4620      	mov	r0, r4
 8002192:	f7ff ff59 	bl	8002048 <UTILS_SetFlashLatency.part.0>
  if(status == SUCCESS)
 8002196:	2800      	cmp	r0, #0
 8002198:	d0d1      	beq.n	800213e <UTILS_EnablePLLAndSwitchSystem+0x1a>
    LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
    LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(SystemCoreClock > hclk_frequency)
 800219a:	682b      	ldr	r3, [r5, #0]
 800219c:	42a3      	cmp	r3, r4
 800219e:	d903      	bls.n	80021a8 <UTILS_EnablePLLAndSwitchSystem+0x84>
  if(HCLK_Frequency == 0U)
 80021a0:	b13c      	cbz	r4, 80021b2 <UTILS_EnablePLLAndSwitchSystem+0x8e>
 80021a2:	4620      	mov	r0, r4
 80021a4:	f7ff ff50 	bl	8002048 <UTILS_SetFlashLatency.part.0>
    /* Set FLASH latency to lowest latency */
    status = UTILS_SetFlashLatency(hclk_frequency);
  }

  /* Update SystemCoreClock variable */
  if(status == SUCCESS)
 80021a8:	b900      	cbnz	r0, 80021ac <UTILS_EnablePLLAndSwitchSystem+0x88>
  SystemCoreClock = HCLKFrequency;
 80021aa:	602c      	str	r4, [r5, #0]
  {
    LL_SetSystemCoreClock(hclk_frequency);
  }

  return status;
}
 80021ac:	bd70      	pop	{r4, r5, r6, pc}
    status = ERROR;
 80021ae:	2001      	movs	r0, #1
 80021b0:	e7f3      	b.n	800219a <UTILS_EnablePLLAndSwitchSystem+0x76>
 80021b2:	2001      	movs	r0, #1
 80021b4:	e7fa      	b.n	80021ac <UTILS_EnablePLLAndSwitchSystem+0x88>
 80021b6:	bf00      	nop
 80021b8:	08005dd0 	.word	0x08005dd0
 80021bc:	200212d0 	.word	0x200212d0
 80021c0:	40023800 	.word	0x40023800

080021c4 <LL_PLL_ConfigSystemClock_HSE>:
{
 80021c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80021c8:	4604      	mov	r4, r0
 80021ca:	460e      	mov	r6, r1
 80021cc:	4690      	mov	r8, r2
 80021ce:	461d      	mov	r5, r3
  if(UTILS_PLL_IsBusy() == SUCCESS)
 80021d0:	f7ff ff26 	bl	8002020 <UTILS_PLL_IsBusy>
 80021d4:	2800      	cmp	r0, #0
 80021d6:	d135      	bne.n	8002244 <LL_PLL_ConfigSystemClock_HSE+0x80>
  pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));
 80021d8:	f8d8 3000 	ldr.w	r3, [r8]
  pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));
 80021dc:	f8d8 7004 	ldr.w	r7, [r8, #4]
  pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));
 80021e0:	f003 003f 	and.w	r0, r3, #63	; 0x3f
  pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLP >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 80021e4:	f8d8 1008 	ldr.w	r1, [r8, #8]
  pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));
 80021e8:	fbb4 f4f0 	udiv	r4, r4, r0
  pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));
 80021ec:	f3c7 0008 	ubfx	r0, r7, #0, #9
 80021f0:	4344      	muls	r4, r0
  pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLP >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 80021f2:	0c08      	lsrs	r0, r1, #16
 80021f4:	3001      	adds	r0, #1
 80021f6:	0040      	lsls	r0, r0, #1
 80021f8:	fbb4 f0f0 	udiv	r0, r4, r0
  return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 80021fc:	4c13      	ldr	r4, [pc, #76]	; (800224c <LL_PLL_ConfigSystemClock_HSE+0x88>)
 80021fe:	6822      	ldr	r2, [r4, #0]
    if(LL_RCC_HSE_IsReady() != 1U)
 8002200:	0392      	lsls	r2, r2, #14
 8002202:	d40f      	bmi.n	8002224 <LL_PLL_ConfigSystemClock_HSE+0x60>
  SET_BIT(RCC->CR, RCC_CR_HSEBYP);
 8002204:	6822      	ldr	r2, [r4, #0]
      if(HSEBypass == LL_UTILS_HSEBYPASS_ON)
 8002206:	2e01      	cmp	r6, #1
 8002208:	bf0c      	ite	eq
 800220a:	f442 2280 	orreq.w	r2, r2, #262144	; 0x40000
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 800220e:	f422 2280 	bicne.w	r2, r2, #262144	; 0x40000
 8002212:	6022      	str	r2, [r4, #0]
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8002214:	6822      	ldr	r2, [r4, #0]
 8002216:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800221a:	6022      	str	r2, [r4, #0]
  return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 800221c:	4c0b      	ldr	r4, [pc, #44]	; (800224c <LL_PLL_ConfigSystemClock_HSE+0x88>)
 800221e:	6822      	ldr	r2, [r4, #0]
      while (LL_RCC_HSE_IsReady() != 1U)
 8002220:	0392      	lsls	r2, r2, #14
 8002222:	d5fc      	bpl.n	800221e <LL_PLL_ConfigSystemClock_HSE+0x5a>
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLP,
 8002224:	4c09      	ldr	r4, [pc, #36]	; (800224c <LL_PLL_ConfigSystemClock_HSE+0x88>)
 8002226:	4a0a      	ldr	r2, [pc, #40]	; (8002250 <LL_PLL_ConfigSystemClock_HSE+0x8c>)
 8002228:	6866      	ldr	r6, [r4, #4]
 800222a:	4032      	ands	r2, r6
 800222c:	ea42 1287 	orr.w	r2, r2, r7, lsl #6
 8002230:	431a      	orrs	r2, r3
 8002232:	430a      	orrs	r2, r1
    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
 8002234:	4629      	mov	r1, r5
 8002236:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800223a:	6062      	str	r2, [r4, #4]
}
 800223c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
 8002240:	f7ff bf70 	b.w	8002124 <UTILS_EnablePLLAndSwitchSystem>
}
 8002244:	2001      	movs	r0, #1
 8002246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800224a:	bf00      	nop
 800224c:	40023800 	.word	0x40023800
 8002250:	ffbc8000 	.word	0xffbc8000

08002254 <OTM8009A_Init>:
  * @param  hdsi_eval : pointer on DSI configuration structure
  * @param  hdsivideo_handle : pointer on DSI video mode configuration structure
  * @retval Status
  */
uint8_t OTM8009A_Init(uint32_t ColorCoding, uint32_t orientation)
{
 8002254:	b538      	push	{r3, r4, r5, lr}
 8002256:	4604      	mov	r4, r0
 8002258:	460d      	mov	r5, r1
  /* Enable CMD2 to access vendor specific commands                               */
  /* Enter in command 2 mode and set EXTC to enable address shift function (0x00) */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 800225a:	2000      	movs	r0, #0
 800225c:	49cb      	ldr	r1, [pc, #812]	; (800258c <OTM8009A_Init+0x338>)
 800225e:	f7fe fc87 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 3, (uint8_t *)lcdRegData1);
 8002262:	49cb      	ldr	r1, [pc, #812]	; (8002590 <OTM8009A_Init+0x33c>)
 8002264:	2003      	movs	r0, #3
 8002266:	f7fe fc83 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Enter ORISE Command 2 */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData2); /* Shift address to 0x80 */
 800226a:	49ca      	ldr	r1, [pc, #808]	; (8002594 <OTM8009A_Init+0x340>)
 800226c:	2000      	movs	r0, #0
 800226e:	f7fe fc7f 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 2, (uint8_t *)lcdRegData2);
 8002272:	49c9      	ldr	r1, [pc, #804]	; (8002598 <OTM8009A_Init+0x344>)
 8002274:	2002      	movs	r0, #2
 8002276:	f7fe fc7b 	bl	8000b70 <DSI_IO_WriteCmd>

  /////////////////////////////////////////////////////////////////////
  /* SD_PCH_CTRL - 0xC480h - 129th parameter - Default 0x00          */
  /* Set SD_PT                                                       */
  /* -> Source output level during porch and non-display area to GND */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData2);
 800227a:	49c6      	ldr	r1, [pc, #792]	; (8002594 <OTM8009A_Init+0x340>)
 800227c:	2000      	movs	r0, #0
 800227e:	f7fe fc77 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData3);
 8002282:	49c6      	ldr	r1, [pc, #792]	; (800259c <OTM8009A_Init+0x348>)
 8002284:	2000      	movs	r0, #0
 8002286:	f7fe fc73 	bl	8000b70 <DSI_IO_WriteCmd>
  OTM8009A_IO_Delay(10);
 800228a:	200a      	movs	r0, #10
 800228c:	f002 fcd1 	bl	8004c32 <OTM8009A_IO_Delay>
  /* Not documented */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData4);
 8002290:	49c3      	ldr	r1, [pc, #780]	; (80025a0 <OTM8009A_Init+0x34c>)
 8002292:	2000      	movs	r0, #0
 8002294:	f7fe fc6c 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData5);
 8002298:	49c2      	ldr	r1, [pc, #776]	; (80025a4 <OTM8009A_Init+0x350>)
 800229a:	2000      	movs	r0, #0
 800229c:	f7fe fc68 	bl	8000b70 <DSI_IO_WriteCmd>
  OTM8009A_IO_Delay(10);
 80022a0:	200a      	movs	r0, #10
 80022a2:	f002 fcc6 	bl	8004c32 <OTM8009A_IO_Delay>
  /////////////////////////////////////////////////////////////////////

  /* PWR_CTRL4 - 0xC4B0h - 178th parameter - Default 0xA8 */
  /* Set gvdd_en_test                                     */
  /* -> enable GVDD test mode !!!                         */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData6);
 80022a6:	49c0      	ldr	r1, [pc, #768]	; (80025a8 <OTM8009A_Init+0x354>)
 80022a8:	2000      	movs	r0, #0
 80022aa:	f7fe fc61 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData7);
 80022ae:	49bf      	ldr	r1, [pc, #764]	; (80025ac <OTM8009A_Init+0x358>)
 80022b0:	2000      	movs	r0, #0
 80022b2:	f7fe fc5d 	bl	8000b70 <DSI_IO_WriteCmd>
  /* PWR_CTRL2 - 0xC590h - 146th parameter - Default 0x79      */
  /* Set pump 4 vgh voltage                                    */
  /* -> from 15.0v down to 13.0v                               */
  /* Set pump 5 vgh voltage                                    */
  /* -> from -12.0v downto -9.0v                               */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData8);
 80022b6:	49be      	ldr	r1, [pc, #760]	; (80025b0 <OTM8009A_Init+0x35c>)
 80022b8:	2000      	movs	r0, #0
 80022ba:	f7fe fc59 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData9);
 80022be:	49bd      	ldr	r1, [pc, #756]	; (80025b4 <OTM8009A_Init+0x360>)
 80022c0:	2000      	movs	r0, #0
 80022c2:	f7fe fc55 	bl	8000b70 <DSI_IO_WriteCmd>

  /* P_DRV_M - 0xC0B4h - 181th parameter - Default 0x00 */
  /* -> Column inversion                                */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData10);
 80022c6:	49bc      	ldr	r1, [pc, #752]	; (80025b8 <OTM8009A_Init+0x364>)
 80022c8:	2000      	movs	r0, #0
 80022ca:	f7fe fc51 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData11);
 80022ce:	49bb      	ldr	r1, [pc, #748]	; (80025bc <OTM8009A_Init+0x368>)
 80022d0:	2000      	movs	r0, #0
 80022d2:	f7fe fc4d 	bl	8000b70 <DSI_IO_WriteCmd>

  /* VCOMDC - 0xD900h - 1st parameter - Default 0x39h */
  /* VCOM Voltage settings                            */
  /* -> from -1.0000v downto -1.2625v                 */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 80022d6:	49ad      	ldr	r1, [pc, #692]	; (800258c <OTM8009A_Init+0x338>)
 80022d8:	2000      	movs	r0, #0
 80022da:	f7fe fc49 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData12);
 80022de:	49b8      	ldr	r1, [pc, #736]	; (80025c0 <OTM8009A_Init+0x36c>)
 80022e0:	2000      	movs	r0, #0
 80022e2:	f7fe fc45 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Oscillator adjustment for Idle/Normal mode (LPDT only) set to 65Hz (default is 60Hz) */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData13);
 80022e6:	49b7      	ldr	r1, [pc, #732]	; (80025c4 <OTM8009A_Init+0x370>)
 80022e8:	2000      	movs	r0, #0
 80022ea:	f7fe fc41 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData14);
 80022ee:	49b6      	ldr	r1, [pc, #728]	; (80025c8 <OTM8009A_Init+0x374>)
 80022f0:	2000      	movs	r0, #0
 80022f2:	f7fe fc3d 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Video mode internal */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData15);
 80022f6:	49b5      	ldr	r1, [pc, #724]	; (80025cc <OTM8009A_Init+0x378>)
 80022f8:	2000      	movs	r0, #0
 80022fa:	f7fe fc39 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData16);
 80022fe:	49b4      	ldr	r1, [pc, #720]	; (80025d0 <OTM8009A_Init+0x37c>)
 8002300:	2000      	movs	r0, #0
 8002302:	f7fe fc35 	bl	8000b70 <DSI_IO_WriteCmd>

  /* PWR_CTRL2 - 0xC590h - 147h parameter - Default 0x00 */
  /* Set pump 4&5 x6                                     */
  /* -> ONLY VALID when PUMP4_EN_ASDM_HV = "0"           */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData17);
 8002306:	49b3      	ldr	r1, [pc, #716]	; (80025d4 <OTM8009A_Init+0x380>)
 8002308:	2000      	movs	r0, #0
 800230a:	f7fe fc31 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData18);
 800230e:	49b2      	ldr	r1, [pc, #712]	; (80025d8 <OTM8009A_Init+0x384>)
 8002310:	2000      	movs	r0, #0
 8002312:	f7fe fc2d 	bl	8000b70 <DSI_IO_WriteCmd>

  /* PWR_CTRL2 - 0xC590h - 150th parameter - Default 0x33h */
  /* Change pump4 clock ratio                              */
  /* -> from 1 line to 1/2 line                            */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData19);
 8002316:	49b1      	ldr	r1, [pc, #708]	; (80025dc <OTM8009A_Init+0x388>)
 8002318:	2000      	movs	r0, #0
 800231a:	f7fe fc29 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData9);
 800231e:	49a5      	ldr	r1, [pc, #660]	; (80025b4 <OTM8009A_Init+0x360>)
 8002320:	2000      	movs	r0, #0
 8002322:	f7fe fc25 	bl	8000b70 <DSI_IO_WriteCmd>

  /* GVDD/NGVDD settings */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 8002326:	4999      	ldr	r1, [pc, #612]	; (800258c <OTM8009A_Init+0x338>)
 8002328:	2000      	movs	r0, #0
 800232a:	f7fe fc21 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 2, (uint8_t *)lcdRegData5);
 800232e:	49ac      	ldr	r1, [pc, #688]	; (80025e0 <OTM8009A_Init+0x38c>)
 8002330:	2002      	movs	r0, #2
 8002332:	f7fe fc1d 	bl	8000b70 <DSI_IO_WriteCmd>

  /* PWR_CTRL2 - 0xC590h - 149th parameter - Default 0x33h */
  /* Rewrite the default value !                           */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData20);
 8002336:	49ab      	ldr	r1, [pc, #684]	; (80025e4 <OTM8009A_Init+0x390>)
 8002338:	2000      	movs	r0, #0
 800233a:	f7fe fc19 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData21);
 800233e:	49aa      	ldr	r1, [pc, #680]	; (80025e8 <OTM8009A_Init+0x394>)
 8002340:	2000      	movs	r0, #0
 8002342:	f7fe fc15 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Panel display timing Setting 3 */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData22);
 8002346:	49a9      	ldr	r1, [pc, #676]	; (80025ec <OTM8009A_Init+0x398>)
 8002348:	2000      	movs	r0, #0
 800234a:	f7fe fc11 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData23);
 800234e:	49a8      	ldr	r1, [pc, #672]	; (80025f0 <OTM8009A_Init+0x39c>)
 8002350:	2000      	movs	r0, #0
 8002352:	f7fe fc0d 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Power control 1 */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData24);
 8002356:	49a7      	ldr	r1, [pc, #668]	; (80025f4 <OTM8009A_Init+0x3a0>)
 8002358:	2000      	movs	r0, #0
 800235a:	f7fe fc09 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData25);
 800235e:	49a6      	ldr	r1, [pc, #664]	; (80025f8 <OTM8009A_Init+0x3a4>)
 8002360:	2000      	movs	r0, #0
 8002362:	f7fe fc05 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Source driver precharge */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData13);
 8002366:	4997      	ldr	r1, [pc, #604]	; (80025c4 <OTM8009A_Init+0x370>)
 8002368:	2000      	movs	r0, #0
 800236a:	f7fe fc01 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData26);
 800236e:	49a3      	ldr	r1, [pc, #652]	; (80025fc <OTM8009A_Init+0x3a8>)
 8002370:	2000      	movs	r0, #0
 8002372:	f7fe fbfd 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData15);
 8002376:	4995      	ldr	r1, [pc, #596]	; (80025cc <OTM8009A_Init+0x378>)
 8002378:	2000      	movs	r0, #0
 800237a:	f7fe fbf9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData27);
 800237e:	49a0      	ldr	r1, [pc, #640]	; (8002600 <OTM8009A_Init+0x3ac>)
 8002380:	2000      	movs	r0, #0
 8002382:	f7fe fbf5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData28);
 8002386:	499f      	ldr	r1, [pc, #636]	; (8002604 <OTM8009A_Init+0x3b0>)
 8002388:	2000      	movs	r0, #0
 800238a:	f7fe fbf1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 2, (uint8_t *)lcdRegData6);
 800238e:	499e      	ldr	r1, [pc, #632]	; (8002608 <OTM8009A_Init+0x3b4>)
 8002390:	2002      	movs	r0, #2
 8002392:	f7fe fbed 	bl	8000b70 <DSI_IO_WriteCmd>

  /* GOAVST */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData2);
 8002396:	497f      	ldr	r1, [pc, #508]	; (8002594 <OTM8009A_Init+0x340>)
 8002398:	2000      	movs	r0, #0
 800239a:	f7fe fbe9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 6, (uint8_t *)lcdRegData7);
 800239e:	499b      	ldr	r1, [pc, #620]	; (800260c <OTM8009A_Init+0x3b8>)
 80023a0:	2006      	movs	r0, #6
 80023a2:	f7fe fbe5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData29);
 80023a6:	499a      	ldr	r1, [pc, #616]	; (8002610 <OTM8009A_Init+0x3bc>)
 80023a8:	2000      	movs	r0, #0
 80023aa:	f7fe fbe1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 14, (uint8_t *)lcdRegData8);
 80023ae:	4999      	ldr	r1, [pc, #612]	; (8002614 <OTM8009A_Init+0x3c0>)
 80023b0:	200e      	movs	r0, #14
 80023b2:	f7fe fbdd 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData30);
 80023b6:	4998      	ldr	r1, [pc, #608]	; (8002618 <OTM8009A_Init+0x3c4>)
 80023b8:	2000      	movs	r0, #0
 80023ba:	f7fe fbd9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 14, (uint8_t *)lcdRegData9);
 80023be:	4997      	ldr	r1, [pc, #604]	; (800261c <OTM8009A_Init+0x3c8>)
 80023c0:	200e      	movs	r0, #14
 80023c2:	f7fe fbd5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData31);
 80023c6:	4996      	ldr	r1, [pc, #600]	; (8002620 <OTM8009A_Init+0x3cc>)
 80023c8:	2000      	movs	r0, #0
 80023ca:	f7fe fbd1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData10);
 80023ce:	4995      	ldr	r1, [pc, #596]	; (8002624 <OTM8009A_Init+0x3d0>)
 80023d0:	200a      	movs	r0, #10
 80023d2:	f7fe fbcd 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData32);
 80023d6:	4994      	ldr	r1, [pc, #592]	; (8002628 <OTM8009A_Init+0x3d4>)
 80023d8:	2000      	movs	r0, #0
 80023da:	f7fe fbc9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData46);
 80023de:	4993      	ldr	r1, [pc, #588]	; (800262c <OTM8009A_Init+0x3d8>)
 80023e0:	2000      	movs	r0, #0
 80023e2:	f7fe fbc5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData2);
 80023e6:	496b      	ldr	r1, [pc, #428]	; (8002594 <OTM8009A_Init+0x340>)
 80023e8:	2000      	movs	r0, #0
 80023ea:	f7fe fbc1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData11);
 80023ee:	4990      	ldr	r1, [pc, #576]	; (8002630 <OTM8009A_Init+0x3dc>)
 80023f0:	200a      	movs	r0, #10
 80023f2:	f7fe fbbd 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData33);
 80023f6:	498f      	ldr	r1, [pc, #572]	; (8002634 <OTM8009A_Init+0x3e0>)
 80023f8:	2000      	movs	r0, #0
 80023fa:	f7fe fbb9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData12);
 80023fe:	498e      	ldr	r1, [pc, #568]	; (8002638 <OTM8009A_Init+0x3e4>)
 8002400:	200f      	movs	r0, #15
 8002402:	f7fe fbb5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData29);
 8002406:	4982      	ldr	r1, [pc, #520]	; (8002610 <OTM8009A_Init+0x3bc>)
 8002408:	2000      	movs	r0, #0
 800240a:	f7fe fbb1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData13);
 800240e:	498b      	ldr	r1, [pc, #556]	; (800263c <OTM8009A_Init+0x3e8>)
 8002410:	200f      	movs	r0, #15
 8002412:	f7fe fbad 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData30);
 8002416:	4980      	ldr	r1, [pc, #512]	; (8002618 <OTM8009A_Init+0x3c4>)
 8002418:	2000      	movs	r0, #0
 800241a:	f7fe fba9 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData14);
 800241e:	4988      	ldr	r1, [pc, #544]	; (8002640 <OTM8009A_Init+0x3ec>)
 8002420:	200a      	movs	r0, #10
 8002422:	f7fe fba5 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData31);
 8002426:	497e      	ldr	r1, [pc, #504]	; (8002620 <OTM8009A_Init+0x3cc>)
 8002428:	2000      	movs	r0, #0
 800242a:	f7fe fba1 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData15);
 800242e:	4985      	ldr	r1, [pc, #532]	; (8002644 <OTM8009A_Init+0x3f0>)
 8002430:	200f      	movs	r0, #15
 8002432:	f7fe fb9d 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData32);
 8002436:	497c      	ldr	r1, [pc, #496]	; (8002628 <OTM8009A_Init+0x3d4>)
 8002438:	2000      	movs	r0, #0
 800243a:	f7fe fb99 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData16);
 800243e:	4982      	ldr	r1, [pc, #520]	; (8002648 <OTM8009A_Init+0x3f4>)
 8002440:	200f      	movs	r0, #15
 8002442:	f7fe fb95 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData34);
 8002446:	4981      	ldr	r1, [pc, #516]	; (800264c <OTM8009A_Init+0x3f8>)
 8002448:	2000      	movs	r0, #0
 800244a:	f7fe fb91 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData17);
 800244e:	4980      	ldr	r1, [pc, #512]	; (8002650 <OTM8009A_Init+0x3fc>)
 8002450:	200a      	movs	r0, #10
 8002452:	f7fe fb8d 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData35);
 8002456:	497f      	ldr	r1, [pc, #508]	; (8002654 <OTM8009A_Init+0x400>)
 8002458:	2000      	movs	r0, #0
 800245a:	f7fe fb89 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData18);
 800245e:	497e      	ldr	r1, [pc, #504]	; (8002658 <OTM8009A_Init+0x404>)
 8002460:	200a      	movs	r0, #10
 8002462:	f7fe fb85 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData2);
 8002466:	494b      	ldr	r1, [pc, #300]	; (8002594 <OTM8009A_Init+0x340>)
 8002468:	2000      	movs	r0, #0
 800246a:	f7fe fb81 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData19);
 800246e:	497b      	ldr	r1, [pc, #492]	; (800265c <OTM8009A_Init+0x408>)
 8002470:	200a      	movs	r0, #10
 8002472:	f7fe fb7d 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData33);
 8002476:	496f      	ldr	r1, [pc, #444]	; (8002634 <OTM8009A_Init+0x3e0>)
 8002478:	2000      	movs	r0, #0
 800247a:	f7fe fb79 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData20);
 800247e:	4978      	ldr	r1, [pc, #480]	; (8002660 <OTM8009A_Init+0x40c>)
 8002480:	200f      	movs	r0, #15
 8002482:	f7fe fb75 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData29);
 8002486:	4962      	ldr	r1, [pc, #392]	; (8002610 <OTM8009A_Init+0x3bc>)
 8002488:	2000      	movs	r0, #0
 800248a:	f7fe fb71 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData21);
 800248e:	4975      	ldr	r1, [pc, #468]	; (8002664 <OTM8009A_Init+0x410>)
 8002490:	200f      	movs	r0, #15
 8002492:	f7fe fb6d 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData30);
 8002496:	4960      	ldr	r1, [pc, #384]	; (8002618 <OTM8009A_Init+0x3c4>)
 8002498:	2000      	movs	r0, #0
 800249a:	f7fe fb69 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 10, (uint8_t *)lcdRegData22);
 800249e:	4972      	ldr	r1, [pc, #456]	; (8002668 <OTM8009A_Init+0x414>)
 80024a0:	200a      	movs	r0, #10
 80024a2:	f7fe fb65 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData31);
 80024a6:	495e      	ldr	r1, [pc, #376]	; (8002620 <OTM8009A_Init+0x3cc>)
 80024a8:	2000      	movs	r0, #0
 80024aa:	f7fe fb61 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData23);
 80024ae:	496f      	ldr	r1, [pc, #444]	; (800266c <OTM8009A_Init+0x418>)
 80024b0:	200f      	movs	r0, #15
 80024b2:	f7fe fb5d 	bl	8000b70 <DSI_IO_WriteCmd>

  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData32);
 80024b6:	495c      	ldr	r1, [pc, #368]	; (8002628 <OTM8009A_Init+0x3d4>)
 80024b8:	2000      	movs	r0, #0
 80024ba:	f7fe fb59 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 15, (uint8_t *)lcdRegData24);
 80024be:	496c      	ldr	r1, [pc, #432]	; (8002670 <OTM8009A_Init+0x41c>)
 80024c0:	200f      	movs	r0, #15
 80024c2:	f7fe fb55 	bl	8000b70 <DSI_IO_WriteCmd>

  /////////////////////////////////////////////////////////////////////////////
  /* PWR_CTRL1 - 0xc580h - 130th parameter - default 0x00 */
  /* Pump 1 min and max DM                                */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData13);
 80024c6:	493f      	ldr	r1, [pc, #252]	; (80025c4 <OTM8009A_Init+0x370>)
 80024c8:	2000      	movs	r0, #0
 80024ca:	f7fe fb51 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData47);
 80024ce:	4969      	ldr	r1, [pc, #420]	; (8002674 <OTM8009A_Init+0x420>)
 80024d0:	2000      	movs	r0, #0
 80024d2:	f7fe fb4d 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData48);
 80024d6:	4968      	ldr	r1, [pc, #416]	; (8002678 <OTM8009A_Init+0x424>)
 80024d8:	2000      	movs	r0, #0
 80024da:	f7fe fb49 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData49);
 80024de:	4967      	ldr	r1, [pc, #412]	; (800267c <OTM8009A_Init+0x428>)
 80024e0:	2000      	movs	r0, #0
 80024e2:	f7fe fb45 	bl	8000b70 <DSI_IO_WriteCmd>
  /////////////////////////////////////////////////////////////////////////////

  /* CABC LEDPWM frequency adjusted to 19,5kHz */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData50);
 80024e6:	4966      	ldr	r1, [pc, #408]	; (8002680 <OTM8009A_Init+0x42c>)
 80024e8:	2000      	movs	r0, #0
 80024ea:	f7fe fb41 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData51);
 80024ee:	4965      	ldr	r1, [pc, #404]	; (8002684 <OTM8009A_Init+0x430>)
 80024f0:	2000      	movs	r0, #0
 80024f2:	f7fe fb3d 	bl	8000b70 <DSI_IO_WriteCmd>
  
  /* Exit CMD2 mode */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 80024f6:	4925      	ldr	r1, [pc, #148]	; (800258c <OTM8009A_Init+0x338>)
 80024f8:	2000      	movs	r0, #0
 80024fa:	f7fe fb39 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 3, (uint8_t *)lcdRegData25);
 80024fe:	4962      	ldr	r1, [pc, #392]	; (8002688 <OTM8009A_Init+0x434>)
 8002500:	2003      	movs	r0, #3
 8002502:	f7fe fb35 	bl	8000b70 <DSI_IO_WriteCmd>
  /*************************************************************************** */
  /* Standard DCS Initialization TO KEEP CAN BE DONE IN HSDT                   */
  /*************************************************************************** */

  /* NOP - goes back to DCS std command ? */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 8002506:	4921      	ldr	r1, [pc, #132]	; (800258c <OTM8009A_Init+0x338>)
 8002508:	2000      	movs	r0, #0
 800250a:	f7fe fb31 	bl	8000b70 <DSI_IO_WriteCmd>
          
  /* Gamma correction 2.2+ table (HSDT possible) */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 800250e:	491f      	ldr	r1, [pc, #124]	; (800258c <OTM8009A_Init+0x338>)
 8002510:	2000      	movs	r0, #0
 8002512:	f7fe fb2d 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 16, (uint8_t *)lcdRegData3);
 8002516:	495d      	ldr	r1, [pc, #372]	; (800268c <OTM8009A_Init+0x438>)
 8002518:	2010      	movs	r0, #16
 800251a:	f7fe fb29 	bl	8000b70 <DSI_IO_WriteCmd>
  
  /* Gamma correction 2.2- table (HSDT possible) */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 800251e:	491b      	ldr	r1, [pc, #108]	; (800258c <OTM8009A_Init+0x338>)
 8002520:	2000      	movs	r0, #0
 8002522:	f7fe fb25 	bl	8000b70 <DSI_IO_WriteCmd>
  DSI_IO_WriteCmd( 16, (uint8_t *)lcdRegData4);
 8002526:	495a      	ldr	r1, [pc, #360]	; (8002690 <OTM8009A_Init+0x43c>)
 8002528:	2010      	movs	r0, #16
 800252a:	f7fe fb21 	bl	8000b70 <DSI_IO_WriteCmd>
          
  /* Send Sleep Out command to display : no parameter */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData36);
 800252e:	2000      	movs	r0, #0
 8002530:	4958      	ldr	r1, [pc, #352]	; (8002694 <OTM8009A_Init+0x440>)
 8002532:	f7fe fb1d 	bl	8000b70 <DSI_IO_WriteCmd>
  
  /* Wait for sleep out exit */
  OTM8009A_IO_Delay(120);
 8002536:	2078      	movs	r0, #120	; 0x78
 8002538:	f002 fb7b 	bl	8004c32 <OTM8009A_IO_Delay>

  switch(ColorCoding)
 800253c:	2c00      	cmp	r4, #0
 800253e:	f000 80c9 	beq.w	80026d4 <OTM8009A_Init+0x480>
 8002542:	2c02      	cmp	r4, #2
 8002544:	d103      	bne.n	800254e <OTM8009A_Init+0x2fa>
  {
  case OTM8009A_FORMAT_RBG565 :
    /* Set Pixel color format to RGB565 */
    DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData37);
 8002546:	4954      	ldr	r1, [pc, #336]	; (8002698 <OTM8009A_Init+0x444>)
 8002548:	2000      	movs	r0, #0
    break;
  case OTM8009A_FORMAT_RGB888 :
    /* Set Pixel color format to RGB888 */
    DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData38);
 800254a:	f7fe fb11 	bl	8000b70 <DSI_IO_WriteCmd>
    break;
  }

  /* Send command to configure display in landscape orientation mode. By default
      the orientation mode is portrait  */
  if(orientation == OTM8009A_ORIENTATION_LANDSCAPE)
 800254e:	2d01      	cmp	r5, #1
 8002550:	d10b      	bne.n	800256a <OTM8009A_Init+0x316>
  {
    DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData39);
 8002552:	4952      	ldr	r1, [pc, #328]	; (800269c <OTM8009A_Init+0x448>)
 8002554:	2000      	movs	r0, #0
 8002556:	f7fe fb0b 	bl	8000b70 <DSI_IO_WriteCmd>
    DSI_IO_WriteCmd( 4, (uint8_t *)lcdRegData27);
 800255a:	4951      	ldr	r1, [pc, #324]	; (80026a0 <OTM8009A_Init+0x44c>)
 800255c:	2004      	movs	r0, #4
 800255e:	f7fe fb07 	bl	8000b70 <DSI_IO_WriteCmd>
    DSI_IO_WriteCmd( 4, (uint8_t *)lcdRegData28);
 8002562:	4950      	ldr	r1, [pc, #320]	; (80026a4 <OTM8009A_Init+0x450>)
 8002564:	2004      	movs	r0, #4
 8002566:	f7fe fb03 	bl	8000b70 <DSI_IO_WriteCmd>
  }

  /** CABC : Content Adaptive Backlight Control section start >> */
  /* Note : defaut is 0 (lowest Brightness), 0xFF is highest Brightness, try 0x7F : intermediate value */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData40);
 800256a:	494f      	ldr	r1, [pc, #316]	; (80026a8 <OTM8009A_Init+0x454>)
 800256c:	2000      	movs	r0, #0
 800256e:	f7fe faff 	bl	8000b70 <DSI_IO_WriteCmd>

  /* defaut is 0, try 0x2C - Brightness Control Block, Display Dimming & BackLight on */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData41);
 8002572:	494e      	ldr	r1, [pc, #312]	; (80026ac <OTM8009A_Init+0x458>)
 8002574:	2000      	movs	r0, #0
 8002576:	f7fe fafb 	bl	8000b70 <DSI_IO_WriteCmd>

  /* defaut is 0, try 0x02 - image Content based Adaptive Brightness [Still Picture] */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData42);
 800257a:	494d      	ldr	r1, [pc, #308]	; (80026b0 <OTM8009A_Init+0x45c>)
 800257c:	2000      	movs	r0, #0
 800257e:	f7fe faf7 	bl	8000b70 <DSI_IO_WriteCmd>

  /* defaut is 0 (lowest Brightness), 0xFF is highest Brightness */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData43);
 8002582:	494c      	ldr	r1, [pc, #304]	; (80026b4 <OTM8009A_Init+0x460>)
 8002584:	2000      	movs	r0, #0
 8002586:	f7fe faf3 	bl	8000b70 <DSI_IO_WriteCmd>
 800258a:	e095      	b.n	80026b8 <OTM8009A_Init+0x464>
 800258c:	08005de8 	.word	0x08005de8
 8002590:	08005e4e 	.word	0x08005e4e
 8002594:	08005dfe 	.word	0x08005dfe
 8002598:	08005ed4 	.word	0x08005ed4
 800259c:	08005e14 	.word	0x08005e14
 80025a0:	08005e2a 	.word	0x08005e2a
 80025a4:	08005e40 	.word	0x08005e40
 80025a8:	08005e46 	.word	0x08005e46
 80025ac:	08005e48 	.word	0x08005e48
 80025b0:	08005e4a 	.word	0x08005e4a
 80025b4:	08005e4c 	.word	0x08005e4c
 80025b8:	08005dea 	.word	0x08005dea
 80025bc:	08005dec 	.word	0x08005dec
 80025c0:	08005dee 	.word	0x08005dee
 80025c4:	08005df0 	.word	0x08005df0
 80025c8:	08005df2 	.word	0x08005df2
 80025cc:	08005df4 	.word	0x08005df4
 80025d0:	08005df6 	.word	0x08005df6
 80025d4:	08005df8 	.word	0x08005df8
 80025d8:	08005dfa 	.word	0x08005dfa
 80025dc:	08005dfc 	.word	0x08005dfc
 80025e0:	08005f52 	.word	0x08005f52
 80025e4:	08005e00 	.word	0x08005e00
 80025e8:	08005e02 	.word	0x08005e02
 80025ec:	08005e04 	.word	0x08005e04
 80025f0:	08005e06 	.word	0x08005e06
 80025f4:	08005e08 	.word	0x08005e08
 80025f8:	08005e0a 	.word	0x08005e0a
 80025fc:	08005e0c 	.word	0x08005e0c
 8002600:	08005e0e 	.word	0x08005e0e
 8002604:	08005e10 	.word	0x08005e10
 8002608:	08005f55 	.word	0x08005f55
 800260c:	08005f58 	.word	0x08005f58
 8002610:	08005e12 	.word	0x08005e12
 8002614:	08005f5f 	.word	0x08005f5f
 8002618:	08005e16 	.word	0x08005e16
 800261c:	08005f6e 	.word	0x08005f6e
 8002620:	08005e18 	.word	0x08005e18
 8002624:	08005e52 	.word	0x08005e52
 8002628:	08005e1a 	.word	0x08005e1a
 800262c:	08005e38 	.word	0x08005e38
 8002630:	08005e5d 	.word	0x08005e5d
 8002634:	08005e1c 	.word	0x08005e1c
 8002638:	08005e68 	.word	0x08005e68
 800263c:	08005e78 	.word	0x08005e78
 8002640:	08005e88 	.word	0x08005e88
 8002644:	08005e93 	.word	0x08005e93
 8002648:	08005ea3 	.word	0x08005ea3
 800264c:	08005e1e 	.word	0x08005e1e
 8002650:	08005eb3 	.word	0x08005eb3
 8002654:	08005e20 	.word	0x08005e20
 8002658:	08005ebe 	.word	0x08005ebe
 800265c:	08005ec9 	.word	0x08005ec9
 8002660:	08005ed7 	.word	0x08005ed7
 8002664:	08005ee7 	.word	0x08005ee7
 8002668:	08005ef7 	.word	0x08005ef7
 800266c:	08005f02 	.word	0x08005f02
 8002670:	08005f12 	.word	0x08005f12
 8002674:	08005e3a 	.word	0x08005e3a
 8002678:	08005e3c 	.word	0x08005e3c
 800267c:	08005e3e 	.word	0x08005e3e
 8002680:	08005e42 	.word	0x08005e42
 8002684:	08005e44 	.word	0x08005e44
 8002688:	08005f22 	.word	0x08005f22
 800268c:	08005f30 	.word	0x08005f30
 8002690:	08005f41 	.word	0x08005f41
 8002694:	08005e22 	.word	0x08005e22
 8002698:	08005e24 	.word	0x08005e24
 800269c:	08005e28 	.word	0x08005e28
 80026a0:	08005f26 	.word	0x08005f26
 80026a4:	08005f2b 	.word	0x08005f2b
 80026a8:	08005e2c 	.word	0x08005e2c
 80026ac:	08005e2e 	.word	0x08005e2e
 80026b0:	08005e30 	.word	0x08005e30
 80026b4:	08005e32 	.word	0x08005e32

  /** CABC : Content Adaptive Backlight Control section end << */

  /* Send Command Display On */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData44);
 80026b8:	4908      	ldr	r1, [pc, #32]	; (80026dc <OTM8009A_Init+0x488>)
 80026ba:	2000      	movs	r0, #0
 80026bc:	f7fe fa58 	bl	8000b70 <DSI_IO_WriteCmd>

  /* NOP command */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData1);
 80026c0:	4907      	ldr	r1, [pc, #28]	; (80026e0 <OTM8009A_Init+0x48c>)
 80026c2:	2000      	movs	r0, #0
 80026c4:	f7fe fa54 	bl	8000b70 <DSI_IO_WriteCmd>

  /* Send Command GRAM memory write (no parameters) : this initiates frame write via other DSI commands sent by */
  /* DSI host from LTDC incoming pixels in video mode */
  DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData45);
 80026c8:	4906      	ldr	r1, [pc, #24]	; (80026e4 <OTM8009A_Init+0x490>)
 80026ca:	2000      	movs	r0, #0
 80026cc:	f7fe fa50 	bl	8000b70 <DSI_IO_WriteCmd>

  return 0;
}
 80026d0:	2000      	movs	r0, #0
 80026d2:	bd38      	pop	{r3, r4, r5, pc}
    DSI_IO_WriteCmd(0, (uint8_t *)ShortRegData38);
 80026d4:	4904      	ldr	r1, [pc, #16]	; (80026e8 <OTM8009A_Init+0x494>)
 80026d6:	4620      	mov	r0, r4
 80026d8:	e737      	b.n	800254a <OTM8009A_Init+0x2f6>
 80026da:	bf00      	nop
 80026dc:	08005e34 	.word	0x08005e34
 80026e0:	08005de8 	.word	0x08005de8
 80026e4:	08005e36 	.word	0x08005e36
 80026e8:	08005e26 	.word	0x08005e26

080026ec <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 80026ec:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  __IO uint32_t tmpmrd = 0;
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 80026f0:	4c21      	ldr	r4, [pc, #132]	; (8002778 <BSP_SDRAM_Initialization_sequence+0x8c>)
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 80026f2:	2601      	movs	r6, #1
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80026f4:	4d21      	ldr	r5, [pc, #132]	; (800277c <BSP_SDRAM_Initialization_sequence+0x90>)
  __IO uint32_t tmpmrd = 0;
 80026f6:	f04f 0800 	mov.w	r8, #0
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 80026fa:	2710      	movs	r7, #16
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80026fc:	4621      	mov	r1, r4
{
 80026fe:	4681      	mov	r9, r0
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002700:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002704:	4628      	mov	r0, r5
  __IO uint32_t tmpmrd = 0;
 8002706:	f8cd 8004 	str.w	r8, [sp, #4]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800270a:	e9c4 6700 	strd	r6, r7, [r4]
  Command.ModeRegisterDefinition = 0;
 800270e:	e9c4 6802 	strd	r6, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002712:	f002 fa08 	bl	8004b26 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
 8002716:	4630      	mov	r0, r6
 8002718:	f001 fe43 	bl	80043a2 <HAL_Delay>
    
  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 800271c:	2302      	movs	r3, #2
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 800271e:	4621      	mov	r1, r4
 8002720:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002724:	4628      	mov	r0, r5
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8002726:	e9c4 3700 	strd	r3, r7, [r4]
  Command.ModeRegisterDefinition = 0;
 800272a:	e9c4 6802 	strd	r6, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 800272e:	f002 f9fa 	bl	8004b26 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8002732:	2303      	movs	r3, #3
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 8;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002734:	4621      	mov	r1, r4
 8002736:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800273a:	4628      	mov	r0, r5
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800273c:	e9c4 3700 	strd	r3, r7, [r4]
  Command.AutoRefreshNumber      = 8;
 8002740:	2308      	movs	r3, #8
  Command.ModeRegisterDefinition = 0;
 8002742:	e9c4 3802 	strd	r3, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002746:	f002 f9ee 	bl	8004b26 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 800274a:	f44f 730c 	mov.w	r3, #560	; 0x230
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = tmpmrd;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800274e:	4621      	mov	r1, r4
 8002750:	f64f 72ff 	movw	r2, #65535	; 0xffff
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 8002754:	9301      	str	r3, [sp, #4]
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 8002756:	2304      	movs	r3, #4
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002758:	4628      	mov	r0, r5
  Command.AutoRefreshNumber      = 1;
 800275a:	60a6      	str	r6, [r4, #8]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800275c:	e9c4 3700 	strd	r3, r7, [r4]
  Command.ModeRegisterDefinition = tmpmrd;
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	60e3      	str	r3, [r4, #12]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8002764:	f002 f9df 	bl	8004b26 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 8002768:	4649      	mov	r1, r9
 800276a:	4628      	mov	r0, r5
}
 800276c:	b003      	add	sp, #12
 800276e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 8002772:	f002 b9ef 	b.w	8004b54 <HAL_SDRAM_ProgramRefreshRate>
 8002776:	bf00      	nop
 8002778:	20020324 	.word	0x20020324
 800277c:	200203b0 	.word	0x200203b0

08002780 <BSP_SDRAM_MspInit>:
{  
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 8002780:	4b55      	ldr	r3, [pc, #340]	; (80028d8 <BSP_SDRAM_MspInit+0x158>)
 8002782:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002784:	f042 0201 	orr.w	r2, r2, #1
{  
 8002788:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_RCC_FMC_CLK_ENABLE();
 800278a:	639a      	str	r2, [r3, #56]	; 0x38
{  
 800278c:	b08f      	sub	sp, #60	; 0x3c
  __HAL_RCC_FMC_CLK_ENABLE();
 800278e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 8002790:	2703      	movs	r7, #3
{  
 8002792:	4606      	mov	r6, r0
  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8| GPIO_PIN_9 | GPIO_PIN_10 |\
                              GPIO_PIN_14 | GPIO_PIN_15;
 
   
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8002794:	a909      	add	r1, sp, #36	; 0x24
  __HAL_RCC_FMC_CLK_ENABLE();
 8002796:	f002 0201 	and.w	r2, r2, #1
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800279a:	4850      	ldr	r0, [pc, #320]	; (80028dc <BSP_SDRAM_MspInit+0x15c>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 |\
                              GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_9 | GPIO_PIN_10;
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);  
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 800279c:	4c50      	ldr	r4, [pc, #320]	; (80028e0 <BSP_SDRAM_MspInit+0x160>)
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 800279e:	2500      	movs	r5, #0
  __HAL_RCC_FMC_CLK_ENABLE();
 80027a0:	9201      	str	r2, [sp, #4]
 80027a2:	9a01      	ldr	r2, [sp, #4]
  __DMAx_CLK_ENABLE();
 80027a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027a6:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80027aa:	631a      	str	r2, [r3, #48]	; 0x30
 80027ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027ae:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 80027b2:	9202      	str	r2, [sp, #8]
 80027b4:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80027b6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027b8:	f042 0208 	orr.w	r2, r2, #8
 80027bc:	631a      	str	r2, [r3, #48]	; 0x30
 80027be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027c0:	f002 0208 	and.w	r2, r2, #8
 80027c4:	9203      	str	r2, [sp, #12]
 80027c6:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80027c8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027ca:	f042 0210 	orr.w	r2, r2, #16
 80027ce:	631a      	str	r2, [r3, #48]	; 0x30
 80027d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027d2:	f002 0210 	and.w	r2, r2, #16
 80027d6:	9204      	str	r2, [sp, #16]
 80027d8:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80027da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027dc:	f042 0220 	orr.w	r2, r2, #32
 80027e0:	631a      	str	r2, [r3, #48]	; 0x30
 80027e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027e4:	f002 0220 	and.w	r2, r2, #32
 80027e8:	9205      	str	r2, [sp, #20]
 80027ea:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80027ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027ee:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80027f2:	631a      	str	r2, [r3, #48]	; 0x30
 80027f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80027f6:	f002 0240 	and.w	r2, r2, #64	; 0x40
 80027fa:	9206      	str	r2, [sp, #24]
 80027fc:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80027fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002800:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002804:	631a      	str	r2, [r3, #48]	; 0x30
 8002806:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002808:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800280c:	9207      	str	r2, [sp, #28]
 800280e:	9a07      	ldr	r2, [sp, #28]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 8002810:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002812:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002816:	631a      	str	r2, [r3, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8002818:	2202      	movs	r2, #2
  __HAL_RCC_GPIOI_CLK_ENABLE();
 800281a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800281c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002820:	9308      	str	r3, [sp, #32]
 8002822:	9b08      	ldr	r3, [sp, #32]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8002824:	2301      	movs	r3, #1
 8002826:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 800282a:	230c      	movs	r3, #12
 800282c:	e9cd 730c 	strd	r7, r3, [sp, #48]	; 0x30
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8| GPIO_PIN_9 | GPIO_PIN_10 |\
 8002830:	f24c 7303 	movw	r3, #50947	; 0xc703
 8002834:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8002836:	f7fe ffb7 	bl	80017a8 <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 800283a:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800283e:	a909      	add	r1, sp, #36	; 0x24
 8002840:	4828      	ldr	r0, [pc, #160]	; (80028e4 <BSP_SDRAM_MspInit+0x164>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 8002842:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8002844:	f7fe ffb0 	bl	80017a8 <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 8002848:	f64f 033f 	movw	r3, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 800284c:	a909      	add	r1, sp, #36	; 0x24
 800284e:	4826      	ldr	r0, [pc, #152]	; (80028e8 <BSP_SDRAM_MspInit+0x168>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 8002850:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 8002852:	f7fe ffa9 	bl	80017a8 <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4|\
 8002856:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800285a:	a909      	add	r1, sp, #36	; 0x24
 800285c:	4823      	ldr	r0, [pc, #140]	; (80028ec <BSP_SDRAM_MspInit+0x16c>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4|\
 800285e:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 8002860:	f7fe ffa2 	bl	80017a8 <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_9 |\
 8002864:	f64f 732c 	movw	r3, #65324	; 0xff2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 8002868:	a909      	add	r1, sp, #36	; 0x24
 800286a:	4821      	ldr	r0, [pc, #132]	; (80028f0 <BSP_SDRAM_MspInit+0x170>)
  gpio_init_structure.Pin   = GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_9 |\
 800286c:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 800286e:	f7fe ff9b 	bl	80017a8 <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 |\
 8002872:	f240 63ff 	movw	r3, #1791	; 0x6ff
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);  
 8002876:	a909      	add	r1, sp, #36	; 0x24
 8002878:	481e      	ldr	r0, [pc, #120]	; (80028f4 <BSP_SDRAM_MspInit+0x174>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 |\
 800287a:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);  
 800287c:	f7fe ff94 	bl	80017a8 <HAL_GPIO_Init>
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8002880:	2380      	movs	r3, #128	; 0x80
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 8002882:	f44f 7100 	mov.w	r1, #512	; 0x200
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8002886:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  dma_handle.Init.Mode                = DMA_NORMAL;
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 800288a:	6325      	str	r5, [r4, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMAx_STREAM;
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 800288c:	6334      	str	r4, [r6, #48]	; 0x30
  dma_handle.Init.Mode                = DMA_NORMAL;
 800288e:	61e5      	str	r5, [r4, #28]
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 8002890:	63a6      	str	r6, [r4, #56]	; 0x38
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8002892:	e9c4 5301 	strd	r5, r3, [r4, #4]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 8002896:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800289a:	e9c4 1303 	strd	r1, r3, [r4, #12]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 800289e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80028a2:	e9c4 0305 	strd	r0, r3, [r4, #20]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 80028a6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 80028aa:	4620      	mov	r0, r4
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 80028ac:	e9c4 3508 	strd	r3, r5, [r4, #32]
  dma_handle.Instance = SDRAM_DMAx_STREAM;
 80028b0:	4b11      	ldr	r3, [pc, #68]	; (80028f8 <BSP_SDRAM_MspInit+0x178>)
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 80028b2:	e9c4 750a 	strd	r7, r5, [r4, #40]	; 0x28
  dma_handle.Instance = SDRAM_DMAx_STREAM;
 80028b6:	6023      	str	r3, [r4, #0]
  HAL_DMA_DeInit(&dma_handle);
 80028b8:	f001 fe00 	bl	80044bc <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 80028bc:	4620      	mov	r0, r4
 80028be:	f7fe fcef 	bl	80012a0 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
 80028c2:	462a      	mov	r2, r5
 80028c4:	210f      	movs	r1, #15
 80028c6:	2038      	movs	r0, #56	; 0x38
 80028c8:	f7fe fc94 	bl	80011f4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 80028cc:	2038      	movs	r0, #56	; 0x38
 80028ce:	f7fe fcc3 	bl	8001258 <HAL_NVIC_EnableIRQ>
}
 80028d2:	b00f      	add	sp, #60	; 0x3c
 80028d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80028d6:	bf00      	nop
 80028d8:	40023800 	.word	0x40023800
 80028dc:	40020c00 	.word	0x40020c00
 80028e0:	20020350 	.word	0x20020350
 80028e4:	40021000 	.word	0x40021000
 80028e8:	40021400 	.word	0x40021400
 80028ec:	40021800 	.word	0x40021800
 80028f0:	40021c00 	.word	0x40021c00
 80028f4:	40022000 	.word	0x40022000
 80028f8:	40026410 	.word	0x40026410

080028fc <BSP_SDRAM_Init>:
{ 
 80028fc:	b538      	push	{r3, r4, r5, lr}
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 80028fe:	4c19      	ldr	r4, [pc, #100]	; (8002964 <BSP_SDRAM_Init+0x68>)
  Timing.ExitSelfRefreshDelay = 7;
 8002900:	2107      	movs	r1, #7
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 8002902:	4b19      	ldr	r3, [pc, #100]	; (8002968 <BSP_SDRAM_Init+0x6c>)
  Timing.SelfRefreshTime      = 4;
 8002904:	2204      	movs	r2, #4
  Timing.LoadToActiveDelay    = 2;
 8002906:	4d19      	ldr	r5, [pc, #100]	; (800296c <BSP_SDRAM_Init+0x70>)
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 8002908:	f44f 6000 	mov.w	r0, #2048	; 0x800
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800290c:	6023      	str	r3, [r4, #0]
  Timing.ExitSelfRefreshDelay = 7;
 800290e:	2302      	movs	r3, #2
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 8002910:	60e2      	str	r2, [r4, #12]
  Timing.RCDDelay             = 2;
 8002912:	61ab      	str	r3, [r5, #24]
  Timing.ExitSelfRefreshDelay = 7;
 8002914:	e9c5 3100 	strd	r3, r1, [r5]
  Timing.RowCycleDelay        = 7;
 8002918:	e9c5 2102 	strd	r2, r1, [r5, #8]
  Timing.RPDelay              = 2;
 800291c:	e9c5 3304 	strd	r3, r3, [r5, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8002920:	2220      	movs	r2, #32
 8002922:	2340      	movs	r3, #64	; 0x40
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 8002924:	2100      	movs	r1, #0
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8002926:	e9c4 2304 	strd	r2, r3, [r4, #16]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_3;
 800292a:	f44f 73c0 	mov.w	r3, #384	; 0x180
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 800292e:	62a1      	str	r1, [r4, #40]	; 0x28
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8002930:	e9c4 3106 	strd	r3, r1, [r4, #24]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 8002934:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8002938:	e9c4 0308 	strd	r0, r3, [r4, #32]
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 800293c:	4620      	mov	r0, r4
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800293e:	e9c4 1101 	strd	r1, r1, [r4, #4]
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 8002942:	f7ff ff1d 	bl	8002780 <BSP_SDRAM_MspInit>
  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 8002946:	4629      	mov	r1, r5
 8002948:	4620      	mov	r0, r4
 800294a:	4c09      	ldr	r4, [pc, #36]	; (8002970 <BSP_SDRAM_Init+0x74>)
 800294c:	f002 f8cb 	bl	8004ae6 <HAL_SDRAM_Init>
 8002950:	3000      	adds	r0, #0
 8002952:	bf18      	it	ne
 8002954:	2001      	movne	r0, #1
 8002956:	7020      	strb	r0, [r4, #0]
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 8002958:	f240 6003 	movw	r0, #1539	; 0x603
 800295c:	f7ff fec6 	bl	80026ec <BSP_SDRAM_Initialization_sequence>
}
 8002960:	7820      	ldrb	r0, [r4, #0]
 8002962:	bd38      	pop	{r3, r4, r5, pc}
 8002964:	200203b0 	.word	0x200203b0
 8002968:	a0000140 	.word	0xa0000140
 800296c:	20020334 	.word	0x20020334
 8002970:	20021340 	.word	0x20021340

08002974 <_IntExit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_ExcExit)

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
 8002974:	4804      	ldr	r0, [pc, #16]	; (8002988 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
 8002976:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
 8002978:	6a00      	ldr	r0, [r0, #32]
    cmp r0, r1
 800297a:	4288      	cmp	r0, r1
    beq _EXIT_EXC
 800297c:	d003      	beq.n	8002986 <_EXIT_EXC>

    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
 800297e:	4903      	ldr	r1, [pc, #12]	; (800298c <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
 8002980:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
 8002984:	600a      	str	r2, [r1, #0]

08002986 <_EXIT_EXC>:
    mov lr, r1
#else
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */
    bx lr
 8002986:	4770      	bx	lr
    ldr r0, =_kernel
 8002988:	20020530 	.word	0x20020530
    ldr r1, =_SCS_ICSR
 800298c:	e000ed04 	.word	0xe000ed04

08002990 <z_IntLibInit>:
 * @return N/A
 */

void z_IntLibInit(void)
{
	int irq = 0;
 8002990:	2300      	movs	r3, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002992:	4804      	ldr	r0, [pc, #16]	; (80029a4 <z_IntLibInit+0x14>)
 8002994:	2110      	movs	r1, #16
 8002996:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8002998:	3301      	adds	r3, #1
 800299a:	2b6e      	cmp	r3, #110	; 0x6e
 800299c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 80029a0:	d1f9      	bne.n	8002996 <z_IntLibInit+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 80029a2:	4770      	bx	lr
 80029a4:	e000e100 	.word	0xe000e100

080029a8 <__swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
 80029a8:	4a09      	ldr	r2, [pc, #36]	; (80029d0 <__swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
 80029aa:	490a      	ldr	r1, [pc, #40]	; (80029d4 <__swap+0x2c>)
	_current->arch.basepri = key;
 80029ac:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
 80029ae:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
 80029b0:	65d8      	str	r0, [r3, #92]	; 0x5c
	_current->arch.swap_return_value = _k_neg_eagain;
 80029b2:	6619      	str	r1, [r3, #96]	; 0x60

	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80029b4:	4908      	ldr	r1, [pc, #32]	; (80029d8 <__swap+0x30>)
 80029b6:	684b      	ldr	r3, [r1, #4]
 80029b8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80029bc:	604b      	str	r3, [r1, #4]
 80029be:	2300      	movs	r3, #0
 80029c0:	f383 8811 	msr	BASEPRI, r3
 80029c4:	f3bf 8f6f 	isb	sy
	irq_unlock(0);

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
 80029c8:	6893      	ldr	r3, [r2, #8]
}
 80029ca:	6e18      	ldr	r0, [r3, #96]	; 0x60
 80029cc:	4770      	bx	lr
 80029ce:	bf00      	nop
 80029d0:	20020530 	.word	0x20020530
 80029d4:	08005c9c 	.word	0x08005c9c
 80029d8:	e000ed00 	.word	0xe000ed00

080029dc <__pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
 80029dc:	490f      	ldr	r1, [pc, #60]	; (8002a1c <__pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
 80029de:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
 80029e0:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
 80029e4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
    mrs ip, PSP
 80029e6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
 80029ea:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 80029ee:	2010      	movs	r0, #16
    msr BASEPRI, r0
 80029f0:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
 80029f4:	f3bf 8f6f 	isb	sy
     * don't clear it yet. PendSV must not be cleared until
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
    ldr v4, =_SCS_ICSR
 80029f8:	4f09      	ldr	r7, [pc, #36]	; (8002a20 <__pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
 80029fa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 80029fe:	6a0a      	ldr	r2, [r1, #32]

    str r2, [r1, #_kernel_offset_to_current]
 8002a00:	608a      	str	r2, [r1, #8]
     * since they were based on the previous kernel state and this
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
    str v3, [v4, #0]
 8002a02:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
 8002a04:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
    movs.n r3, #0
 8002a06:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
 8002a08:	65d3      	str	r3, [r2, #92]	; 0x5c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
 8002a0a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
 8002a0e:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
 8002a12:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    /* clear stack pointer limit before setting the PSP */
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

    msr PSP, ip
 8002a16:	f38c 8809 	msr	PSP, ip
    pop {r0, lr}
#endif
#endif /* CONFIG_TRACING */

    /* exc return */
    bx lr
 8002a1a:	4770      	bx	lr
    ldr r1, =_kernel
 8002a1c:	20020530 	.word	0x20020530
    ldr v4, =_SCS_ICSR
 8002a20:	e000ed04 	.word	0xe000ed04

08002a24 <__svc>:
 * - System Calls (User mode)
 *
 * @return N/A
 */
SECTION_FUNC(TEXT, __svc)
    tst lr, #0x4    /* did we come from thread mode ? */
 8002a24:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 8002a28:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 8002a2a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 8002a2e:	f3ef 8009 	mrsne	r0, PSP

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 8002a32:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read encoding */
    ldrh r1, [r1, #-2]
 8002a34:	f831 1c02 	ldrh.w	r1, [r1, #-2]
    * 2: kernel panic or oops (software generated fatal exception)
    * 3: System call (if user mode supported)
    * Planned implementation of system calls for memory protection will
    * expand this case.
    */
    ands r1, #0xff
 8002a38:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    tst r2, #0x1
    bne _oops

#endif

    cmp r1, #2
 8002a3c:	2902      	cmp	r1, #2
    beq _oops
 8002a3e:	d0ff      	beq.n	8002a40 <_oops>

08002a40 <_oops>:
    /* exception return is done in _IntExit() */
    b _IntExit
#endif

_oops:
    push {r0, lr}
 8002a40:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
 8002a42:	f002 f8fa 	bl	8004c3a <z_do_kernel_oops>
    pop {r0, pc}
 8002a46:	bd01      	pop	{r0, pc}

08002a48 <MpuFault.isra.2>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t MpuFault(NANO_ESF *esf, int fromHardFault)
 8002a48:	b538      	push	{r3, r4, r5, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****\n");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 8002a4a:	4c1c      	ldr	r4, [pc, #112]	; (8002abc <MpuFault.isra.2+0x74>)
static u32_t MpuFault(NANO_ESF *esf, int fromHardFault)
 8002a4c:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** MPU FAULT *****\n");
 8002a4e:	481c      	ldr	r0, [pc, #112]	; (8002ac0 <MpuFault.isra.2+0x78>)
 8002a50:	f001 fc97 	bl	8004382 <printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 8002a54:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002a56:	06d1      	lsls	r1, r2, #27
 8002a58:	d502      	bpl.n	8002a60 <MpuFault.isra.2+0x18>
		PR_FAULT_INFO("  Stacking error (context area might be"
 8002a5a:	481a      	ldr	r0, [pc, #104]	; (8002ac4 <MpuFault.isra.2+0x7c>)
 8002a5c:	f001 fc91 	bl	8004382 <printk>
			" not valid)\n");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 8002a60:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a62:	071a      	lsls	r2, r3, #28
 8002a64:	d502      	bpl.n	8002a6c <MpuFault.isra.2+0x24>
		PR_FAULT_INFO("  Unstacking error\n");
 8002a66:	4818      	ldr	r0, [pc, #96]	; (8002ac8 <MpuFault.isra.2+0x80>)
 8002a68:	f001 fc8b 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8002a6c:	4c13      	ldr	r4, [pc, #76]	; (8002abc <MpuFault.isra.2+0x74>)
 8002a6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a70:	079b      	lsls	r3, r3, #30
 8002a72:	d50e      	bpl.n	8002a92 <MpuFault.isra.2+0x4a>
		PR_FAULT_INFO("  Data Access Violation\n");
 8002a74:	4815      	ldr	r0, [pc, #84]	; (8002acc <MpuFault.isra.2+0x84>)
 8002a76:	f001 fc84 	bl	8004382 <printk>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
 8002a7a:	6b61      	ldr	r1, [r4, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 8002a7c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a7e:	0618      	lsls	r0, r3, #24
 8002a80:	d507      	bpl.n	8002a92 <MpuFault.isra.2+0x4a>
			PR_EXC("  MMFAR Address: 0x%x\n", mmfar);
 8002a82:	4813      	ldr	r0, [pc, #76]	; (8002ad0 <MpuFault.isra.2+0x88>)
 8002a84:	f001 fc7d 	bl	8004382 <printk>
			if (fromHardFault) {
 8002a88:	b11d      	cbz	r5, 8002a92 <MpuFault.isra.2+0x4a>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 8002a8a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a8c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002a90:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 8002a92:	4c0a      	ldr	r4, [pc, #40]	; (8002abc <MpuFault.isra.2+0x74>)
 8002a94:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002a96:	07d2      	lsls	r2, r2, #31
 8002a98:	d502      	bpl.n	8002aa0 <MpuFault.isra.2+0x58>
		PR_FAULT_INFO("  Instruction Access Violation\n");
 8002a9a:	480e      	ldr	r0, [pc, #56]	; (8002ad4 <MpuFault.isra.2+0x8c>)
 8002a9c:	f001 fc71 	bl	8004382 <printk>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8002aa0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002aa2:	069b      	lsls	r3, r3, #26
 8002aa4:	d502      	bpl.n	8002aac <MpuFault.isra.2+0x64>
		PR_FAULT_INFO(
 8002aa6:	480c      	ldr	r0, [pc, #48]	; (8002ad8 <MpuFault.isra.2+0x90>)
 8002aa8:	f001 fc6b 	bl	8004382 <printk>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
 8002aac:	4b03      	ldr	r3, [pc, #12]	; (8002abc <MpuFault.isra.2+0x74>)
	if (MemoryFaultIsRecoverable(esf)) {
		reason = _NANO_ERR_RECOVERABLE;
	}

	return reason;
}
 8002aae:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
 8002ab0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 8002ab2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002ab4:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8002ab8:	629a      	str	r2, [r3, #40]	; 0x28
}
 8002aba:	bd38      	pop	{r3, r4, r5, pc}
 8002abc:	e000ed00 	.word	0xe000ed00
 8002ac0:	08007ac3 	.word	0x08007ac3
 8002ac4:	08007ada 	.word	0x08007ada
 8002ac8:	08007b0e 	.word	0x08007b0e
 8002acc:	08007b22 	.word	0x08007b22
 8002ad0:	08007b3b 	.word	0x08007b3b
 8002ad4:	08007b52 	.word	0x08007b52
 8002ad8:	08007b72 	.word	0x08007b72

08002adc <BusFault.isra.3>:
 *
 * See _FaultDump() for example.
 *
 * @return N/A
 */
static int BusFault(NANO_ESF *esf, int fromHardFault)
 8002adc:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****\n");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8002ade:	4c1e      	ldr	r4, [pc, #120]	; (8002b58 <BusFault.isra.3+0x7c>)
static int BusFault(NANO_ESF *esf, int fromHardFault)
 8002ae0:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** BUS FAULT *****\n");
 8002ae2:	481e      	ldr	r0, [pc, #120]	; (8002b5c <BusFault.isra.3+0x80>)
 8002ae4:	f001 fc4d 	bl	8004382 <printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8002ae8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002aea:	04d1      	lsls	r1, r2, #19
 8002aec:	d502      	bpl.n	8002af4 <BusFault.isra.3+0x18>
		PR_FAULT_INFO("  Stacking error\n");
 8002aee:	481c      	ldr	r0, [pc, #112]	; (8002b60 <BusFault.isra.3+0x84>)
 8002af0:	f001 fc47 	bl	8004382 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 8002af4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002af6:	051a      	lsls	r2, r3, #20
 8002af8:	d502      	bpl.n	8002b00 <BusFault.isra.3+0x24>
		PR_FAULT_INFO("  Unstacking error\n");
 8002afa:	481a      	ldr	r0, [pc, #104]	; (8002b64 <BusFault.isra.3+0x88>)
 8002afc:	f001 fc41 	bl	8004382 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 8002b00:	4c15      	ldr	r4, [pc, #84]	; (8002b58 <BusFault.isra.3+0x7c>)
 8002b02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b04:	059b      	lsls	r3, r3, #22
 8002b06:	d50e      	bpl.n	8002b26 <BusFault.isra.3+0x4a>
		PR_FAULT_INFO("  Precise data bus error\n");
 8002b08:	4817      	ldr	r0, [pc, #92]	; (8002b68 <BusFault.isra.3+0x8c>)
 8002b0a:	f001 fc3a 	bl	8004382 <printk>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
 8002b0e:	6ba1      	ldr	r1, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8002b10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b12:	0418      	lsls	r0, r3, #16
 8002b14:	d507      	bpl.n	8002b26 <BusFault.isra.3+0x4a>
			PR_EXC("  BFAR Address: 0x%x\n", bfar);
 8002b16:	4815      	ldr	r0, [pc, #84]	; (8002b6c <BusFault.isra.3+0x90>)
 8002b18:	f001 fc33 	bl	8004382 <printk>
			if (fromHardFault) {
 8002b1c:	b11d      	cbz	r5, 8002b26 <BusFault.isra.3+0x4a>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 8002b1e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b20:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002b24:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8002b26:	4c0c      	ldr	r4, [pc, #48]	; (8002b58 <BusFault.isra.3+0x7c>)
 8002b28:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b2a:	0559      	lsls	r1, r3, #21
 8002b2c:	d502      	bpl.n	8002b34 <BusFault.isra.3+0x58>
		PR_FAULT_INFO("  Imprecise data bus error\n");
 8002b2e:	4810      	ldr	r0, [pc, #64]	; (8002b70 <BusFault.isra.3+0x94>)
 8002b30:	f001 fc27 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 8002b34:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b36:	05da      	lsls	r2, r3, #23
 8002b38:	d509      	bpl.n	8002b4e <BusFault.isra.3+0x72>
		PR_FAULT_INFO("  Instruction bus error\n");
 8002b3a:	480e      	ldr	r0, [pc, #56]	; (8002b74 <BusFault.isra.3+0x98>)
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error\n");
 8002b3c:	f001 fc21 	bl	8004382 <printk>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8002b40:	4a05      	ldr	r2, [pc, #20]	; (8002b58 <BusFault.isra.3+0x7c>)
	if (MemoryFaultIsRecoverable(esf)) {
		reason = _NANO_ERR_RECOVERABLE;
	}

	return reason;
}
 8002b42:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8002b44:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8002b46:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
 8002b4a:	6293      	str	r3, [r2, #40]	; 0x28
}
 8002b4c:	bd38      	pop	{r3, r4, r5, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8002b4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b50:	049b      	lsls	r3, r3, #18
 8002b52:	d5f5      	bpl.n	8002b40 <BusFault.isra.3+0x64>
		PR_FAULT_INFO("  Floating-point lazy state preservation error\n");
 8002b54:	4808      	ldr	r0, [pc, #32]	; (8002b78 <BusFault.isra.3+0x9c>)
 8002b56:	e7f1      	b.n	8002b3c <BusFault.isra.3+0x60>
 8002b58:	e000ed00 	.word	0xe000ed00
 8002b5c:	08007a35 	.word	0x08007a35
 8002b60:	08007a4c 	.word	0x08007a4c
 8002b64:	08007b0e 	.word	0x08007b0e
 8002b68:	08007a5e 	.word	0x08007a5e
 8002b6c:	08007a78 	.word	0x08007a78
 8002b70:	08007a8e 	.word	0x08007a8e
 8002b74:	08007aaa 	.word	0x08007aaa
 8002b78:	08007b72 	.word	0x08007b72

08002b7c <UsageFault.isra.4>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t UsageFault(const NANO_ESF *esf)
 8002b7c:	b510      	push	{r4, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****\n");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8002b7e:	4c19      	ldr	r4, [pc, #100]	; (8002be4 <UsageFault.isra.4+0x68>)
	PR_FAULT_INFO("***** USAGE FAULT *****\n");
 8002b80:	4819      	ldr	r0, [pc, #100]	; (8002be8 <UsageFault.isra.4+0x6c>)
 8002b82:	f001 fbfe 	bl	8004382 <printk>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8002b86:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002b88:	0193      	lsls	r3, r2, #6
 8002b8a:	d502      	bpl.n	8002b92 <UsageFault.isra.4+0x16>
		PR_FAULT_INFO("  Division by zero\n");
 8002b8c:	4817      	ldr	r0, [pc, #92]	; (8002bec <UsageFault.isra.4+0x70>)
 8002b8e:	f001 fbf8 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8002b92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b94:	01dc      	lsls	r4, r3, #7
 8002b96:	d502      	bpl.n	8002b9e <UsageFault.isra.4+0x22>
		PR_FAULT_INFO("  Unaligned memory access\n");
 8002b98:	4815      	ldr	r0, [pc, #84]	; (8002bf0 <UsageFault.isra.4+0x74>)
 8002b9a:	f001 fbf2 	bl	8004382 <printk>
		 */
		reason = _NANO_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 8002b9e:	4c11      	ldr	r4, [pc, #68]	; (8002be4 <UsageFault.isra.4+0x68>)
 8002ba0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002ba2:	0310      	lsls	r0, r2, #12
 8002ba4:	d502      	bpl.n	8002bac <UsageFault.isra.4+0x30>
		PR_FAULT_INFO("  No coprocessor instructions\n");
 8002ba6:	4813      	ldr	r0, [pc, #76]	; (8002bf4 <UsageFault.isra.4+0x78>)
 8002ba8:	f001 fbeb 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 8002bac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002bae:	0359      	lsls	r1, r3, #13
 8002bb0:	d502      	bpl.n	8002bb8 <UsageFault.isra.4+0x3c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC\n");
 8002bb2:	4811      	ldr	r0, [pc, #68]	; (8002bf8 <UsageFault.isra.4+0x7c>)
 8002bb4:	f001 fbe5 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8002bb8:	4c0a      	ldr	r4, [pc, #40]	; (8002be4 <UsageFault.isra.4+0x68>)
 8002bba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002bbc:	0392      	lsls	r2, r2, #14
 8002bbe:	d502      	bpl.n	8002bc6 <UsageFault.isra.4+0x4a>
		PR_FAULT_INFO("  Illegal use of the EPSR\n");
 8002bc0:	480e      	ldr	r0, [pc, #56]	; (8002bfc <UsageFault.isra.4+0x80>)
 8002bc2:	f001 fbde 	bl	8004382 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8002bc6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002bc8:	03db      	lsls	r3, r3, #15
 8002bca:	d502      	bpl.n	8002bd2 <UsageFault.isra.4+0x56>
		PR_FAULT_INFO("  Attempt to execute undefined instruction\n");
 8002bcc:	480c      	ldr	r0, [pc, #48]	; (8002c00 <UsageFault.isra.4+0x84>)
 8002bce:	f001 fbd8 	bl	8004382 <printk>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8002bd2:	4a04      	ldr	r2, [pc, #16]	; (8002be4 <UsageFault.isra.4+0x68>)

	return reason;
}
 8002bd4:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8002bd6:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8002bd8:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 8002bdc:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 8002be0:	6293      	str	r3, [r2, #40]	; 0x28
}
 8002be2:	bd10      	pop	{r4, pc}
 8002be4:	e000ed00 	.word	0xe000ed00
 8002be8:	08007ba2 	.word	0x08007ba2
 8002bec:	08007bbb 	.word	0x08007bbb
 8002bf0:	08007bcf 	.word	0x08007bcf
 8002bf4:	08007bea 	.word	0x08007bea
 8002bf8:	08007c09 	.word	0x08007c09
 8002bfc:	08007c2f 	.word	0x08007c2f
 8002c00:	08007c4a 	.word	0x08007c4a

08002c04 <_Fault>:
 *
 * Note: exc_return argument shall only be used by the Fault handler if we are
 * running a Secure Firmware.
 */
void _Fault(NANO_ESF *esf, u32_t exc_return)
{
 8002c04:	b570      	push	{r4, r5, r6, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8002c06:	4d28      	ldr	r5, [pc, #160]	; (8002ca8 <_Fault+0xa4>)
{
 8002c08:	4606      	mov	r6, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8002c0a:	686b      	ldr	r3, [r5, #4]
 8002c0c:	f3c3 0208 	ubfx	r2, r3, #0, #9
	switch (fault) {
 8002c10:	1ed1      	subs	r1, r2, #3
 8002c12:	2909      	cmp	r1, #9
 8002c14:	d83b      	bhi.n	8002c8e <_Fault+0x8a>
 8002c16:	e8df f001 	tbb	[pc, r1]
 8002c1a:	3405      	.short	0x3405
 8002c1c:	3a3a2936 	.word	0x3a3a2936
 8002c20:	383a3a3a 	.word	0x383a3a3a
	PR_FAULT_INFO("***** HARD FAULT *****\n");
 8002c24:	4821      	ldr	r0, [pc, #132]	; (8002cac <_Fault+0xa8>)
 8002c26:	f001 fbac 	bl	8004382 <printk>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8002c2a:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 8002c2c:	f014 0402 	ands.w	r4, r4, #2
 8002c30:	d004      	beq.n	8002c3c <_Fault+0x38>
		PR_EXC("  Bus fault on vector table read\n");
 8002c32:	481f      	ldr	r0, [pc, #124]	; (8002cb0 <_Fault+0xac>)
	PR_FAULT_INFO(
 8002c34:	f001 fba5 	bl	8004382 <printk>
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
 8002c38:	2400      	movs	r4, #0
 8002c3a:	e01c      	b.n	8002c76 <_Fault+0x72>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8002c3c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002c3e:	005b      	lsls	r3, r3, #1
 8002c40:	d519      	bpl.n	8002c76 <_Fault+0x72>
		PR_EXC("  Fault escalation (see below)\n");
 8002c42:	481c      	ldr	r0, [pc, #112]	; (8002cb4 <_Fault+0xb0>)
 8002c44:	f001 fb9d 	bl	8004382 <printk>
		if (SCB_MMFSR != 0) {
 8002c48:	4b1b      	ldr	r3, [pc, #108]	; (8002cb8 <_Fault+0xb4>)
 8002c4a:	781b      	ldrb	r3, [r3, #0]
 8002c4c:	b11b      	cbz	r3, 8002c56 <_Fault+0x52>
			reason = MpuFault(esf, 1);
 8002c4e:	2001      	movs	r0, #1
		reason = MpuFault(esf, 0);
 8002c50:	f7ff fefa 	bl	8002a48 <MpuFault.isra.2>
 8002c54:	e00c      	b.n	8002c70 <_Fault+0x6c>
		} else if (SCB_BFSR != 0) {
 8002c56:	4b19      	ldr	r3, [pc, #100]	; (8002cbc <_Fault+0xb8>)
 8002c58:	781b      	ldrb	r3, [r3, #0]
 8002c5a:	b11b      	cbz	r3, 8002c64 <_Fault+0x60>
			reason = BusFault(esf, 1);
 8002c5c:	2001      	movs	r0, #1
		reason = BusFault(esf, 0);
 8002c5e:	f7ff ff3d 	bl	8002adc <BusFault.isra.3>
 8002c62:	e005      	b.n	8002c70 <_Fault+0x6c>
		} else if (SCB_UFSR != 0) {
 8002c64:	4b16      	ldr	r3, [pc, #88]	; (8002cc0 <_Fault+0xbc>)
 8002c66:	881b      	ldrh	r3, [r3, #0]
 8002c68:	b29b      	uxth	r3, r3
 8002c6a:	b123      	cbz	r3, 8002c76 <_Fault+0x72>
			reason = UsageFault(esf);
 8002c6c:	f7ff ff86 	bl	8002b7c <UsageFault.isra.4>
	(void) exc_return;
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	reason = FaultHandle(esf, fault);

	if (reason == _NANO_ERR_RECOVERABLE) {
 8002c70:	2806      	cmp	r0, #6
			reason = UsageFault(esf);
 8002c72:	4604      	mov	r4, r0
	if (reason == _NANO_ERR_RECOVERABLE) {
 8002c74:	d017      	beq.n	8002ca6 <_Fault+0xa2>

#if defined(CONFIG_ARM_SECURE_FIRMWARE) || \
	defined(CONFIG_ARM_NONSECURE_FIRMWARE)
_exit_fatal:
#endif
	z_NanoFatalErrorHandler(reason, esf);
 8002c76:	4631      	mov	r1, r6
 8002c78:	4620      	mov	r0, r4
}
 8002c7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_NanoFatalErrorHandler(reason, esf);
 8002c7e:	f000 b89b 	b.w	8002db8 <z_NanoFatalErrorHandler>
		reason = MpuFault(esf, 0);
 8002c82:	2000      	movs	r0, #0
 8002c84:	e7e4      	b.n	8002c50 <_Fault+0x4c>
		reason = BusFault(esf, 0);
 8002c86:	2000      	movs	r0, #0
 8002c88:	e7e9      	b.n	8002c5e <_Fault+0x5a>
	PR_FAULT_INFO(
 8002c8a:	480e      	ldr	r0, [pc, #56]	; (8002cc4 <_Fault+0xc0>)
 8002c8c:	e7d2      	b.n	8002c34 <_Fault+0x30>
	PR_FAULT_INFO("***** %s %d) *****\n",
 8002c8e:	f413 7ff8 	tst.w	r3, #496	; 0x1f0
 8002c92:	4b0d      	ldr	r3, [pc, #52]	; (8002cc8 <_Fault+0xc4>)
 8002c94:	490d      	ldr	r1, [pc, #52]	; (8002ccc <_Fault+0xc8>)
 8002c96:	f1a2 0210 	sub.w	r2, r2, #16
 8002c9a:	bf18      	it	ne
 8002c9c:	4619      	movne	r1, r3
 8002c9e:	480c      	ldr	r0, [pc, #48]	; (8002cd0 <_Fault+0xcc>)
 8002ca0:	f001 fb6f 	bl	8004382 <printk>
	if (reason == _NANO_ERR_RECOVERABLE) {
 8002ca4:	e7c8      	b.n	8002c38 <_Fault+0x34>
}
 8002ca6:	bd70      	pop	{r4, r5, r6, pc}
 8002ca8:	e000ed00 	.word	0xe000ed00
 8002cac:	08007ca4 	.word	0x08007ca4
 8002cb0:	08007cbc 	.word	0x08007cbc
 8002cb4:	08007cde 	.word	0x08007cde
 8002cb8:	e000ed28 	.word	0xe000ed28
 8002cbc:	e000ed29 	.word	0xe000ed29
 8002cc0:	e000ed2a 	.word	0xe000ed2a
 8002cc4:	08007cfe 	.word	0x08007cfe
 8002cc8:	08007c8b 	.word	0x08007c8b
 8002ccc:	08007c76 	.word	0x08007c76
 8002cd0:	08007d35 	.word	0x08007d35

08002cd4 <z_FaultInit>:
 */
void z_FaultInit(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8002cd4:	4a02      	ldr	r2, [pc, #8]	; (8002ce0 <z_FaultInit+0xc>)
 8002cd6:	6953      	ldr	r3, [r2, #20]
 8002cd8:	f043 0310 	orr.w	r3, r3, #16
 8002cdc:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
 8002cde:	4770      	bx	lr
 8002ce0:	e000ed00 	.word	0xe000ed00

08002ce4 <z_arch_irq_enable>:
 *
 * @return N/A
 */
void z_arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 8002ce4:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
 8002ce6:	2b00      	cmp	r3, #0
 8002ce8:	db08      	blt.n	8002cfc <z_arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002cea:	2201      	movs	r2, #1
 8002cec:	f000 001f 	and.w	r0, r0, #31
 8002cf0:	095b      	lsrs	r3, r3, #5
 8002cf2:	fa02 f000 	lsl.w	r0, r2, r0
 8002cf6:	4a02      	ldr	r2, [pc, #8]	; (8002d00 <z_arch_irq_enable+0x1c>)
 8002cf8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
 8002cfc:	4770      	bx	lr
 8002cfe:	bf00      	nop
 8002d00:	e000e100 	.word	0xe000e100

08002d04 <z_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 8002d04:	b243      	sxtb	r3, r0
	prio += _IRQ_PRIO_OFFSET;
 8002d06:	3101      	adds	r1, #1
  if ((int32_t)(IRQn) >= 0)
 8002d08:	2b00      	cmp	r3, #0
 8002d0a:	ea4f 1101 	mov.w	r1, r1, lsl #4
 8002d0e:	b2c9      	uxtb	r1, r1
 8002d10:	db06      	blt.n	8002d20 <z_irq_priority_set+0x1c>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002d12:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002d16:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8002d1a:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
 8002d1e:	4770      	bx	lr
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002d20:	f000 000f 	and.w	r0, r0, #15
 8002d24:	4b01      	ldr	r3, [pc, #4]	; (8002d2c <z_irq_priority_set+0x28>)
 8002d26:	5419      	strb	r1, [r3, r0]
}
 8002d28:	4770      	bx	lr
 8002d2a:	bf00      	nop
 8002d2c:	e000ed14 	.word	0xe000ed14

08002d30 <z_new_thread>:

void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stackSize, k_thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
 8002d30:	b570      	push	{r4, r5, r6, lr}
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
 8002d32:	188c      	adds	r4, r1, r2
{
 8002d34:	461e      	mov	r6, r3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
 8002d36:	2204      	movs	r2, #4
 8002d38:	9b08      	ldr	r3, [sp, #32]
 8002d3a:	9907      	ldr	r1, [sp, #28]
 8002d3c:	4605      	mov	r5, r0
 8002d3e:	f002 fc20 	bl	8005582 <z_init_thread_base>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
 8002d42:	f1a4 0320 	sub.w	r3, r4, #32
#else
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
 8002d46:	490b      	ldr	r1, [pc, #44]	; (8002d74 <z_new_thread+0x44>)

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
 8002d48:	2200      	movs	r2, #0
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
 8002d4a:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
 8002d4e:	f021 0101 	bic.w	r1, r1, #1
	thread->fn_abort = NULL;
 8002d52:	e9c5 2213 	strd	r2, r2, [r5, #76]	; 0x4c
 8002d56:	6199      	str	r1, [r3, #24]

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
 8002d58:	9904      	ldr	r1, [sp, #16]
	pInitCtx->basic.a1 = (u32_t)pEntry;
 8002d5a:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
 8002d5c:	6059      	str	r1, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
 8002d5e:	9905      	ldr	r1, [sp, #20]
 8002d60:	6099      	str	r1, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
 8002d62:	9906      	ldr	r1, [sp, #24]
 8002d64:	60d9      	str	r1, [r3, #12]
	pInitCtx->basic.xpsr =
 8002d66:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8002d6a:	61d9      	str	r1, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
 8002d6c:	64ab      	str	r3, [r5, #72]	; 0x48
	thread->arch.basepri = 0;
 8002d6e:	65ea      	str	r2, [r5, #92]	; 0x5c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
 8002d70:	bd70      	pop	{r4, r5, r6, pc}
 8002d72:	bf00      	nop
 8002d74:	0800406f 	.word	0x0800406f

08002d78 <z_CpuIdleInit>:
 *
 * void z_CpuIdleInit (void);
 */

SECTION_FUNC(TEXT, z_CpuIdleInit)
	ldr r1, =_SCB_SCR
 8002d78:	4901      	ldr	r1, [pc, #4]	; (8002d80 <z_CpuIdleInit+0x8>)
	movs.n r2, #_SCR_INIT_BITS
 8002d7a:	2210      	movs	r2, #16
	str r2, [r1]
 8002d7c:	600a      	str	r2, [r1, #0]
	bx lr
 8002d7e:	4770      	bx	lr
	ldr r1, =_SCB_SCR
 8002d80:	e000ed10 	.word	0xe000ed10

08002d84 <k_cpu_idle>:

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
 8002d84:	4040      	eors	r0, r0
	msr BASEPRI, r0
 8002d86:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
 8002d8a:	bf30      	wfi

	bx lr
 8002d8c:	4770      	bx	lr
 8002d8e:	bf00      	nop

08002d90 <__bus_fault>:
	mrs r0, MSP
_stack_frame_endif:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* force unlock interrupts */
	eors.n r0, r0
 8002d90:	4040      	eors	r0, r0
	msr BASEPRI, r0
 8002d92:	f380 8811 	msr	BASEPRI, r0

#if !defined(CONFIG_ARM_SECURE_FIRMWARE) && \
	!defined(CONFIG_ARM_NONSECURE_FIRMWARE)
	/* this checks to see if we are in a nested exception */
	ldr ip, =_SCS_ICSR
 8002d96:	f8df c01c 	ldr.w	ip, [pc, #28]	; 8002db4 <__bus_fault+0x24>
	ldr ip, [ip]
 8002d9a:	f8dc c000 	ldr.w	ip, [ip]
	ands.w ip, #_SCS_ICSR_RETTOBASE
 8002d9e:	f41c 6c00 	ands.w	ip, ip, #2048	; 0x800

	ite eq			/* is the RETTOBASE bit zero ? */
 8002da2:	bf0c      	ite	eq
		mrseq r0, MSP	/* if so, we're not returning to thread mode,
 8002da4:	f3ef 8008 	mrseq	r0, MSP
				 * thus this is a nested exception: the stack
				 * frame is on the MSP */
		mrsne r0, PSP	/* if not, we are returning to thread mode, thus
 8002da8:	f3ef 8009 	mrsne	r0, PSP
	 * located in the LR. Therefore, we supply the LR value as an
	 * argument to the fault handler.
	 */
	mov r1, lr
#endif /* CONFIG_ARM_SECURE_FIRMWARE || CONFIG_ARM_NONSECURE_FIRMWARE */
	push {r0, lr}
 8002dac:	b501      	push	{r0, lr}
	bl _Fault
 8002dae:	f7ff ff29 	bl	8002c04 <_Fault>

	pop {r0, pc}
 8002db2:	bd01      	pop	{r0, pc}
	ldr ip, =_SCS_ICSR
 8002db4:	e000ed04 	.word	0xe000ed04

08002db8 <z_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
void z_NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
 8002db8:	b538      	push	{r3, r4, r5, lr}
 8002dba:	4604      	mov	r4, r0
 8002dbc:	460d      	mov	r5, r1
	const char *thread_name = k_thread_name_get(k_current_get());
#endif

	LOG_PANIC();

	switch (reason) {
 8002dbe:	2805      	cmp	r0, #5
 8002dc0:	d81a      	bhi.n	8002df8 <z_NanoFatalErrorHandler+0x40>
 8002dc2:	e8df f000 	tbb	[pc, r0]
 8002dc6:	1903      	.short	0x1903
 8002dc8:	17151319 	.word	0x17151319
	case _NANO_ERR_HW_EXCEPTION:
		printk("***** Hardware exception *****\n");
 8002dcc:	480d      	ldr	r0, [pc, #52]	; (8002e04 <z_NanoFatalErrorHandler+0x4c>)
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
 8002dce:	f001 fad8 	bl	8004382 <printk>

K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)

K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
 8002dd2:	f000 fed5 	bl	8003b80 <z_impl_k_current_get>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}
	printk("Current thread ID = %p"
 8002dd6:	69aa      	ldr	r2, [r5, #24]
 8002dd8:	4601      	mov	r1, r0
 8002dda:	480b      	ldr	r0, [pc, #44]	; (8002e08 <z_NanoFatalErrorHandler+0x50>)
 8002ddc:	f001 fad1 	bl	8004382 <printk>
	 * to respond to the error.  The decisions as to what responses are
	 * appropriate to the various errors are something the customer must
	 * decide.
	 */

	z_SysFatalErrorHandler(reason, pEsf);
 8002de0:	4629      	mov	r1, r5
 8002de2:	4620      	mov	r0, r4
}
 8002de4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_SysFatalErrorHandler(reason, pEsf);
 8002de8:	f000 b818 	b.w	8002e1c <z_SysFatalErrorHandler>
		printk("**** Kernel Allocation Failure! ****\n");
 8002dec:	4807      	ldr	r0, [pc, #28]	; (8002e0c <z_NanoFatalErrorHandler+0x54>)
 8002dee:	e7ee      	b.n	8002dce <z_NanoFatalErrorHandler+0x16>
		printk("***** Kernel OOPS! *****\n");
 8002df0:	4807      	ldr	r0, [pc, #28]	; (8002e10 <z_NanoFatalErrorHandler+0x58>)
 8002df2:	e7ec      	b.n	8002dce <z_NanoFatalErrorHandler+0x16>
		printk("***** Kernel Panic! *****\n");
 8002df4:	4807      	ldr	r0, [pc, #28]	; (8002e14 <z_NanoFatalErrorHandler+0x5c>)
 8002df6:	e7ea      	b.n	8002dce <z_NanoFatalErrorHandler+0x16>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
 8002df8:	4601      	mov	r1, r0
 8002dfa:	4807      	ldr	r0, [pc, #28]	; (8002e18 <z_NanoFatalErrorHandler+0x60>)
 8002dfc:	f001 fac1 	bl	8004382 <printk>
		break;
 8002e00:	e7e7      	b.n	8002dd2 <z_NanoFatalErrorHandler+0x1a>
 8002e02:	bf00      	nop
 8002e04:	08007d49 	.word	0x08007d49
 8002e08:	08007de7 	.word	0x08007de7
 8002e0c:	08007d69 	.word	0x08007d69
 8002e10:	08007d8f 	.word	0x08007d8f
 8002e14:	08007da9 	.word	0x08007da9
 8002e18:	08007dc4 	.word	0x08007dc4

08002e1c <z_SysFatalErrorHandler>:
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
 8002e1c:	2805      	cmp	r0, #5
{
 8002e1e:	b510      	push	{r4, lr}
	if (reason == _NANO_ERR_KERNEL_PANIC) {
 8002e20:	d00c      	beq.n	8002e3c <z_SysFatalErrorHandler+0x20>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
 8002e22:	f000 fefd 	bl	8003c20 <k_is_in_isr>
 8002e26:	b160      	cbz	r0, 8002e42 <z_SysFatalErrorHandler+0x26>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
 8002e28:	f000 fefa 	bl	8003c20 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
 8002e2c:	490c      	ldr	r1, [pc, #48]	; (8002e60 <z_SysFatalErrorHandler+0x44>)
 8002e2e:	4b0d      	ldr	r3, [pc, #52]	; (8002e64 <z_SysFatalErrorHandler+0x48>)
 8002e30:	2800      	cmp	r0, #0
 8002e32:	bf08      	it	eq
 8002e34:	4619      	moveq	r1, r3
 8002e36:	480c      	ldr	r0, [pc, #48]	; (8002e68 <z_SysFatalErrorHandler+0x4c>)
 8002e38:	f001 faa3 	bl	8004382 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
 8002e3c:	f7ff ffa2 	bl	8002d84 <k_cpu_idle>
 8002e40:	e7fc      	b.n	8002e3c <z_SysFatalErrorHandler+0x20>
	if (k_is_in_isr() || z_is_thread_essential()) {
 8002e42:	f000 fefd 	bl	8003c40 <z_is_thread_essential>
 8002e46:	2800      	cmp	r0, #0
 8002e48:	d1ee      	bne.n	8002e28 <z_SysFatalErrorHandler+0xc>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
 8002e4a:	4c08      	ldr	r4, [pc, #32]	; (8002e6c <z_SysFatalErrorHandler+0x50>)
 8002e4c:	4808      	ldr	r0, [pc, #32]	; (8002e70 <z_SysFatalErrorHandler+0x54>)
 8002e4e:	68a1      	ldr	r1, [r4, #8]
 8002e50:	f001 fa97 	bl	8004382 <printk>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
 8002e54:	68a0      	ldr	r0, [r4, #8]
	}
	CODE_UNREACHABLE;
}
 8002e56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002e5a:	f000 b80b 	b.w	8002e74 <z_impl_k_thread_abort>
 8002e5e:	bf00      	nop
 8002e60:	08007e23 	.word	0x08007e23
 8002e64:	08007e27 	.word	0x08007e27
 8002e68:	08007e38 	.word	0x08007e38
 8002e6c:	20020530 	.word	0x20020530
 8002e70:	08007e58 	.word	0x08007e58

08002e74 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
 8002e74:	b538      	push	{r3, r4, r5, lr}
 8002e76:	4605      	mov	r5, r0
	__asm__ volatile(
 8002e78:	f04f 0310 	mov.w	r3, #16
 8002e7c:	f3ef 8411 	mrs	r4, BASEPRI
 8002e80:	f383 8811 	msr	BASEPRI, r3
 8002e84:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
 8002e88:	f002 fb5c 	bl	8005544 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
 8002e8c:	4b0a      	ldr	r3, [pc, #40]	; (8002eb8 <z_impl_k_thread_abort+0x44>)
 8002e8e:	689b      	ldr	r3, [r3, #8]
 8002e90:	42ab      	cmp	r3, r5
 8002e92:	d10b      	bne.n	8002eac <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
 8002e94:	4b09      	ldr	r3, [pc, #36]	; (8002ebc <z_impl_k_thread_abort+0x48>)
 8002e96:	685a      	ldr	r2, [r3, #4]
 8002e98:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002e9c:	b912      	cbnz	r2, 8002ea4 <z_impl_k_thread_abort+0x30>
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
 8002e9e:	4620      	mov	r0, r4
 8002ea0:	f7ff fd82 	bl	80029a8 <__swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8002ea4:	685a      	ldr	r2, [r3, #4]
 8002ea6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002eaa:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 8002eac:	4620      	mov	r0, r4
}
 8002eae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
 8002eb2:	f002 baad 	b.w	8005410 <z_reschedule_irqlock>
 8002eb6:	bf00      	nop
 8002eb8:	20020530 	.word	0x20020530
 8002ebc:	e000ed00 	.word	0xe000ed00

08002ec0 <_isr_wrapper>:
 *
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

	push {r0,lr}		/* r0, lr are now the first items on the stack */
 8002ec0:	b501      	push	{r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
#endif

	mrs r0, IPSR	/* get exception number */
 8002ec2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 8002ec6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 8002eca:	ea4f 00c0 	mov.w	r0, r0, lsl #3
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
 8002ece:	4904      	ldr	r1, [pc, #16]	; (8002ee0 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 8002ed0:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 8002ed2:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
 8002ed4:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 8002ed6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * _IntExit() */
	ldr r0, =_IntExit
 8002eda:	4802      	ldr	r0, [pc, #8]	; (8002ee4 <_isr_wrapper+0x24>)
	bx r0
 8002edc:	4700      	bx	r0
 8002ede:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
 8002ee0:	08005668 	.word	0x08005668
	ldr r0, =_IntExit
 8002ee4:	08002975 	.word	0x08002975

08002ee8 <__reset>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8002ee8:	2010      	movs	r0, #16
    msr BASEPRI, r0
 8002eea:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
 8002eee:	4808      	ldr	r0, [pc, #32]	; (8002f10 <__reset+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
 8002ef0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 8002ef4:	1840      	adds	r0, r0, r1
    msr PSP, r0
 8002ef6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 8002efa:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 8002efe:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8002f00:	4308      	orrs	r0, r1
    msr CONTROL, r0
 8002f02:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 8002f06:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to _PrepC
     * (even though we do not intend to return).
     */
    bl _PrepC
 8002f0a:	f000 f807 	bl	8002f1c <_PrepC>
 8002f0e:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
 8002f10:	20020ab0 	.word	0x20020ab0

08002f14 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 8002f14:	bf30      	wfi
    b z_SysNmiOnReset
 8002f16:	f7ff bffd 	b.w	8002f14 <z_SysNmiOnReset>
 8002f1a:	bf00      	nop

08002f1c <_PrepC>:

#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	extern u64_t __start_time_stamp;
#endif
void _PrepC(void)
{
 8002f1c:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8002f1e:	4b08      	ldr	r3, [pc, #32]	; (8002f40 <_PrepC+0x24>)
 8002f20:	4a08      	ldr	r2, [pc, #32]	; (8002f44 <_PrepC+0x28>)
 8002f22:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002f26:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
 8002f28:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002f2c:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
 8002f30:	f000 fb16 	bl	8003560 <z_bss_zero>
	z_data_copy();
 8002f34:	f000 fb1e 	bl	8003574 <z_data_copy>
#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	__start_time_stamp = 0U;
#endif
	z_IntLibInit();
 8002f38:	f7ff fd2a 	bl	8002990 <z_IntLibInit>
	z_cstart();
 8002f3c:	f000 fb4c 	bl	80035d8 <z_cstart>
 8002f40:	08000000 	.word	0x08000000
 8002f44:	e000ed00 	.word	0xe000ed00

08002f48 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
 8002f48:	4b01      	ldr	r3, [pc, #4]	; (8002f50 <__stdout_hook_install+0x8>)
 8002f4a:	6018      	str	r0, [r3, #0]
}
 8002f4c:	4770      	bx	lr
 8002f4e:	bf00      	nop
 8002f50:	200212dc 	.word	0x200212dc

08002f54 <pinmux_stm32_init>:
	{STM32_PIN_PG14, STM32F7_PINMUX_FUNC_PG14_ETH},
#endif /* CONFIG_ETH_STM32_HAL */
};

static int pinmux_stm32_init(struct device *port)
{
 8002f54:	b508      	push	{r3, lr}
	ARG_UNUSED(port);

	stm32_setup_pins(pinconf, ARRAY_SIZE(pinconf));
 8002f56:	2108      	movs	r1, #8
 8002f58:	4802      	ldr	r0, [pc, #8]	; (8002f64 <pinmux_stm32_init+0x10>)
 8002f5a:	f7fe f843 	bl	8000fe4 <stm32_setup_pins>

	return 0;
}
 8002f5e:	2000      	movs	r0, #0
 8002f60:	bd08      	pop	{r3, pc}
 8002f62:	bf00      	nop
 8002f64:	08005b28 	.word	0x08005b28

08002f68 <gpio_stm32_init>:
 *
 * @return 0
 */
static int gpio_stm32_init(struct device *device)
{
	const struct gpio_stm32_config *cfg = device->config->config_info;
 8002f68:	6803      	ldr	r3, [r0, #0]
 8002f6a:	4807      	ldr	r0, [pc, #28]	; (8002f88 <gpio_stm32_init+0x20>)
{
 8002f6c:	b510      	push	{r4, lr}
	const struct gpio_stm32_config *cfg = device->config->config_info;
 8002f6e:	689c      	ldr	r4, [r3, #8]
 8002f70:	f000 fad0 	bl	8003514 <z_impl_device_get_binding>
 8002f74:	6843      	ldr	r3, [r0, #4]
 8002f76:	f104 0108 	add.w	r1, r4, #8
 8002f7a:	681b      	ldr	r3, [r3, #0]
 8002f7c:	4798      	blx	r3

	/* enable clock for subsystem */
	struct device *clk =
		device_get_binding(STM32_CLOCK_CONTROL_NAME);

	if (clock_control_on(clk,
 8002f7e:	2800      	cmp	r0, #0
		}
	}
#endif  /* PWR_CR2_IOSV */

	return 0;
}
 8002f80:	bf18      	it	ne
 8002f82:	f06f 0004 	mvnne.w	r0, #4
 8002f86:	bd10      	pop	{r4, pc}
 8002f88:	08005d41 	.word	0x08005d41

08002f8c <gpio_stm32_enable_int>:
{
 8002f8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002f8e:	4605      	mov	r5, r0
 8002f90:	481c      	ldr	r0, [pc, #112]	; (8003004 <gpio_stm32_enable_int+0x78>)
 8002f92:	460c      	mov	r4, r1
 8002f94:	f000 fabe 	bl	8003514 <z_impl_device_get_binding>
	struct stm32_pclken pclken = {
 8002f98:	491b      	ldr	r1, [pc, #108]	; (8003008 <gpio_stm32_enable_int+0x7c>)
 8002f9a:	4602      	mov	r2, r0
 8002f9c:	466b      	mov	r3, sp
 8002f9e:	c903      	ldmia	r1, {r0, r1}
 8002fa0:	e883 0003 	stmia.w	r3, {r0, r1}
 8002fa4:	6851      	ldr	r1, [r2, #4]
 8002fa6:	4610      	mov	r0, r2
 8002fa8:	680e      	ldr	r6, [r1, #0]
 8002faa:	4619      	mov	r1, r3
 8002fac:	47b0      	blx	r6
	if (pin > 15) {
 8002fae:	2c0f      	cmp	r4, #15
 8002fb0:	dc25      	bgt.n	8002ffe <gpio_stm32_enable_int+0x72>
	line = (0xF << ((pin % 4 * 4) + 16)) | (pin / 4);
 8002fb2:	4263      	negs	r3, r4
 8002fb4:	f004 0103 	and.w	r1, r4, #3
 8002fb8:	f003 0303 	and.w	r3, r3, #3
 8002fbc:	bf58      	it	pl
 8002fbe:	4259      	negpl	r1, r3
 8002fc0:	2c00      	cmp	r4, #0
 8002fc2:	f101 0104 	add.w	r1, r1, #4
 8002fc6:	bfb8      	it	lt
 8002fc8:	3403      	addlt	r4, #3
 8002fca:	008b      	lsls	r3, r1, #2
 8002fcc:	210f      	movs	r1, #15
 8002fce:	4099      	lsls	r1, r3
 8002fd0:	ea41 01a4 	orr.w	r1, r1, r4, asr #2
  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFFU], (Line >> 16U), Port << POSITION_VAL((Line >> 16U)));
 8002fd4:	b2cb      	uxtb	r3, r1
 8002fd6:	0c09      	lsrs	r1, r1, #16
 8002fd8:	009b      	lsls	r3, r3, #2
 8002fda:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002fde:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
 8002fe2:	689a      	ldr	r2, [r3, #8]
 8002fe4:	ea22 0201 	bic.w	r2, r2, r1
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002fe8:	fa91 f1a1 	rbit	r1, r1
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 8002fec:	fab1 f181 	clz	r1, r1
	return 0;
 8002ff0:	2000      	movs	r0, #0
 8002ff2:	fa05 f101 	lsl.w	r1, r5, r1
 8002ff6:	4311      	orrs	r1, r2
 8002ff8:	6099      	str	r1, [r3, #8]
}
 8002ffa:	b002      	add	sp, #8
 8002ffc:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
 8002ffe:	f06f 0015 	mvn.w	r0, #21
 8003002:	e7fa      	b.n	8002ffa <gpio_stm32_enable_int+0x6e>
 8003004:	08005d41 	.word	0x08005d41
 8003008:	08005ad4 	.word	0x08005ad4

0800300c <gpio_stm32_config>:
{
 800300c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8003010:	461d      	mov	r5, r3
	const struct gpio_stm32_config *cfg = dev->config->config_info;
 8003012:	6803      	ldr	r3, [r0, #0]
{
 8003014:	4680      	mov	r8, r0
 8003016:	4616      	mov	r6, r2
	const struct gpio_stm32_config *cfg = dev->config->config_info;
 8003018:	689f      	ldr	r7, [r3, #8]
	if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
 800301a:	f005 0380 	and.w	r3, r5, #128	; 0x80
 800301e:	430b      	orrs	r3, r1
 8003020:	d005      	beq.n	800302e <gpio_stm32_config+0x22>
		return -ENOTSUP;
 8003022:	f06f 0422 	mvn.w	r4, #34	; 0x22
}
 8003026:	4620      	mov	r0, r4
 8003028:	b002      	add	sp, #8
 800302a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	map_res = gpio_stm32_flags_to_conf(flags, &pincfg);
 800302e:	a901      	add	r1, sp, #4
 8003030:	4628      	mov	r0, r5
 8003032:	f001 fee6 	bl	8004e02 <gpio_stm32_flags_to_conf>
	if (map_res != 0) {
 8003036:	4604      	mov	r4, r0
 8003038:	2800      	cmp	r0, #0
 800303a:	d1f4      	bne.n	8003026 <gpio_stm32_config+0x1a>
	if (gpio_stm32_configure(cfg->base, pin, pincfg, 0) != 0) {
 800303c:	4603      	mov	r3, r0
 800303e:	9a01      	ldr	r2, [sp, #4]
 8003040:	4631      	mov	r1, r6
 8003042:	6838      	ldr	r0, [r7, #0]
 8003044:	f001 fefa 	bl	8004e3c <gpio_stm32_configure>
 8003048:	4604      	mov	r4, r0
 800304a:	bb10      	cbnz	r0, 8003092 <gpio_stm32_config+0x86>
	if (IS_ENABLED(CONFIG_EXTI_STM32) && (flags & GPIO_INT) != 0) {
 800304c:	07a9      	lsls	r1, r5, #30
 800304e:	d5ea      	bpl.n	8003026 <gpio_stm32_config+0x1a>
		if (stm32_exti_set_callback(pin, cfg->port,
 8003050:	4643      	mov	r3, r8
 8003052:	4a13      	ldr	r2, [pc, #76]	; (80030a0 <gpio_stm32_config+0x94>)
 8003054:	6879      	ldr	r1, [r7, #4]
 8003056:	4630      	mov	r0, r6
 8003058:	f7fd fbc8 	bl	80007ec <stm32_exti_set_callback>
 800305c:	b9e0      	cbnz	r0, 8003098 <gpio_stm32_config+0x8c>
		gpio_stm32_enable_int(cfg->port, pin);
 800305e:	4631      	mov	r1, r6
 8003060:	6878      	ldr	r0, [r7, #4]
 8003062:	f7ff ff93 	bl	8002f8c <gpio_stm32_enable_int>
		if ((flags & GPIO_INT_EDGE) != 0) {
 8003066:	06aa      	lsls	r2, r5, #26
 8003068:	d5db      	bpl.n	8003022 <gpio_stm32_config+0x16>
			if ((flags & GPIO_INT_DOUBLE_EDGE) != 0) {
 800306a:	066b      	lsls	r3, r5, #25
 800306c:	d40f      	bmi.n	800308e <gpio_stm32_config+0x82>
				edge = STM32_EXTI_TRIG_FALLING;
 800306e:	f015 0f04 	tst.w	r5, #4
 8003072:	bf14      	ite	ne
 8003074:	2101      	movne	r1, #1
 8003076:	2102      	moveq	r1, #2
			stm32_exti_trigger(pin, edge);
 8003078:	4630      	mov	r0, r6
 800307a:	f7fd fb9f 	bl	80007bc <stm32_exti_trigger>
		if (stm32_exti_enable(pin) != 0) {
 800307e:	4630      	mov	r0, r6
 8003080:	f7fd fb82 	bl	8000788 <stm32_exti_enable>
			return -ENOSYS;
 8003084:	2800      	cmp	r0, #0
 8003086:	bf18      	it	ne
 8003088:	f06f 0446 	mvnne.w	r4, #70	; 0x46
 800308c:	e7cb      	b.n	8003026 <gpio_stm32_config+0x1a>
				edge = STM32_EXTI_TRIG_RISING |
 800308e:	2103      	movs	r1, #3
 8003090:	e7f2      	b.n	8003078 <gpio_stm32_config+0x6c>
		return -EIO;
 8003092:	f06f 0404 	mvn.w	r4, #4
 8003096:	e7c6      	b.n	8003026 <gpio_stm32_config+0x1a>
			return -EBUSY;
 8003098:	f06f 040f 	mvn.w	r4, #15
 800309c:	e7c3      	b.n	8003026 <gpio_stm32_config+0x1a>
 800309e:	bf00      	nop
 80030a0:	08004d07 	.word	0x08004d07

080030a4 <spi_stm32_init>:
#endif
	.release = spi_stm32_release,
};

static int spi_stm32_init(struct device *dev)
{
 80030a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct spi_stm32_data *data __attribute__((unused)) = dev->driver_data;
	const struct spi_stm32_config *cfg = dev->config->config_info;
 80030a6:	6803      	ldr	r3, [r0, #0]
{
 80030a8:	4605      	mov	r5, r0
	struct spi_stm32_data *data __attribute__((unused)) = dev->driver_data;
 80030aa:	6887      	ldr	r7, [r0, #8]
 80030ac:	480a      	ldr	r0, [pc, #40]	; (80030d8 <spi_stm32_init+0x34>)
	const struct spi_stm32_config *cfg = dev->config->config_info;
 80030ae:	689e      	ldr	r6, [r3, #8]
 80030b0:	f000 fa30 	bl	8003514 <z_impl_device_get_binding>
 80030b4:	6843      	ldr	r3, [r0, #4]
 80030b6:	4631      	mov	r1, r6
 80030b8:	681b      	ldr	r3, [r3, #0]
 80030ba:	4798      	blx	r3

	__ASSERT_NO_MSG(device_get_binding(STM32_CLOCK_CONTROL_NAME));

	if (clock_control_on(device_get_binding(STM32_CLOCK_CONTROL_NAME),
 80030bc:	4604      	mov	r4, r0
 80030be:	b938      	cbnz	r0, 80030d0 <spi_stm32_init+0x2c>
		LOG_ERR("Could not enable SPI clock");
		return -EIO;
	}

#ifdef CONFIG_SPI_STM32_INTERRUPT
	cfg->irq_config(dev);
 80030c0:	4628      	mov	r0, r5
 80030c2:	68f3      	ldr	r3, [r6, #12]
 80030c4:	4798      	blx	r3
#endif

	spi_context_unlock_unconditionally(&data->ctx);
 80030c6:	4638      	mov	r0, r7
 80030c8:	f001 ff9a 	bl	8005000 <spi_context_unlock_unconditionally>

	return 0;
}
 80030cc:	4620      	mov	r0, r4
 80030ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EIO;
 80030d0:	f06f 0404 	mvn.w	r4, #4
 80030d4:	e7fa      	b.n	80030cc <spi_stm32_init+0x28>
 80030d6:	bf00      	nop
 80030d8:	08005d41 	.word	0x08005d41

080030dc <spi_stm32_transceive>:
{
 80030dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80030e0:	461e      	mov	r6, r3
	const struct spi_stm32_config *cfg = DEV_CFG(dev);
 80030e2:	6803      	ldr	r3, [r0, #0]
{
 80030e4:	b08d      	sub	sp, #52	; 0x34
 80030e6:	4604      	mov	r4, r0
	SPI_TypeDef *spi = cfg->spi;
 80030e8:	689b      	ldr	r3, [r3, #8]
{
 80030ea:	4689      	mov	r9, r1
	struct spi_stm32_data *data = DEV_DATA(dev);
 80030ec:	6885      	ldr	r5, [r0, #8]
	if (!tx_bufs && !rx_bufs) {
 80030ee:	4690      	mov	r8, r2
	SPI_TypeDef *spi = cfg->spi;
 80030f0:	689f      	ldr	r7, [r3, #8]
	if (!tx_bufs && !rx_bufs) {
 80030f2:	b912      	cbnz	r2, 80030fa <spi_stm32_transceive+0x1e>
 80030f4:	2e00      	cmp	r6, #0
 80030f6:	f000 80e1 	beq.w	80032bc <spi_stm32_transceive+0x1e0>

static inline void spi_context_lock(struct spi_context *ctx,
				    bool asynchronous,
				    struct k_poll_signal *signal)
{
	k_sem_take(&ctx->lock, K_FOREVER);
 80030fa:	f105 0b04 	add.w	fp, r5, #4

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)

K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)

K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
 80030fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003102:	4658      	mov	r0, fp
 8003104:	f000 fd68 	bl	8003bd8 <z_impl_k_sem_take>
	const struct spi_stm32_config *cfg = DEV_CFG(dev);
 8003108:	6823      	ldr	r3, [r4, #0]
	const u32_t scaler[] = {
 800310a:	f8df c20c 	ldr.w	ip, [pc, #524]	; 8003318 <spi_stm32_transceive+0x23c>
	const struct spi_stm32_config *cfg = DEV_CFG(dev);
 800310e:	689b      	ldr	r3, [r3, #8]
	struct spi_stm32_data *data = DEV_DATA(dev);
 8003110:	f8d4 a008 	ldr.w	sl, [r4, #8]
	const u32_t scaler[] = {
 8003114:	ac04      	add	r4, sp, #16
	const struct spi_stm32_config *cfg = DEV_CFG(dev);
 8003116:	9301      	str	r3, [sp, #4]
	const u32_t scaler[] = {
 8003118:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800311c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800311e:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 8003122:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	if (spi_context_configured(&data->ctx, config)) {
 8003126:	f8da 3000 	ldr.w	r3, [sl]
 800312a:	4599      	cmp	r9, r3
 800312c:	d07c      	beq.n	8003228 <spi_stm32_transceive+0x14c>
	if ((SPI_WORD_SIZE_GET(config->operation) != 8)
 800312e:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8003132:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8003136:	2b08      	cmp	r3, #8
 8003138:	d002      	beq.n	8003140 <spi_stm32_transceive+0x64>
	    && (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 800313a:	2b10      	cmp	r3, #16
 800313c:	f040 80bc 	bne.w	80032b8 <spi_stm32_transceive+0x1dc>
	SPI_TypeDef *spi = cfg->spi;
 8003140:	9b01      	ldr	r3, [sp, #4]
 8003142:	4874      	ldr	r0, [pc, #464]	; (8003314 <spi_stm32_transceive+0x238>)
 8003144:	689c      	ldr	r4, [r3, #8]
 8003146:	f000 f9e5 	bl	8003514 <z_impl_device_get_binding>
		(const struct clock_control_driver_api *)dev->driver_api;

	__ASSERT(api->get_rate != NULL, "%s not implemented for device %s",
		__func__, dev->config->name);

	return api->get_rate(dev, sys, rate);
 800314a:	6843      	ldr	r3, [r0, #4]
 800314c:	aa03      	add	r2, sp, #12
 800314e:	9901      	ldr	r1, [sp, #4]
 8003150:	68db      	ldr	r3, [r3, #12]
 8003152:	4798      	blx	r3
		u32_t clk = clock >> br;
 8003154:	9a03      	ldr	r2, [sp, #12]
		if (clk <= config->frequency) {
 8003156:	f8d9 1000 	ldr.w	r1, [r9]
	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 800315a:	2301      	movs	r3, #1
		u32_t clk = clock >> br;
 800315c:	fa22 f003 	lsr.w	r0, r2, r3
		if (clk <= config->frequency) {
 8003160:	4288      	cmp	r0, r1
 8003162:	f240 80c0 	bls.w	80032e6 <spi_stm32_transceive+0x20a>
	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 8003166:	3301      	adds	r3, #1
 8003168:	2b09      	cmp	r3, #9
 800316a:	d1f7      	bne.n	800315c <spi_stm32_transceive+0x80>
		return -EINVAL;
 800316c:	f06f 0615 	mvn.w	r6, #21
 8003170:	e0a4      	b.n	80032bc <spi_stm32_transceive+0x1e0>
  *         @arg @ref LL_SPI_POLARITY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_SPI_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity)
{
  MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 8003172:	6822      	ldr	r2, [r4, #0]
 8003174:	f042 0202 	orr.w	r2, r2, #2
 8003178:	6022      	str	r2, [r4, #0]
	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 800317a:	0758      	lsls	r0, r3, #29
  MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 800317c:	6822      	ldr	r2, [r4, #0]
 800317e:	bf4c      	ite	mi
 8003180:	f042 0201 	orrmi.w	r2, r2, #1
 8003184:	f022 0201 	bicpl.w	r2, r2, #1
	if (config->operation & SPI_TRANSFER_LSB) {
 8003188:	06d9      	lsls	r1, r3, #27
 800318a:	6022      	str	r2, [r4, #0]
  *         @arg @ref LL_SPI_HALF_DUPLEX_TX
  * @retval None
  */
__STATIC_INLINE void LL_SPI_SetTransferDirection(SPI_TypeDef *SPIx, uint32_t TransferDirection)
{
  MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 800318c:	6822      	ldr	r2, [r4, #0]
 800318e:	f422 4244 	bic.w	r2, r2, #50176	; 0xc400
 8003192:	6022      	str	r2, [r4, #0]
  MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 8003194:	6822      	ldr	r2, [r4, #0]
 8003196:	bf4c      	ite	mi
 8003198:	f042 0280 	orrmi.w	r2, r2, #128	; 0x80
 800319c:	f022 0280 	bicpl.w	r2, r2, #128	; 0x80
	if (config->operation & SPI_OP_MODE_SLAVE) {
 80031a0:	f013 0101 	ands.w	r1, r3, #1
 80031a4:	6022      	str	r2, [r4, #0]
  * @param  SPIx SPI Instance
  * @retval None
  */
__STATIC_INLINE void LL_SPI_DisableCRC(SPI_TypeDef *SPIx)
{
  CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 80031a6:	6822      	ldr	r2, [r4, #0]
 80031a8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80031ac:	6022      	str	r2, [r4, #0]
  MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 80031ae:	6822      	ldr	r2, [r4, #0]
 80031b0:	bf14      	ite	ne
 80031b2:	f422 7282 	bicne.w	r2, r2, #260	; 0x104
 80031b6:	f442 7282 	orreq.w	r2, r2, #260	; 0x104
 80031ba:	6022      	str	r2, [r4, #0]
	if (config->cs) {
 80031bc:	f8d9 2008 	ldr.w	r2, [r9, #8]
 80031c0:	2a00      	cmp	r2, #0
 80031c2:	d06a      	beq.n	800329a <spi_stm32_transceive+0x1be>
  *         @arg @ref LL_SPI_NSS_HARD_OUTPUT
  * @retval None
  */
__STATIC_INLINE void LL_SPI_SetNSSMode(SPI_TypeDef *SPIx, uint32_t NSS)
{
  MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 80031c4:	6821      	ldr	r1, [r4, #0]
 80031c6:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 80031ca:	6021      	str	r1, [r4, #0]
  MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 80031cc:	6861      	ldr	r1, [r4, #4]
 80031ce:	f021 0104 	bic.w	r1, r1, #4
	if (SPI_WORD_SIZE_GET(config->operation) ==  8) {
 80031d2:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80031d6:	6061      	str	r1, [r4, #4]
 80031d8:	2b08      	cmp	r3, #8
  MODIFY_REG(SPIx->CR2, SPI_CR2_DS, DataWidth);
 80031da:	6863      	ldr	r3, [r4, #4]
 80031dc:	bf0a      	itet	eq
 80031de:	f423 6370 	biceq.w	r3, r3, #3840	; 0xf00
 80031e2:	f443 6370 	orrne.w	r3, r3, #3840	; 0xf00
 80031e6:	f443 63e0 	orreq.w	r3, r3, #1792	; 0x700
 80031ea:	6063      	str	r3, [r4, #4]
  MODIFY_REG(SPIx->CR2, SPI_CR2_FRXTH, Threshold);
 80031ec:	6863      	ldr	r3, [r4, #4]
 80031ee:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80031f2:	6063      	str	r3, [r4, #4]
  MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 80031f4:	6863      	ldr	r3, [r4, #4]
 80031f6:	f023 0310 	bic.w	r3, r3, #16
 80031fa:	6063      	str	r3, [r4, #4]
	data->ctx.config = config;
 80031fc:	f8ca 9000 	str.w	r9, [sl]
	return 1;
}

static inline void spi_context_cs_configure(struct spi_context *ctx)
{
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
 8003200:	b192      	cbz	r2, 8003228 <spi_stm32_transceive+0x14c>
 8003202:	6810      	ldr	r0, [r2, #0]
 8003204:	b180      	cbz	r0, 8003228 <spi_stm32_transceive+0x14c>
	return api->config(port, access_op, pin, flags);
 8003206:	6843      	ldr	r3, [r0, #4]
 8003208:	2100      	movs	r1, #0
 800320a:	6852      	ldr	r2, [r2, #4]
 800320c:	681c      	ldr	r4, [r3, #0]
 800320e:	2301      	movs	r3, #1
 8003210:	47a0      	blx	r4
		gpio_pin_configure(ctx->config->cs->gpio_dev,
				   ctx->config->cs->gpio_pin, GPIO_DIR_OUT);
		gpio_pin_write(ctx->config->cs->gpio_dev,
 8003212:	f8da 2000 	ldr.w	r2, [sl]
 8003216:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
 8003218:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
 800321c:	43d2      	mvns	r2, r2
 800321e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003222:	0fd2      	lsrs	r2, r2, #31
 8003224:	f001 feb9 	bl	8004f9a <gpio_pin_write>
			       const struct spi_buf_set *rx_bufs,
			       u8_t dfs)
{
	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);

	if (tx_bufs) {
 8003228:	f1b8 0f00 	cmp.w	r8, #0
 800322c:	d04a      	beq.n	80032c4 <spi_stm32_transceive+0x1e8>
		ctx->current_tx = tx_bufs->buffers;
 800322e:	f8d8 3000 	ldr.w	r3, [r8]
		ctx->tx_count = tx_bufs->count;
 8003232:	f8d8 2004 	ldr.w	r2, [r8, #4]
		ctx->current_tx = tx_bufs->buffers;
 8003236:	62ab      	str	r3, [r5, #40]	; 0x28
		ctx->tx_count = tx_bufs->count;
 8003238:	62ea      	str	r2, [r5, #44]	; 0x2c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 800323a:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
 800323c:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 800323e:	63aa      	str	r2, [r5, #56]	; 0x38
		ctx->tx_len = ctx->current_tx->len / dfs;
 8003240:	63eb      	str	r3, [r5, #60]	; 0x3c
		ctx->tx_count = 0;
		ctx->tx_buf = NULL;
		ctx->tx_len = 0;
	}

	if (rx_bufs) {
 8003242:	2e00      	cmp	r6, #0
 8003244:	d043      	beq.n	80032ce <spi_stm32_transceive+0x1f2>
		ctx->current_rx = rx_bufs->buffers;
 8003246:	6833      	ldr	r3, [r6, #0]
		ctx->rx_count = rx_bufs->count;
 8003248:	6872      	ldr	r2, [r6, #4]
		ctx->current_rx = rx_bufs->buffers;
 800324a:	632b      	str	r3, [r5, #48]	; 0x30
		ctx->rx_count = rx_bufs->count;
 800324c:	636a      	str	r2, [r5, #52]	; 0x34
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 800324e:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
 8003250:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 8003252:	642a      	str	r2, [r5, #64]	; 0x40
		ctx->rx_len = ctx->current_rx->len / dfs;
 8003254:	646b      	str	r3, [r5, #68]	; 0x44
		ctx->rx_count = 0;
		ctx->rx_buf = NULL;
		ctx->rx_len = 0;
	}

	ctx->sync_status = 0;
 8003256:	2300      	movs	r3, #0
 8003258:	626b      	str	r3, [r5, #36]	; 0x24
  * @param  SPIx SPI Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx)
{
  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 800325a:	68ba      	ldr	r2, [r7, #8]
 800325c:	f012 0201 	ands.w	r2, r2, #1
 8003260:	d13a      	bne.n	80032d8 <spi_stm32_transceive+0x1fc>
  SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 8003262:	683b      	ldr	r3, [r7, #0]
	_spi_context_cs_control(ctx, on, false);
 8003264:	2101      	movs	r1, #1
 8003266:	4628      	mov	r0, r5
 8003268:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800326c:	603b      	str	r3, [r7, #0]
 800326e:	f001 fe9d 	bl	8004fac <_spi_context_cs_control.isra.6>
  * @param  SPIx SPI Instance
  * @retval None
  */
__STATIC_INLINE void LL_SPI_EnableIT_ERR(SPI_TypeDef *SPIx)
{
  SET_BIT(SPIx->CR2, SPI_CR2_ERRIE);
 8003272:	687b      	ldr	r3, [r7, #4]
 8003274:	f043 0320 	orr.w	r3, r3, #32
 8003278:	607b      	str	r3, [r7, #4]
	if (rx_bufs) {
 800327a:	bb7e      	cbnz	r6, 80032dc <spi_stm32_transceive+0x200>
  * @param  SPIx SPI Instance
  * @retval None
  */
__STATIC_INLINE void LL_SPI_EnableIT_TXE(SPI_TypeDef *SPIx)
{
  SET_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 800327c:	687b      	ldr	r3, [r7, #4]
 800327e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003282:	f105 0014 	add.w	r0, r5, #20
 8003286:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800328a:	607b      	str	r3, [r7, #4]
 800328c:	f000 fca4 	bl	8003bd8 <z_impl_k_sem_take>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
 8003290:	4658      	mov	r0, fp
	status = ctx->sync_status;
 8003292:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 8003294:	f000 fc7a 	bl	8003b8c <z_impl_k_sem_give>
	return ret;
 8003298:	e010      	b.n	80032bc <spi_stm32_transceive+0x1e0>
		if (config->operation & SPI_OP_MODE_SLAVE) {
 800329a:	b119      	cbz	r1, 80032a4 <spi_stm32_transceive+0x1c8>
  MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 800329c:	6821      	ldr	r1, [r4, #0]
 800329e:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 80032a2:	e792      	b.n	80031ca <spi_stm32_transceive+0xee>
 80032a4:	6821      	ldr	r1, [r4, #0]
 80032a6:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 80032aa:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 80032ae:	6021      	str	r1, [r4, #0]
  MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 80032b0:	6861      	ldr	r1, [r4, #4]
 80032b2:	f041 0104 	orr.w	r1, r1, #4
 80032b6:	e78c      	b.n	80031d2 <spi_stm32_transceive+0xf6>
		return -ENOTSUP;
 80032b8:	f06f 0622 	mvn.w	r6, #34	; 0x22
}
 80032bc:	4630      	mov	r0, r6
 80032be:	b00d      	add	sp, #52	; 0x34
 80032c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ctx->tx_count = 0;
 80032c4:	e9c5 880a 	strd	r8, r8, [r5, #40]	; 0x28
		ctx->tx_len = 0;
 80032c8:	e9c5 880e 	strd	r8, r8, [r5, #56]	; 0x38
 80032cc:	e7b9      	b.n	8003242 <spi_stm32_transceive+0x166>
		ctx->rx_count = 0;
 80032ce:	e9c5 660c 	strd	r6, r6, [r5, #48]	; 0x30
		ctx->rx_len = 0;
 80032d2:	e9c5 6610 	strd	r6, r6, [r5, #64]	; 0x40
 80032d6:	e7be      	b.n	8003256 <spi_stm32_transceive+0x17a>
  * @param  SPIx SPI Instance
  * @retval RxData Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_SPI_ReceiveData8(SPI_TypeDef *SPIx)
{
  return (uint8_t)(READ_REG(SPIx->DR));
 80032d8:	68fb      	ldr	r3, [r7, #12]
 80032da:	e7be      	b.n	800325a <spi_stm32_transceive+0x17e>
  SET_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
 80032dc:	687b      	ldr	r3, [r7, #4]
 80032de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80032e2:	607b      	str	r3, [r7, #4]
 80032e4:	e7ca      	b.n	800327c <spi_stm32_transceive+0x1a0>
  CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 80032e6:	6822      	ldr	r2, [r4, #0]
	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 80032e8:	a90c      	add	r1, sp, #48	; 0x30
 80032ea:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80032ee:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80032f2:	6022      	str	r2, [r4, #0]
  MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 80032f4:	6822      	ldr	r2, [r4, #0]
 80032f6:	f853 3c24 	ldr.w	r3, [r3, #-36]
 80032fa:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 80032fe:	4313      	orrs	r3, r2
 8003300:	6023      	str	r3, [r4, #0]
	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 8003302:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8003306:	079a      	lsls	r2, r3, #30
 8003308:	f53f af33 	bmi.w	8003172 <spi_stm32_transceive+0x96>
  MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 800330c:	6822      	ldr	r2, [r4, #0]
 800330e:	f022 0202 	bic.w	r2, r2, #2
 8003312:	e731      	b.n	8003178 <spi_stm32_transceive+0x9c>
 8003314:	08005d41 	.word	0x08005d41
 8003318:	08005adc 	.word	0x08005adc

0800331c <uart_stm32_configure>:
	return UART_CFG_PARITY_NONE;
}

static int uart_stm32_configure(struct device *dev,
				const struct uart_config *cfg)
{
 800331c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct uart_stm32_data *data = DEV_DATA(dev);
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 8003320:	6803      	ldr	r3, [r0, #0]
{
 8003322:	460d      	mov	r5, r1
	const u32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8003324:	790a      	ldrb	r2, [r1, #4]
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 8003326:	689b      	ldr	r3, [r3, #8]
	switch (parity) {
 8003328:	2a01      	cmp	r2, #1
	struct uart_stm32_data *data = DEV_DATA(dev);
 800332a:	6886      	ldr	r6, [r0, #8]
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 800332c:	681c      	ldr	r4, [r3, #0]
	switch (parity) {
 800332e:	f000 8089 	beq.w	8003444 <uart_stm32_configure+0x128>
		return LL_USART_PARITY_NONE;
 8003332:	2a02      	cmp	r2, #2
 8003334:	bf0c      	ite	eq
 8003336:	f44f 6180 	moveq.w	r1, #1024	; 0x400
 800333a:	2100      	movne	r1, #0
	const u32_t stopbits = uart_stm32_cfg2ll_stopbits(cfg->stop_bits);
 800333c:	f895 9005 	ldrb.w	r9, [r5, #5]
	const u32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits);
 8003340:	f895 8006 	ldrb.w	r8, [r5, #6]
 8003344:	f1b9 0f02 	cmp.w	r9, #2
 8003348:	bf96      	itet	ls
 800334a:	4b43      	ldrls	r3, [pc, #268]	; (8003458 <uart_stm32_configure+0x13c>)
	const u32_t stopbits = uart_stm32_cfg2ll_stopbits(cfg->stop_bits);
 800334c:	f44f 5e00 	movhi.w	lr, #8192	; 0x2000
 8003350:	f833 e019 	ldrhls.w	lr, [r3, r9, lsl #1]
	switch (db) {
 8003354:	f1b8 0f02 	cmp.w	r8, #2
 8003358:	d077      	beq.n	800344a <uart_stm32_configure+0x12e>
		return LL_USART_DATAWIDTH_8B;
 800335a:	f1b8 0f04 	cmp.w	r8, #4
 800335e:	bf0c      	ite	eq
 8003360:	f44f 5380 	moveq.w	r3, #4096	; 0x1000
 8003364:	2300      	movne	r3, #0
	const u32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 8003366:	79ef      	ldrb	r7, [r5, #7]

	/* Hardware doesn't support mark or space parity */
	if ((UART_CFG_PARITY_MARK == cfg->parity) ||
 8003368:	3a03      	subs	r2, #3
		return LL_USART_HWCONTROL_RTS_CTS;
 800336a:	2f01      	cmp	r7, #1
 800336c:	bf14      	ite	ne
 800336e:	f04f 0c00 	movne.w	ip, #0
 8003372:	f44f 7c40 	moveq.w	ip, #768	; 0x300
	if ((UART_CFG_PARITY_MARK == cfg->parity) ||
 8003376:	2a01      	cmp	r2, #1
 8003378:	d96a      	bls.n	8003450 <uart_stm32_configure+0x134>
	if (IS_LPUART_INSTANCE(UartInstance) &&
	    UART_CFG_STOP_BITS_0_5 == cfg->stop_bits) {
		return -ENOTSUP;
	}
#else
	if (UART_CFG_STOP_BITS_0_5 == cfg->stop_bits) {
 800337a:	f019 0ffd 	tst.w	r9, #253	; 0xfd
 800337e:	d067      	beq.n	8003450 <uart_stm32_configure+0x134>
		return -ENOTSUP;
	}
#endif

	/* Driver doesn't support 5 or 6 databits and potentially 7 or 9 */
	if ((UART_CFG_DATA_BITS_5 == cfg->data_bits) ||
 8003380:	f1b8 0f01 	cmp.w	r8, #1
 8003384:	d964      	bls.n	8003450 <uart_stm32_configure+0x134>
		) {
		return -ENOTSUP;
	}

	/* Driver supports only RTS CTS flow control */
	if (UART_CFG_FLOW_CTRL_NONE != cfg->flow_ctrl) {
 8003386:	b307      	cbz	r7, 80033ca <uart_stm32_configure+0xae>
		if (!IS_UART_HWFLOW_INSTANCE(UartInstance) ||
 8003388:	4a34      	ldr	r2, [pc, #208]	; (800345c <uart_stm32_configure+0x140>)
 800338a:	4294      	cmp	r4, r2
 800338c:	d01b      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 800338e:	f5a2 424c 	sub.w	r2, r2, #52224	; 0xcc00
 8003392:	4294      	cmp	r4, r2
 8003394:	d017      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 8003396:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800339a:	4294      	cmp	r4, r2
 800339c:	d013      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 800339e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80033a2:	4294      	cmp	r4, r2
 80033a4:	d00f      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 80033a6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80033aa:	4294      	cmp	r4, r2
 80033ac:	d00b      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 80033ae:	f502 4244 	add.w	r2, r2, #50176	; 0xc400
 80033b2:	4294      	cmp	r4, r2
 80033b4:	d007      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 80033b6:	f5a2 421c 	sub.w	r2, r2, #39936	; 0x9c00
 80033ba:	4294      	cmp	r4, r2
 80033bc:	d003      	beq.n	80033c6 <uart_stm32_configure+0xaa>
 80033be:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80033c2:	4294      	cmp	r4, r2
 80033c4:	d144      	bne.n	8003450 <uart_stm32_configure+0x134>
 80033c6:	2f01      	cmp	r7, #1
 80033c8:	d142      	bne.n	8003450 <uart_stm32_configure+0x134>
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_Disable(USART_TypeDef *USARTx)
{
  CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 80033ca:	6822      	ldr	r2, [r4, #0]
 80033cc:	f022 0201 	bic.w	r2, r2, #1
 80033d0:	6022      	str	r2, [r4, #0]
  *         @arg @ref LL_USART_PARITY_EVEN
  *         @arg @ref LL_USART_PARITY_ODD
  */
__STATIC_INLINE uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
{
  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 80033d2:	6822      	ldr	r2, [r4, #0]
 80033d4:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
		}
	}

	LL_USART_Disable(UartInstance);

	if (parity != uart_stm32_get_parity(dev)) {
 80033d8:	4291      	cmp	r1, r2
 80033da:	d004      	beq.n	80033e6 <uart_stm32_configure+0xca>
  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 80033dc:	6827      	ldr	r7, [r4, #0]
 80033de:	f427 67c0 	bic.w	r7, r7, #1536	; 0x600
 80033e2:	430f      	orrs	r7, r1
 80033e4:	6027      	str	r7, [r4, #0]
  *         @arg @ref LL_USART_STOPBITS_1_5
  *         @arg @ref LL_USART_STOPBITS_2
  */
__STATIC_INLINE uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
{
  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 80033e6:	6862      	ldr	r2, [r4, #4]
 80033e8:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
		uart_stm32_set_parity(dev, parity);
	}

	if (stopbits != uart_stm32_get_stopbits(dev)) {
 80033ec:	4596      	cmp	lr, r2
 80033ee:	d005      	beq.n	80033fc <uart_stm32_configure+0xe0>
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 80033f0:	6861      	ldr	r1, [r4, #4]
 80033f2:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 80033f6:	ea41 010e 	orr.w	r1, r1, lr
 80033fa:	6061      	str	r1, [r4, #4]
  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 80033fc:	6822      	ldr	r2, [r4, #0]
 80033fe:	f002 2210 	and.w	r2, r2, #268439552	; 0x10001000
		uart_stm32_set_stopbits(dev, stopbits);
	}

	if (databits != uart_stm32_get_databits(dev)) {
 8003402:	4293      	cmp	r3, r2
 8003404:	d004      	beq.n	8003410 <uart_stm32_configure+0xf4>
  MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 8003406:	6822      	ldr	r2, [r4, #0]
 8003408:	f022 2210 	bic.w	r2, r2, #268439552	; 0x10001000
 800340c:	431a      	orrs	r2, r3
 800340e:	6022      	str	r2, [r4, #0]
  *         @arg @ref LL_USART_HWCONTROL_CTS
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  */
__STATIC_INLINE uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
{
  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 8003410:	68a3      	ldr	r3, [r4, #8]
 8003412:	f403 7340 	and.w	r3, r3, #768	; 0x300
		uart_stm32_set_databits(dev, databits);
	}

	if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 8003416:	459c      	cmp	ip, r3
 8003418:	d005      	beq.n	8003426 <uart_stm32_configure+0x10a>
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 800341a:	68a3      	ldr	r3, [r4, #8]
 800341c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003420:	ea43 030c 	orr.w	r3, r3, ip
 8003424:	60a3      	str	r3, [r4, #8]
		uart_stm32_set_hwctrl(dev, flowctrl);
	}

	if (cfg->baudrate != data->baud_rate) {
 8003426:	6829      	ldr	r1, [r5, #0]
 8003428:	6833      	ldr	r3, [r6, #0]
 800342a:	4299      	cmp	r1, r3
 800342c:	d003      	beq.n	8003436 <uart_stm32_configure+0x11a>
		uart_stm32_set_baudrate(dev, cfg->baudrate);
 800342e:	f001 ff31 	bl	8005294 <uart_stm32_set_baudrate>
		data->baud_rate = cfg->baudrate;
 8003432:	682b      	ldr	r3, [r5, #0]
 8003434:	6033      	str	r3, [r6, #0]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8003436:	6823      	ldr	r3, [r4, #0]
	}

	LL_USART_Enable(UartInstance);
	return 0;
 8003438:	2000      	movs	r0, #0
 800343a:	f043 0301 	orr.w	r3, r3, #1
 800343e:	6023      	str	r3, [r4, #0]
};
 8003440:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return LL_USART_PARITY_ODD;
 8003444:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8003448:	e778      	b.n	800333c <uart_stm32_configure+0x20>
		return LL_USART_DATAWIDTH_7B;
 800344a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800344e:	e78a      	b.n	8003366 <uart_stm32_configure+0x4a>
		return -ENOTSUP;
 8003450:	f06f 0022 	mvn.w	r0, #34	; 0x22
 8003454:	e7f4      	b.n	8003440 <uart_stm32_configure+0x124>
 8003456:	bf00      	nop
 8003458:	08005ca4 	.word	0x08005ca4
 800345c:	40011000 	.word	0x40011000

08003460 <uart_stm32_init>:
 *
 * @return 0
 */
static int uart_stm32_init(struct device *dev)
{
	const struct uart_stm32_config *config = DEV_CFG(dev);
 8003460:	6803      	ldr	r3, [r0, #0]
{
 8003462:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct uart_stm32_config *config = DEV_CFG(dev);
 8003466:	f8d3 8008 	ldr.w	r8, [r3, #8]
{
 800346a:	4605      	mov	r5, r0
	struct uart_stm32_data *data = DEV_DATA(dev);
 800346c:	6887      	ldr	r7, [r0, #8]
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 800346e:	4646      	mov	r6, r8
 8003470:	481c      	ldr	r0, [pc, #112]	; (80034e4 <uart_stm32_init+0x84>)
 8003472:	f856 4b08 	ldr.w	r4, [r6], #8
 8003476:	f000 f84d 	bl	8003514 <z_impl_device_get_binding>
	return api->on(dev, sys);
 800347a:	6843      	ldr	r3, [r0, #4]
 800347c:	4631      	mov	r1, r6
	data->clock = clk;
 800347e:	6078      	str	r0, [r7, #4]
 8003480:	681b      	ldr	r3, [r3, #0]
 8003482:	4798      	blx	r3

	__uart_stm32_get_clock(dev);
	/* enable clock */
	if (clock_control_on(data->clock,
 8003484:	4606      	mov	r6, r0
 8003486:	bb48      	cbnz	r0, 80034dc <uart_stm32_init+0x7c>
  CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8003488:	6823      	ldr	r3, [r4, #0]
 800348a:	f023 0301 	bic.w	r3, r3, #1
 800348e:	6023      	str	r3, [r4, #0]
  MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8003490:	6823      	ldr	r3, [r4, #0]
 8003492:	f043 030c 	orr.w	r3, r3, #12
 8003496:	6023      	str	r3, [r4, #0]
  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 8003498:	6823      	ldr	r3, [r4, #0]
 800349a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800349e:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 80034a2:	6023      	str	r3, [r4, #0]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 80034a4:	6863      	ldr	r3, [r4, #4]
 80034a6:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80034aa:	6063      	str	r3, [r4, #4]
	LL_USART_ConfigCharacter(UartInstance,
				 LL_USART_DATAWIDTH_8B,
				 LL_USART_PARITY_NONE,
				 LL_USART_STOPBITS_1);

	if (config->hw_flow_control) {
 80034ac:	f898 3010 	ldrb.w	r3, [r8, #16]
 80034b0:	b133      	cbz	r3, 80034c0 <uart_stm32_init+0x60>
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 80034b2:	682b      	ldr	r3, [r5, #0]
 80034b4:	689b      	ldr	r3, [r3, #8]
 80034b6:	681a      	ldr	r2, [r3, #0]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80034b8:	6893      	ldr	r3, [r2, #8]
 80034ba:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 80034be:	6093      	str	r3, [r2, #8]
		uart_stm32_set_hwctrl(dev, LL_USART_HWCONTROL_RTS_CTS);
	}

	/* Set the default baudrate */
	uart_stm32_set_baudrate(dev, data->baud_rate);
 80034c0:	6839      	ldr	r1, [r7, #0]
 80034c2:	4628      	mov	r0, r5
 80034c4:	f001 fee6 	bl	8005294 <uart_stm32_set_baudrate>
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 80034c8:	6823      	ldr	r3, [r4, #0]
 80034ca:	f043 0301 	orr.w	r3, r3, #1
 80034ce:	6023      	str	r3, [r4, #0]
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 80034d0:	69e3      	ldr	r3, [r4, #28]
 80034d2:	029b      	lsls	r3, r3, #10
 80034d4:	d5fc      	bpl.n	80034d0 <uart_stm32_init+0x70>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->uconf.irq_config_func(dev);
#endif
	return 0;
}
 80034d6:	4630      	mov	r0, r6
 80034d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EIO;
 80034dc:	f06f 0604 	mvn.w	r6, #4
 80034e0:	e7f9      	b.n	80034d6 <uart_stm32_init+0x76>
 80034e2:	bf00      	nop
 80034e4:	08005d41 	.word	0x08005d41

080034e8 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
 80034e8:	4b09      	ldr	r3, [pc, #36]	; (8003510 <z_sys_device_do_config_level+0x28>)
{
 80034ea:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
 80034ec:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 80034f0:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
 80034f2:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
 80034f4:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
 80034f8:	42a5      	cmp	r5, r4
 80034fa:	d800      	bhi.n	80034fe <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
 80034fc:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
 80034fe:	6823      	ldr	r3, [r4, #0]
 8003500:	4620      	mov	r0, r4
 8003502:	685b      	ldr	r3, [r3, #4]
 8003504:	4798      	blx	r3
		if (retval != 0) {
 8003506:	b100      	cbz	r0, 800350a <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
 8003508:	6066      	str	r6, [r4, #4]
								info++) {
 800350a:	340c      	adds	r4, #12
 800350c:	e7f4      	b.n	80034f8 <z_sys_device_do_config_level+0x10>
 800350e:	bf00      	nop
 8003510:	08005c88 	.word	0x08005c88

08003514 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
 8003514:	4b10      	ldr	r3, [pc, #64]	; (8003558 <z_impl_device_get_binding+0x44>)
{
 8003516:	b570      	push	{r4, r5, r6, lr}
 8003518:	4605      	mov	r5, r0
	for (info = __device_init_start; info != __device_init_end; info++) {
 800351a:	4c10      	ldr	r4, [pc, #64]	; (800355c <z_impl_device_get_binding+0x48>)
 800351c:	461e      	mov	r6, r3
 800351e:	429c      	cmp	r4, r3
 8003520:	d104      	bne.n	800352c <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
 8003522:	4c0e      	ldr	r4, [pc, #56]	; (800355c <z_impl_device_get_binding+0x48>)
 8003524:	42b4      	cmp	r4, r6
 8003526:	d109      	bne.n	800353c <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
 8003528:	2400      	movs	r4, #0
 800352a:	e012      	b.n	8003552 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
 800352c:	6862      	ldr	r2, [r4, #4]
 800352e:	b11a      	cbz	r2, 8003538 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
 8003530:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
 8003532:	6812      	ldr	r2, [r2, #0]
 8003534:	42aa      	cmp	r2, r5
 8003536:	d00c      	beq.n	8003552 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
 8003538:	340c      	adds	r4, #12
 800353a:	e7f0      	b.n	800351e <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
 800353c:	6863      	ldr	r3, [r4, #4]
 800353e:	b90b      	cbnz	r3, 8003544 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
 8003540:	340c      	adds	r4, #12
 8003542:	e7ef      	b.n	8003524 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
 8003544:	6823      	ldr	r3, [r4, #0]
 8003546:	4628      	mov	r0, r5
 8003548:	6819      	ldr	r1, [r3, #0]
 800354a:	f001 fb81 	bl	8004c50 <strcmp>
 800354e:	2800      	cmp	r0, #0
 8003550:	d1f6      	bne.n	8003540 <z_impl_device_get_binding+0x2c>
}
 8003552:	4620      	mov	r0, r4
 8003554:	bd70      	pop	{r4, r5, r6, pc}
 8003556:	bf00      	nop
 8003558:	20021440 	.word	0x20021440
 800355c:	20021344 	.word	0x20021344

08003560 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
 8003560:	4802      	ldr	r0, [pc, #8]	; (800356c <z_bss_zero+0xc>)
 8003562:	2100      	movs	r1, #0
 8003564:	4a02      	ldr	r2, [pc, #8]	; (8003570 <z_bss_zero+0x10>)
 8003566:	1a12      	subs	r2, r2, r0
 8003568:	f001 bba8 	b.w	8004cbc <memset>
 800356c:	20020000 	.word	0x20020000
 8003570:	2002056c 	.word	0x2002056c

08003574 <z_data_copy>:
 * @return N/A
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
 8003574:	4806      	ldr	r0, [pc, #24]	; (8003590 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
 8003576:	4a07      	ldr	r2, [pc, #28]	; (8003594 <z_data_copy+0x20>)
 8003578:	4907      	ldr	r1, [pc, #28]	; (8003598 <z_data_copy+0x24>)
 800357a:	1a12      	subs	r2, r2, r0
{
 800357c:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
 800357e:	f001 fb73 	bl	8004c68 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
 8003582:	4a06      	ldr	r2, [pc, #24]	; (800359c <z_data_copy+0x28>)
 8003584:	4906      	ldr	r1, [pc, #24]	; (80035a0 <z_data_copy+0x2c>)
 8003586:	4807      	ldr	r0, [pc, #28]	; (80035a4 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 8003588:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
 800358c:	f001 bb6c 	b.w	8004c68 <memcpy>
 8003590:	200212b0 	.word	0x200212b0
 8003594:	20021454 	.word	0x20021454
 8003598:	08007f18 	.word	0x08007f18
 800359c:	00000000 	.word	0x00000000
 80035a0:	08007f18 	.word	0x08007f18
 80035a4:	20020000 	.word	0x20020000

080035a8 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 80035a8:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
 80035aa:	2002      	movs	r0, #2
 80035ac:	f7ff ff9c 	bl	80034e8 <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
 80035b0:	4807      	ldr	r0, [pc, #28]	; (80035d0 <bg_thread_main+0x28>)
 80035b2:	f000 fee6 	bl	8004382 <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
 80035b6:	2003      	movs	r0, #3
 80035b8:	f7ff ff96 	bl	80034e8 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
 80035bc:	f000 fb9a 	bl	8003cf4 <z_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
 80035c0:	f7fc ff8e 	bl	80004e0 <main>

	/* Mark nonessenrial since main() has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
 80035c4:	4a03      	ldr	r2, [pc, #12]	; (80035d4 <bg_thread_main+0x2c>)
 80035c6:	7b13      	ldrb	r3, [r2, #12]
 80035c8:	f023 0301 	bic.w	r3, r3, #1
 80035cc:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 80035ce:	bd08      	pop	{r3, pc}
 80035d0:	08007ec6 	.word	0x08007ec6
 80035d4:	200204cc 	.word	0x200204cc

080035d8 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
 80035d8:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_InterruptStackSetup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
 80035da:	4b3a      	ldr	r3, [pc, #232]	; (80036c4 <z_cstart+0xec>)
 80035dc:	b0a0      	sub	sp, #128	; 0x80
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 80035de:	f383 8808 	msr	MSP, r3
 80035e2:	4d39      	ldr	r5, [pc, #228]	; (80036c8 <z_cstart+0xf0>)
 80035e4:	2400      	movs	r4, #0
 80035e6:	23f0      	movs	r3, #240	; 0xf0
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
 80035e8:	4e38      	ldr	r6, [pc, #224]	; (80036cc <z_cstart+0xf4>)
	struct k_thread dummy_thread = {
 80035ea:	2701      	movs	r7, #1
 80035ec:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 80035f0:	77ec      	strb	r4, [r5, #31]
 80035f2:	762c      	strb	r4, [r5, #24]
 80035f4:	766c      	strb	r4, [r5, #25]
 80035f6:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 80035f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80035fa:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 80035fe:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void kernel_arch_init(void)
{
	z_InterruptStackSetup();
	z_ExcSetup();
	z_FaultInit();
 8003600:	f7ff fb68 	bl	8002cd4 <z_FaultInit>
	z_CpuIdleInit();
 8003604:	f7ff fbb8 	bl	8002d78 <z_CpuIdleInit>
static ALWAYS_INLINE void z_clearfaults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 8003608:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800360c:	4621      	mov	r1, r4
 800360e:	2264      	movs	r2, #100	; 0x64
 8003610:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 8003612:	62eb      	str	r3, [r5, #44]	; 0x2c
 8003614:	ab07      	add	r3, sp, #28
	_kernel.ready_q.cache = _main_thread;
 8003616:	4d2e      	ldr	r5, [pc, #184]	; (80036d0 <z_cstart+0xf8>)
	struct k_thread dummy_thread = {
 8003618:	4618      	mov	r0, r3
 800361a:	f001 fb4f 	bl	8004cbc <memset>
	_current = &dummy_thread;
 800361e:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 8003620:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
 8003622:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 8003626:	f7ff ff5f 	bl	80034e8 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 800362a:	4638      	mov	r0, r7
 800362c:	f7ff ff5c 	bl	80034e8 <z_sys_device_do_config_level>
	z_sched_init();
 8003630:	f000 fa50 	bl	8003ad4 <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
 8003634:	4b27      	ldr	r3, [pc, #156]	; (80036d4 <z_cstart+0xfc>)
	_kernel.ready_q.cache = _main_thread;
 8003636:	6235      	str	r5, [r6, #32]
	z_setup_new_thread(_main_thread, _main_stack,
 8003638:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800363c:	4926      	ldr	r1, [pc, #152]	; (80036d8 <z_cstart+0x100>)
 800363e:	4628      	mov	r0, r5
 8003640:	e9cd 7304 	strd	r7, r3, [sp, #16]
 8003644:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8003648:	e9cd 4400 	strd	r4, r4, [sp]
 800364c:	4b23      	ldr	r3, [pc, #140]	; (80036dc <z_cstart+0x104>)
 800364e:	4634      	mov	r4, r6
 8003650:	f000 fb38 	bl	8003cc4 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 8003654:	7b6b      	ldrb	r3, [r5, #13]
 8003656:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 800365a:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
 800365e:	736a      	strb	r2, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 8003660:	d104      	bne.n	800366c <z_cstart+0x94>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
 8003662:	69ab      	ldr	r3, [r5, #24]
 8003664:	b913      	cbnz	r3, 800366c <z_cstart+0x94>
		z_add_thread_to_ready_q(thread);
 8003666:	4628      	mov	r0, r5
 8003668:	f000 f8ec 	bl	8003844 <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
 800366c:	4b1c      	ldr	r3, [pc, #112]	; (80036e0 <z_cstart+0x108>)
 800366e:	2201      	movs	r2, #1
 8003670:	4e1c      	ldr	r6, [pc, #112]	; (80036e4 <z_cstart+0x10c>)
 8003672:	9305      	str	r3, [sp, #20]
 8003674:	230f      	movs	r3, #15
 8003676:	491c      	ldr	r1, [pc, #112]	; (80036e8 <z_cstart+0x110>)
 8003678:	4630      	mov	r0, r6
 800367a:	e9cd 3203 	strd	r3, r2, [sp, #12]
 800367e:	2300      	movs	r3, #0
 8003680:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8003684:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8003688:	9300      	str	r3, [sp, #0]
 800368a:	4b18      	ldr	r3, [pc, #96]	; (80036ec <z_cstart+0x114>)
 800368c:	f000 fb1a 	bl	8003cc4 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 8003690:	7b73      	ldrb	r3, [r6, #13]
	_kernel.cpus[0].idle_thread = _idle_thread;
 8003692:	60e6      	str	r6, [r4, #12]
 8003694:	f023 0304 	bic.w	r3, r3, #4
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
 8003698:	60a5      	str	r5, [r4, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
 800369a:	4a15      	ldr	r2, [pc, #84]	; (80036f0 <z_cstart+0x118>)
 800369c:	7373      	strb	r3, [r6, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 800369e:	4b15      	ldr	r3, [pc, #84]	; (80036f4 <z_cstart+0x11c>)
	list->tail = (sys_dnode_t *)list;
 80036a0:	e9c4 3306 	strd	r3, r3, [r4, #24]
 80036a4:	4b0d      	ldr	r3, [pc, #52]	; (80036dc <z_cstart+0x104>)
 80036a6:	4618      	mov	r0, r3
 80036a8:	f382 8809 	msr	PSP, r2
 80036ac:	b663      	cpsie	if
 80036ae:	f04f 0100 	mov.w	r1, #0
 80036b2:	f381 8811 	msr	BASEPRI, r1
 80036b6:	f3bf 8f6f 	isb	sy
 80036ba:	2100      	movs	r1, #0
 80036bc:	2200      	movs	r2, #0
 80036be:	2300      	movs	r3, #0
 80036c0:	f000 fcd5 	bl	800406e <z_thread_entry>
	"bl z_thread_entry \n\t"   /* z_thread_entry(_main, 0, 0, 0); */
	:
	: "r" (_main), "r" (start_of_main_stack)
	);

	CODE_UNREACHABLE;
 80036c4:	200212b0 	.word	0x200212b0
 80036c8:	e000ed00 	.word	0xe000ed00
 80036cc:	20020530 	.word	0x20020530
 80036d0:	200204cc 	.word	0x200204cc
 80036d4:	08007f0d 	.word	0x08007f0d
 80036d8:	20020570 	.word	0x20020570
 80036dc:	080035a9 	.word	0x080035a9
 80036e0:	08007f12 	.word	0x08007f12
 80036e4:	20020468 	.word	0x20020468
 80036e8:	20020970 	.word	0x20020970
 80036ec:	08005635 	.word	0x08005635
 80036f0:	20020970 	.word	0x20020970
 80036f4:	20020548 	.word	0x20020548

080036f8 <reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

static void reset_time_slice(void)
{
 80036f8:	b508      	push	{r3, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 80036fa:	f7fd fd45 	bl	8001188 <z_clock_elapsed>
 80036fe:	4b05      	ldr	r3, [pc, #20]	; (8003714 <reset_time_slice+0x1c>)
 8003700:	4a05      	ldr	r2, [pc, #20]	; (8003718 <reset_time_slice+0x20>)

	z_set_timeout_expiry(slice_time, false);
 8003702:	2100      	movs	r1, #0
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 8003704:	681b      	ldr	r3, [r3, #0]
 8003706:	4418      	add	r0, r3
 8003708:	6110      	str	r0, [r2, #16]
	z_set_timeout_expiry(slice_time, false);
 800370a:	4618      	mov	r0, r3
}
 800370c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_set_timeout_expiry(slice_time, false);
 8003710:	f001 bf65 	b.w	80055de <z_set_timeout_expiry>
 8003714:	20020564 	.word	0x20020564
 8003718:	20020530 	.word	0x20020530

0800371c <resched.part.15>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800371c:	f3ef 8005 	mrs	r0, IPSR
		|| (vector && !(SCB->ICSR & SCB_ICSR_RETTOBASE_Msk))
 8003720:	280d      	cmp	r0, #13
 8003722:	d809      	bhi.n	8003738 <resched.part.15+0x1c>
 8003724:	b128      	cbz	r0, 8003732 <resched.part.15+0x16>
 8003726:	4b05      	ldr	r3, [pc, #20]	; (800373c <resched.part.15+0x20>)
 8003728:	6858      	ldr	r0, [r3, #4]
 800372a:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 800372e:	f3c0 20c0 	ubfx	r0, r0, #11, #1
	}
	_current_cpu->swap_ok = 0;
#endif

	return z_arch_irq_unlocked(key) && !z_is_in_isr();
}
 8003732:	f080 0001 	eor.w	r0, r0, #1
 8003736:	4770      	bx	lr
 8003738:	2001      	movs	r0, #1
 800373a:	e7fa      	b.n	8003732 <resched.part.15+0x16>
 800373c:	e000ed00 	.word	0xe000ed00

08003740 <k_sched_time_slice_set>:
{
 8003740:	b510      	push	{r4, lr}
 8003742:	f04f 0310 	mov.w	r3, #16
 8003746:	f3ef 8411 	mrs	r4, BASEPRI
 800374a:	f383 8811 	msr	BASEPRI, r3
 800374e:	f3bf 8f6f 	isb	sy
		_current_cpu->slice_ticks = 0;
 8003752:	2200      	movs	r2, #0
 8003754:	4b06      	ldr	r3, [pc, #24]	; (8003770 <k_sched_time_slice_set+0x30>)
 8003756:	611a      	str	r2, [r3, #16]
		slice_time = z_ms_to_ticks(slice);
 8003758:	4b06      	ldr	r3, [pc, #24]	; (8003774 <k_sched_time_slice_set+0x34>)
 800375a:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
 800375c:	4b06      	ldr	r3, [pc, #24]	; (8003778 <k_sched_time_slice_set+0x38>)
 800375e:	6019      	str	r1, [r3, #0]
		reset_time_slice();
 8003760:	f7ff ffca 	bl	80036f8 <reset_time_slice>
	__asm__ volatile(
 8003764:	f384 8811 	msr	BASEPRI, r4
 8003768:	f3bf 8f6f 	isb	sy
}
 800376c:	bd10      	pop	{r4, pc}
 800376e:	bf00      	nop
 8003770:	20020530 	.word	0x20020530
 8003774:	20020564 	.word	0x20020564
 8003778:	20020560 	.word	0x20020560

0800377c <k_sched_lock>:
	__asm__ volatile(
 800377c:	f04f 0310 	mov.w	r3, #16
 8003780:	f3ef 8111 	mrs	r1, BASEPRI
 8003784:	f383 8811 	msr	BASEPRI, r3
 8003788:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
 800378c:	4b04      	ldr	r3, [pc, #16]	; (80037a0 <k_sched_lock+0x24>)
 800378e:	689a      	ldr	r2, [r3, #8]
 8003790:	7bd3      	ldrb	r3, [r2, #15]
 8003792:	3b01      	subs	r3, #1
 8003794:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
 8003796:	f381 8811 	msr	BASEPRI, r1
 800379a:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
 800379e:	4770      	bx	lr
 80037a0:	20020530 	.word	0x20020530

080037a4 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
 80037a4:	4b09      	ldr	r3, [pc, #36]	; (80037cc <z_priq_dumb_remove+0x28>)
 80037a6:	f103 0224 	add.w	r2, r3, #36	; 0x24
 80037aa:	4282      	cmp	r2, r0
 80037ac:	d105      	bne.n	80037ba <z_priq_dumb_remove+0x16>
 80037ae:	689b      	ldr	r3, [r3, #8]
 80037b0:	428b      	cmp	r3, r1
 80037b2:	d102      	bne.n	80037ba <z_priq_dumb_remove+0x16>
 80037b4:	7b4b      	ldrb	r3, [r1, #13]
 80037b6:	06db      	lsls	r3, r3, #27
 80037b8:	d106      	bne.n	80037c8 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
 80037ba:	e9d1 3200 	ldrd	r3, r2, [r1]
 80037be:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 80037c0:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 80037c2:	2300      	movs	r3, #0
	node->prev = NULL;
 80037c4:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!is_idle(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
 80037c8:	4770      	bx	lr
 80037ca:	bf00      	nop
 80037cc:	20020530 	.word	0x20020530

080037d0 <update_cache>:
{
 80037d0:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
 80037d2:	4c0d      	ldr	r4, [pc, #52]	; (8003808 <update_cache+0x38>)
{
 80037d4:	4602      	mov	r2, r0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
 80037d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80037da:	f001 fe33 	bl	8005444 <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
 80037de:	4605      	mov	r5, r0
 80037e0:	b900      	cbnz	r0, 80037e4 <update_cache+0x14>
 80037e2:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
 80037e4:	68a3      	ldr	r3, [r4, #8]
 80037e6:	b94a      	cbnz	r2, 80037fc <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
 80037e8:	7b5a      	ldrb	r2, [r3, #13]
 80037ea:	06d2      	lsls	r2, r2, #27
 80037ec:	d106      	bne.n	80037fc <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80037ee:	69aa      	ldr	r2, [r5, #24]
 80037f0:	b922      	cbnz	r2, 80037fc <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(th)) {
 80037f2:	89da      	ldrh	r2, [r3, #14]
 80037f4:	2a7f      	cmp	r2, #127	; 0x7f
 80037f6:	d901      	bls.n	80037fc <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
 80037f8:	6223      	str	r3, [r4, #32]
}
 80037fa:	bd38      	pop	{r3, r4, r5, pc}
		if (th != _current) {
 80037fc:	429d      	cmp	r5, r3
 80037fe:	d001      	beq.n	8003804 <update_cache+0x34>
			reset_time_slice();
 8003800:	f7ff ff7a 	bl	80036f8 <reset_time_slice>
		_kernel.ready_q.cache = th;
 8003804:	6225      	str	r5, [r4, #32]
}
 8003806:	e7f8      	b.n	80037fa <update_cache+0x2a>
 8003808:	20020530 	.word	0x20020530

0800380c <k_sched_unlock>:
{
 800380c:	b510      	push	{r4, lr}
	__asm__ volatile(
 800380e:	f04f 0310 	mov.w	r3, #16
 8003812:	f3ef 8411 	mrs	r4, BASEPRI
 8003816:	f383 8811 	msr	BASEPRI, r3
 800381a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
 800381e:	4b08      	ldr	r3, [pc, #32]	; (8003840 <k_sched_unlock+0x34>)
		update_cache(1);
 8003820:	2001      	movs	r0, #1
		++_current->base.sched_locked;
 8003822:	689a      	ldr	r2, [r3, #8]
 8003824:	7bd3      	ldrb	r3, [r2, #15]
 8003826:	3301      	adds	r3, #1
 8003828:	73d3      	strb	r3, [r2, #15]
		update_cache(1);
 800382a:	f7ff ffd1 	bl	80037d0 <update_cache>
	__asm__ volatile(
 800382e:	f384 8811 	msr	BASEPRI, r4
 8003832:	f3bf 8f6f 	isb	sy
}
 8003836:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
 800383a:	f001 bdf9 	b.w	8005430 <z_reschedule_unlocked>
 800383e:	bf00      	nop
 8003840:	20020530 	.word	0x20020530

08003844 <z_add_thread_to_ready_q>:
{
 8003844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
 8003846:	f04f 0310 	mov.w	r3, #16
 800384a:	f3ef 8411 	mrs	r4, BASEPRI
 800384e:	f383 8811 	msr	BASEPRI, r3
 8003852:	f3bf 8f6f 	isb	sy
	return list->head == list;
 8003856:	4a15      	ldr	r2, [pc, #84]	; (80038ac <z_add_thread_to_ready_q+0x68>)
 8003858:	4611      	mov	r1, r2
 800385a:	f851 3f24 	ldr.w	r3, [r1, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 800385e:	428b      	cmp	r3, r1
 8003860:	d01d      	beq.n	800389e <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003862:	b1e3      	cbz	r3, 800389e <z_add_thread_to_ready_q+0x5a>
 8003864:	6a96      	ldr	r6, [r2, #40]	; 0x28
	if (t1->base.prio < t2->base.prio) {
 8003866:	f990 500e 	ldrsb.w	r5, [r0, #14]
 800386a:	f993 700e 	ldrsb.w	r7, [r3, #14]
 800386e:	42af      	cmp	r7, r5
 8003870:	dd10      	ble.n	8003894 <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
 8003872:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 8003874:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
 8003878:	6010      	str	r0, [r2, #0]
	successor->prev = node;
 800387a:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
 800387c:	7b43      	ldrb	r3, [r0, #13]
 800387e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003882:	7343      	strb	r3, [r0, #13]
		update_cache(0);
 8003884:	2000      	movs	r0, #0
 8003886:	f7ff ffa3 	bl	80037d0 <update_cache>
	__asm__ volatile(
 800388a:	f384 8811 	msr	BASEPRI, r4
 800388e:	f3bf 8f6f 	isb	sy
}
 8003892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
 8003894:	42b3      	cmp	r3, r6
 8003896:	d002      	beq.n	800389e <z_add_thread_to_ready_q+0x5a>
 8003898:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800389a:	2b00      	cmp	r3, #0
 800389c:	d1e5      	bne.n	800386a <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
 800389e:	6a93      	ldr	r3, [r2, #40]	; 0x28
	node->next = list;
 80038a0:	6001      	str	r1, [r0, #0]
	node->prev = list->tail;
 80038a2:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
 80038a4:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80038a6:	6018      	str	r0, [r3, #0]
	list->tail = node;
 80038a8:	6290      	str	r0, [r2, #40]	; 0x28
 80038aa:	e7e7      	b.n	800387c <z_add_thread_to_ready_q+0x38>
 80038ac:	20020530 	.word	0x20020530

080038b0 <z_move_thread_to_end_of_prio_q>:
{
 80038b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038b2:	4604      	mov	r4, r0
	__asm__ volatile(
 80038b4:	f04f 0310 	mov.w	r3, #16
 80038b8:	f3ef 8711 	mrs	r7, BASEPRI
 80038bc:	f383 8811 	msr	BASEPRI, r3
 80038c0:	f3bf 8f6f 	isb	sy
		_priq_run_remove(&_kernel.ready_q.runq, thread);
 80038c4:	4d19      	ldr	r5, [pc, #100]	; (800392c <z_move_thread_to_end_of_prio_q+0x7c>)
 80038c6:	4601      	mov	r1, r0
 80038c8:	f105 0624 	add.w	r6, r5, #36	; 0x24
 80038cc:	4630      	mov	r0, r6
 80038ce:	f7ff ff69 	bl	80037a4 <z_priq_dumb_remove>
	return list->head == list;
 80038d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80038d4:	462a      	mov	r2, r5
	return sys_dlist_is_empty(list) ? NULL : list->head;
 80038d6:	42b3      	cmp	r3, r6
 80038d8:	d020      	beq.n	800391c <z_move_thread_to_end_of_prio_q+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80038da:	b1fb      	cbz	r3, 800391c <z_move_thread_to_end_of_prio_q+0x6c>
 80038dc:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	if (t1->base.prio < t2->base.prio) {
 80038de:	f994 100e 	ldrsb.w	r1, [r4, #14]
 80038e2:	f993 500e 	ldrsb.w	r5, [r3, #14]
 80038e6:	428d      	cmp	r5, r1
 80038e8:	dd13      	ble.n	8003912 <z_move_thread_to_end_of_prio_q+0x62>
	node->prev = successor->prev;
 80038ea:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
 80038ec:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
 80038f0:	600c      	str	r4, [r1, #0]
	successor->prev = node;
 80038f2:	605c      	str	r4, [r3, #4]
 80038f4:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
 80038f6:	6890      	ldr	r0, [r2, #8]
 80038f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80038fc:	7363      	strb	r3, [r4, #13]
 80038fe:	1b03      	subs	r3, r0, r4
 8003900:	4258      	negs	r0, r3
 8003902:	4158      	adcs	r0, r3
 8003904:	f7ff ff64 	bl	80037d0 <update_cache>
	__asm__ volatile(
 8003908:	f387 8811 	msr	BASEPRI, r7
 800390c:	f3bf 8f6f 	isb	sy
}
 8003910:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
 8003912:	4283      	cmp	r3, r0
 8003914:	d002      	beq.n	800391c <z_move_thread_to_end_of_prio_q+0x6c>
 8003916:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003918:	2b00      	cmp	r3, #0
 800391a:	d1e2      	bne.n	80038e2 <z_move_thread_to_end_of_prio_q+0x32>
	node->prev = list->tail;
 800391c:	6a93      	ldr	r3, [r2, #40]	; 0x28
	node->next = list;
 800391e:	6026      	str	r6, [r4, #0]
	node->prev = list->tail;
 8003920:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
 8003922:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8003924:	601c      	str	r4, [r3, #0]
	list->tail = node;
 8003926:	6294      	str	r4, [r2, #40]	; 0x28
 8003928:	e7e4      	b.n	80038f4 <z_move_thread_to_end_of_prio_q+0x44>
 800392a:	bf00      	nop
 800392c:	20020530 	.word	0x20020530

08003930 <z_time_slice>:
	if (pending_current == _current) {
 8003930:	4914      	ldr	r1, [pc, #80]	; (8003984 <z_time_slice+0x54>)
 8003932:	4a15      	ldr	r2, [pc, #84]	; (8003988 <z_time_slice+0x58>)
 8003934:	688b      	ldr	r3, [r1, #8]
{
 8003936:	b510      	push	{r4, lr}
	if (pending_current == _current) {
 8003938:	6814      	ldr	r4, [r2, #0]
 800393a:	42a3      	cmp	r3, r4
 800393c:	d103      	bne.n	8003946 <z_time_slice+0x16>
}
 800393e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			reset_time_slice();
 8003942:	f7ff bed9 	b.w	80036f8 <reset_time_slice>
	pending_current = NULL;
 8003946:	2400      	movs	r4, #0
 8003948:	6014      	str	r4, [r2, #0]
	if (slice_time && sliceable(_current)) {
 800394a:	4a10      	ldr	r2, [pc, #64]	; (800398c <z_time_slice+0x5c>)
 800394c:	6812      	ldr	r2, [r2, #0]
 800394e:	b1ba      	cbz	r2, 8003980 <z_time_slice+0x50>
		&& !z_is_thread_timeout_active(t);
 8003950:	89da      	ldrh	r2, [r3, #14]
 8003952:	2a7f      	cmp	r2, #127	; 0x7f
 8003954:	d814      	bhi.n	8003980 <z_time_slice+0x50>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
 8003956:	4a0e      	ldr	r2, [pc, #56]	; (8003990 <z_time_slice+0x60>)
 8003958:	f993 400e 	ldrsb.w	r4, [r3, #14]
 800395c:	6812      	ldr	r2, [r2, #0]
 800395e:	4294      	cmp	r4, r2
 8003960:	db0e      	blt.n	8003980 <z_time_slice+0x50>
	return thread == _idle_thread;
 8003962:	4a0c      	ldr	r2, [pc, #48]	; (8003994 <z_time_slice+0x64>)
		&& !is_idle(t)
 8003964:	6812      	ldr	r2, [r2, #0]
 8003966:	4293      	cmp	r3, r2
 8003968:	d00a      	beq.n	8003980 <z_time_slice+0x50>
		&& !z_is_thread_timeout_active(t);
 800396a:	699a      	ldr	r2, [r3, #24]
 800396c:	b942      	cbnz	r2, 8003980 <z_time_slice+0x50>
		if (ticks >= _current_cpu->slice_ticks) {
 800396e:	690a      	ldr	r2, [r1, #16]
 8003970:	4282      	cmp	r2, r0
 8003972:	dc03      	bgt.n	800397c <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
 8003974:	4618      	mov	r0, r3
 8003976:	f7ff ff9b 	bl	80038b0 <z_move_thread_to_end_of_prio_q>
 800397a:	e7e0      	b.n	800393e <z_time_slice+0xe>
			_current_cpu->slice_ticks -= ticks;
 800397c:	1a12      	subs	r2, r2, r0
 800397e:	610a      	str	r2, [r1, #16]
}
 8003980:	bd10      	pop	{r4, pc}
 8003982:	bf00      	nop
 8003984:	20020530 	.word	0x20020530
 8003988:	2002055c 	.word	0x2002055c
 800398c:	20020564 	.word	0x20020564
 8003990:	20020560 	.word	0x20020560
 8003994:	08005ca0 	.word	0x08005ca0

08003998 <z_remove_thread_from_ready_q>:
{
 8003998:	b538      	push	{r3, r4, r5, lr}
 800399a:	4604      	mov	r4, r0
	__asm__ volatile(
 800399c:	f04f 0310 	mov.w	r3, #16
 80039a0:	f3ef 8511 	mrs	r5, BASEPRI
 80039a4:	f383 8811 	msr	BASEPRI, r3
 80039a8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 80039ac:	7b43      	ldrb	r3, [r0, #13]
 80039ae:	065a      	lsls	r2, r3, #25
 80039b0:	d507      	bpl.n	80039c2 <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
 80039b2:	4601      	mov	r1, r0
 80039b4:	4809      	ldr	r0, [pc, #36]	; (80039dc <z_remove_thread_from_ready_q+0x44>)
 80039b6:	f7ff fef5 	bl	80037a4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 80039ba:	7b63      	ldrb	r3, [r4, #13]
 80039bc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80039c0:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
 80039c2:	4b07      	ldr	r3, [pc, #28]	; (80039e0 <z_remove_thread_from_ready_q+0x48>)
 80039c4:	6898      	ldr	r0, [r3, #8]
 80039c6:	1b03      	subs	r3, r0, r4
 80039c8:	4258      	negs	r0, r3
 80039ca:	4158      	adcs	r0, r3
 80039cc:	f7ff ff00 	bl	80037d0 <update_cache>
	__asm__ volatile(
 80039d0:	f385 8811 	msr	BASEPRI, r5
 80039d4:	f3bf 8f6f 	isb	sy
}
 80039d8:	bd38      	pop	{r3, r4, r5, pc}
 80039da:	bf00      	nop
 80039dc:	20020554 	.word	0x20020554
 80039e0:	20020530 	.word	0x20020530

080039e4 <pend>:
{
 80039e4:	b570      	push	{r4, r5, r6, lr}
 80039e6:	4604      	mov	r4, r0
 80039e8:	460d      	mov	r5, r1
 80039ea:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
 80039ec:	f7ff ffd4 	bl	8003998 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
 80039f0:	7b63      	ldrb	r3, [r4, #13]
 80039f2:	f043 0302 	orr.w	r3, r3, #2
 80039f6:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
 80039f8:	b17d      	cbz	r5, 8003a1a <pend+0x36>
	return list->head == list;
 80039fa:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
 80039fc:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 80039fe:	429d      	cmp	r5, r3
 8003a00:	d01b      	beq.n	8003a3a <pend+0x56>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003a02:	b1d3      	cbz	r3, 8003a3a <pend+0x56>
	if (t1->base.prio < t2->base.prio) {
 8003a04:	f994 200e 	ldrsb.w	r2, [r4, #14]
 8003a08:	f993 100e 	ldrsb.w	r1, [r3, #14]
 8003a0c:	4291      	cmp	r1, r2
 8003a0e:	dd0e      	ble.n	8003a2e <pend+0x4a>
	node->prev = successor->prev;
 8003a10:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 8003a12:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
 8003a16:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 8003a18:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
 8003a1a:	1c73      	adds	r3, r6, #1
 8003a1c:	d014      	beq.n	8003a48 <pend+0x64>

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
 8003a1e:	1c72      	adds	r2, r6, #1
 8003a20:	f104 0018 	add.w	r0, r4, #24
 8003a24:	4909      	ldr	r1, [pc, #36]	; (8003a4c <pend+0x68>)
}
 8003a26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8003a2a:	f000 b9e7 	b.w	8003dfc <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
 8003a2e:	6869      	ldr	r1, [r5, #4]
 8003a30:	428b      	cmp	r3, r1
 8003a32:	d002      	beq.n	8003a3a <pend+0x56>
 8003a34:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d1e6      	bne.n	8003a08 <pend+0x24>
	node->prev = list->tail;
 8003a3a:	686b      	ldr	r3, [r5, #4]
	node->next = list;
 8003a3c:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
 8003a3e:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
 8003a40:	686b      	ldr	r3, [r5, #4]
 8003a42:	601c      	str	r4, [r3, #0]
	list->tail = node;
 8003a44:	606c      	str	r4, [r5, #4]
 8003a46:	e7e8      	b.n	8003a1a <pend+0x36>
}
 8003a48:	bd70      	pop	{r4, r5, r6, pc}
 8003a4a:	bf00      	nop
 8003a4c:	08005451 	.word	0x08005451

08003a50 <z_pend_curr>:
{
 8003a50:	b510      	push	{r4, lr}
 8003a52:	460c      	mov	r4, r1
 8003a54:	4611      	mov	r1, r2
	pending_current = _current;
 8003a56:	4a06      	ldr	r2, [pc, #24]	; (8003a70 <z_pend_curr+0x20>)
 8003a58:	6890      	ldr	r0, [r2, #8]
 8003a5a:	4a06      	ldr	r2, [pc, #24]	; (8003a74 <z_pend_curr+0x24>)
 8003a5c:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
 8003a5e:	461a      	mov	r2, r3
 8003a60:	f7ff ffc0 	bl	80039e4 <pend>
 8003a64:	4620      	mov	r0, r4
}
 8003a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8003a6a:	f7fe bf9d 	b.w	80029a8 <__swap>
 8003a6e:	bf00      	nop
 8003a70:	20020530 	.word	0x20020530
 8003a74:	2002055c 	.word	0x2002055c

08003a78 <z_tick_sleep.part.16>:

#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

static s32_t z_tick_sleep(s32_t ticks)
 8003a78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
 8003a7a:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
 8003a7c:	f001 fdc9 	bl	8005612 <z_tick_get_32>
 8003a80:	1834      	adds	r4, r6, r0
	__asm__ volatile(
 8003a82:	f04f 0310 	mov.w	r3, #16
 8003a86:	f3ef 8711 	mrs	r7, BASEPRI
 8003a8a:	f383 8811 	msr	BASEPRI, r3
 8003a8e:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
 8003a92:	4d0d      	ldr	r5, [pc, #52]	; (8003ac8 <z_tick_sleep.part.16+0x50>)
 8003a94:	4b0d      	ldr	r3, [pc, #52]	; (8003acc <z_tick_sleep.part.16+0x54>)
 8003a96:	68a8      	ldr	r0, [r5, #8]
 8003a98:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
 8003a9a:	f7ff ff7d 	bl	8003998 <z_remove_thread_from_ready_q>
 8003a9e:	68a8      	ldr	r0, [r5, #8]
 8003aa0:	4632      	mov	r2, r6
 8003aa2:	490b      	ldr	r1, [pc, #44]	; (8003ad0 <z_tick_sleep.part.16+0x58>)
 8003aa4:	3018      	adds	r0, #24
 8003aa6:	f000 f9a9 	bl	8003dfc <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
 8003aaa:	68aa      	ldr	r2, [r5, #8]
 8003aac:	4638      	mov	r0, r7
	thread->base.thread_state |= _THREAD_SUSPENDED;
 8003aae:	7b53      	ldrb	r3, [r2, #13]
 8003ab0:	f043 0310 	orr.w	r3, r3, #16
 8003ab4:	7353      	strb	r3, [r2, #13]
 8003ab6:	f7fe ff77 	bl	80029a8 <__swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
 8003aba:	f001 fdaa 	bl	8005612 <z_tick_get_32>
 8003abe:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
 8003ac0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8003ac4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003ac6:	bf00      	nop
 8003ac8:	20020530 	.word	0x20020530
 8003acc:	2002055c 	.word	0x2002055c
 8003ad0:	08005451 	.word	0x08005451

08003ad4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
 8003ad4:	4b04      	ldr	r3, [pc, #16]	; (8003ae8 <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 8003ad6:	2100      	movs	r1, #0
 8003ad8:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8003adc:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
 8003ade:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
 8003ae2:	f7ff be2d 	b.w	8003740 <k_sched_time_slice_set>
 8003ae6:	bf00      	nop
 8003ae8:	20020530 	.word	0x20020530

08003aec <z_impl_k_yield>:
{
 8003aec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!is_idle(_current)) {
 8003aee:	4c22      	ldr	r4, [pc, #136]	; (8003b78 <z_impl_k_yield+0x8c>)
 8003af0:	4b22      	ldr	r3, [pc, #136]	; (8003b7c <z_impl_k_yield+0x90>)
 8003af2:	68a2      	ldr	r2, [r4, #8]
 8003af4:	681b      	ldr	r3, [r3, #0]
 8003af6:	429a      	cmp	r2, r3
 8003af8:	d025      	beq.n	8003b46 <z_impl_k_yield+0x5a>
 8003afa:	f04f 0310 	mov.w	r3, #16
 8003afe:	f3ef 8611 	mrs	r6, BASEPRI
 8003b02:	f383 8811 	msr	BASEPRI, r3
 8003b06:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
 8003b0a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8003b0e:	68a1      	ldr	r1, [r4, #8]
 8003b10:	4628      	mov	r0, r5
 8003b12:	f7ff fe47 	bl	80037a4 <z_priq_dumb_remove>
	return list->head == list;
 8003b16:	6a63      	ldr	r3, [r4, #36]	; 0x24
				_priq_run_add(&_kernel.ready_q.runq,
 8003b18:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8003b1a:	42ab      	cmp	r3, r5
 8003b1c:	d024      	beq.n	8003b68 <z_impl_k_yield+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003b1e:	b31b      	cbz	r3, 8003b68 <z_impl_k_yield+0x7c>
 8003b20:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (t1->base.prio < t2->base.prio) {
 8003b22:	f992 000e 	ldrsb.w	r0, [r2, #14]
 8003b26:	f993 700e 	ldrsb.w	r7, [r3, #14]
 8003b2a:	4287      	cmp	r7, r0
 8003b2c:	dd17      	ble.n	8003b5e <z_impl_k_yield+0x72>
	node->prev = successor->prev;
 8003b2e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
 8003b30:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
 8003b34:	600a      	str	r2, [r1, #0]
	successor->prev = node;
 8003b36:	605a      	str	r2, [r3, #4]
			update_cache(1);
 8003b38:	2001      	movs	r0, #1
 8003b3a:	f7ff fe49 	bl	80037d0 <update_cache>
	__asm__ volatile(
 8003b3e:	f386 8811 	msr	BASEPRI, r6
 8003b42:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 8003b46:	f04f 0310 	mov.w	r3, #16
 8003b4a:	f3ef 8011 	mrs	r0, BASEPRI
 8003b4e:	f383 8811 	msr	BASEPRI, r3
 8003b52:	f3bf 8f6f 	isb	sy
}
 8003b56:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8003b5a:	f7fe bf25 	b.w	80029a8 <__swap>
	return (node == list->tail) ? NULL : node->next;
 8003b5e:	4299      	cmp	r1, r3
 8003b60:	d002      	beq.n	8003b68 <z_impl_k_yield+0x7c>
 8003b62:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8003b64:	2b00      	cmp	r3, #0
 8003b66:	d1de      	bne.n	8003b26 <z_impl_k_yield+0x3a>
	node->prev = list->tail;
 8003b68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	node->next = list;
 8003b6a:	6015      	str	r5, [r2, #0]
	node->prev = list->tail;
 8003b6c:	6053      	str	r3, [r2, #4]
	list->tail->next = node;
 8003b6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003b70:	601a      	str	r2, [r3, #0]
	list->tail = node;
 8003b72:	62a2      	str	r2, [r4, #40]	; 0x28
 8003b74:	e7e0      	b.n	8003b38 <z_impl_k_yield+0x4c>
 8003b76:	bf00      	nop
 8003b78:	20020530 	.word	0x20020530
 8003b7c:	08005ca0 	.word	0x08005ca0

08003b80 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
 8003b80:	4b01      	ldr	r3, [pc, #4]	; (8003b88 <z_impl_k_current_get+0x8>)
 8003b82:	6898      	ldr	r0, [r3, #8]
 8003b84:	4770      	bx	lr
 8003b86:	bf00      	nop
 8003b88:	20020530 	.word	0x20020530

08003b8c <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 8003b8c:	b570      	push	{r4, r5, r6, lr}
 8003b8e:	4604      	mov	r4, r0
 8003b90:	f04f 0310 	mov.w	r3, #16
 8003b94:	f3ef 8611 	mrs	r6, BASEPRI
 8003b98:	f383 8811 	msr	BASEPRI, r3
 8003b9c:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
 8003ba0:	f001 fc87 	bl	80054b2 <z_unpend_first_thread>
	if (thread != NULL) {
 8003ba4:	4605      	mov	r5, r0
 8003ba6:	b170      	cbz	r0, 8003bc6 <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 8003ba8:	7b43      	ldrb	r3, [r0, #13]
 8003baa:	06db      	lsls	r3, r3, #27
 8003bac:	d103      	bne.n	8003bb6 <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
 8003bae:	6983      	ldr	r3, [r0, #24]
 8003bb0:	b90b      	cbnz	r3, 8003bb6 <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
 8003bb2:	f7ff fe47 	bl	8003844 <z_add_thread_to_ready_q>
}

static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
 8003bb6:	2300      	movs	r3, #0
 8003bb8:	662b      	str	r3, [r5, #96]	; 0x60
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
 8003bba:	4631      	mov	r1, r6
 8003bbc:	4805      	ldr	r0, [pc, #20]	; (8003bd4 <z_impl_k_sem_give+0x48>)
}
 8003bbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
 8003bc2:	f001 bc16 	b.w	80053f2 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
 8003bc6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 8003bca:	429a      	cmp	r2, r3
 8003bcc:	bf18      	it	ne
 8003bce:	3301      	addne	r3, #1
 8003bd0:	60a3      	str	r3, [r4, #8]
 8003bd2:	e7f2      	b.n	8003bba <z_impl_k_sem_give+0x2e>
 8003bd4:	2002056c 	.word	0x2002056c

08003bd8 <z_impl_k_sem_take>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_sem_give, K_OBJ_SEM, struct k_sem *);
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
 8003bd8:	b410      	push	{r4}
 8003bda:	4602      	mov	r2, r0
 8003bdc:	460b      	mov	r3, r1
 8003bde:	f04f 0010 	mov.w	r0, #16
 8003be2:	f3ef 8111 	mrs	r1, BASEPRI
 8003be6:	f380 8811 	msr	BASEPRI, r0
 8003bea:	f3bf 8f6f 	isb	sy
	__ASSERT(((z_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
 8003bee:	6894      	ldr	r4, [r2, #8]
 8003bf0:	b144      	cbz	r4, 8003c04 <z_impl_k_sem_take+0x2c>
		sem->count--;
 8003bf2:	3c01      	subs	r4, #1
 8003bf4:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
 8003bf6:	f381 8811 	msr	BASEPRI, r1
 8003bfa:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
 8003bfe:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
 8003c00:	bc10      	pop	{r4}
 8003c02:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
 8003c04:	b933      	cbnz	r3, 8003c14 <z_impl_k_sem_take+0x3c>
 8003c06:	f381 8811 	msr	BASEPRI, r1
 8003c0a:	f3bf 8f6f 	isb	sy
		return -EBUSY;
 8003c0e:	f06f 000f 	mvn.w	r0, #15
 8003c12:	e7f5      	b.n	8003c00 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 8003c14:	4801      	ldr	r0, [pc, #4]	; (8003c1c <z_impl_k_sem_take+0x44>)
}
 8003c16:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 8003c18:	f7ff bf1a 	b.w	8003a50 <z_pend_curr>
 8003c1c:	2002056c 	.word	0x2002056c

08003c20 <k_is_in_isr>:
 8003c20:	f3ef 8005 	mrs	r0, IPSR
 8003c24:	280d      	cmp	r0, #13
 8003c26:	d807      	bhi.n	8003c38 <k_is_in_isr+0x18>
 8003c28:	b138      	cbz	r0, 8003c3a <k_is_in_isr+0x1a>
 8003c2a:	4b04      	ldr	r3, [pc, #16]	; (8003c3c <k_is_in_isr+0x1c>)
 8003c2c:	6858      	ldr	r0, [r3, #4]
 8003c2e:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 8003c32:	f3c0 20c0 	ubfx	r0, r0, #11, #1
 8003c36:	4770      	bx	lr
 8003c38:	2001      	movs	r0, #1
}

bool k_is_in_isr(void)
{
	return z_is_in_isr();
}
 8003c3a:	4770      	bx	lr
 8003c3c:	e000ed00 	.word	0xe000ed00

08003c40 <z_is_thread_essential>:
 *
 * Returns true if current thread is essential, false if it is not.
 */
bool z_is_thread_essential(void)
{
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 8003c40:	4b02      	ldr	r3, [pc, #8]	; (8003c4c <z_is_thread_essential+0xc>)
 8003c42:	689b      	ldr	r3, [r3, #8]
 8003c44:	7b18      	ldrb	r0, [r3, #12]
}
 8003c46:	f000 0001 	and.w	r0, r0, #1
 8003c4a:	4770      	bx	lr
 8003c4c:	20020530 	.word	0x20020530

08003c50 <z_impl_k_busy_wait>:
{
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	/* use 64-bit math to prevent overflow when multiplying */
	u32_t cycles_to_wait = (u32_t)(
		(u64_t)usec_to_wait *
		(u64_t)sys_clock_hw_cycles_per_sec() /
 8003c50:	4908      	ldr	r1, [pc, #32]	; (8003c74 <z_impl_k_busy_wait+0x24>)
 8003c52:	4a09      	ldr	r2, [pc, #36]	; (8003c78 <z_impl_k_busy_wait+0x28>)
 8003c54:	fba0 0101 	umull	r0, r1, r0, r1
{
 8003c58:	b538      	push	{r3, r4, r5, lr}
		(u64_t)sys_clock_hw_cycles_per_sec() /
 8003c5a:	2300      	movs	r3, #0
 8003c5c:	f7fc facc 	bl	80001f8 <__aeabi_uldivmod>
 8003c60:	4604      	mov	r4, r0
		(u64_t)USEC_PER_SEC
	);
	u32_t start_cycles = k_cycle_get_32();
 8003c62:	f7fd fab1 	bl	80011c8 <z_timer_cycle_get_32>
 8003c66:	4605      	mov	r5, r0

	for (;;) {
		u32_t current_cycles = k_cycle_get_32();
 8003c68:	f7fd faae 	bl	80011c8 <z_timer_cycle_get_32>

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 8003c6c:	1b40      	subs	r0, r0, r5
 8003c6e:	42a0      	cmp	r0, r4
 8003c70:	d3fa      	bcc.n	8003c68 <z_impl_k_busy_wait+0x18>
		}
	}
#else
	z_arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
}
 8003c72:	bd38      	pop	{r3, r4, r5, pc}
 8003c74:	0cdfe600 	.word	0x0cdfe600
 8003c78:	000f4240 	.word	0x000f4240

08003c7c <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
 8003c7c:	b510      	push	{r4, lr}
 8003c7e:	4602      	mov	r2, r0
	__asm__ volatile(
 8003c80:	f04f 0310 	mov.w	r3, #16
 8003c84:	f3ef 8411 	mrs	r4, BASEPRI
 8003c88:	f383 8811 	msr	BASEPRI, r3
 8003c8c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
 8003c90:	7b43      	ldrb	r3, [r0, #13]
 8003c92:	0759      	lsls	r1, r3, #29
 8003c94:	d404      	bmi.n	8003ca0 <z_impl_k_thread_start+0x24>
	__asm__ volatile(
 8003c96:	f384 8811 	msr	BASEPRI, r4
 8003c9a:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
 8003c9e:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
 8003ca0:	f023 0304 	bic.w	r3, r3, #4
 8003ca4:	7343      	strb	r3, [r0, #13]
	if (z_is_thread_ready(thread)) {
 8003ca6:	f001 fc44 	bl	8005532 <z_is_thread_ready>
 8003caa:	b110      	cbz	r0, 8003cb2 <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
 8003cac:	4610      	mov	r0, r2
 8003cae:	f7ff fdc9 	bl	8003844 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
 8003cb2:	4621      	mov	r1, r4
 8003cb4:	4802      	ldr	r0, [pc, #8]	; (8003cc0 <z_impl_k_thread_start+0x44>)
}
 8003cb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
 8003cba:	f001 bb9a 	b.w	80053f2 <z_reschedule>
 8003cbe:	bf00      	nop
 8003cc0:	2002056c 	.word	0x2002056c

08003cc4 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
 8003cc4:	b530      	push	{r4, r5, lr}
 8003cc6:	b087      	sub	sp, #28
 8003cc8:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 8003cca:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8003ccc:	9504      	str	r5, [sp, #16]
 8003cce:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8003cd0:	9503      	str	r5, [sp, #12]
 8003cd2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8003cd4:	9502      	str	r5, [sp, #8]
 8003cd6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8003cd8:	9501      	str	r5, [sp, #4]
 8003cda:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8003cdc:	9500      	str	r5, [sp, #0]
 8003cde:	f7ff f827 	bl	8002d30 <z_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
 8003ce2:	4b03      	ldr	r3, [pc, #12]	; (8003cf0 <z_setup_new_thread+0x2c>)
 8003ce4:	689b      	ldr	r3, [r3, #8]
 8003ce6:	b103      	cbz	r3, 8003cea <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
 8003ce8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003cea:	65a3      	str	r3, [r4, #88]	; 0x58
	sys_trace_thread_create(new_thread);
}
 8003cec:	b007      	add	sp, #28
 8003cee:	bd30      	pop	{r4, r5, pc}
 8003cf0:	20020530 	.word	0x20020530

08003cf4 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
 8003cf4:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
 8003cf6:	4e1f      	ldr	r6, [pc, #124]	; (8003d74 <z_init_static_threads+0x80>)
{
 8003cf8:	b087      	sub	sp, #28
 8003cfa:	4d1f      	ldr	r5, [pc, #124]	; (8003d78 <z_init_static_threads+0x84>)
 8003cfc:	4637      	mov	r7, r6
	_FOREACH_STATIC_THREAD(thread_data) {
 8003cfe:	42b5      	cmp	r5, r6
 8003d00:	f105 0430 	add.w	r4, r5, #48	; 0x30
 8003d04:	d30a      	bcc.n	8003d1c <z_init_static_threads+0x28>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
 8003d06:	4c1c      	ldr	r4, [pc, #112]	; (8003d78 <z_init_static_threads+0x84>)
	k_sched_lock();
 8003d08:	f7ff fd38 	bl	800377c <k_sched_lock>
 8003d0c:	4d1b      	ldr	r5, [pc, #108]	; (8003d7c <z_init_static_threads+0x88>)
	_FOREACH_STATIC_THREAD(thread_data) {
 8003d0e:	42bc      	cmp	r4, r7
 8003d10:	d321      	bcc.n	8003d56 <z_init_static_threads+0x62>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
 8003d12:	b007      	add	sp, #28
 8003d14:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
 8003d18:	f7ff bd78 	b.w	800380c <k_sched_unlock>
		z_setup_new_thread(
 8003d1c:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8003d20:	9305      	str	r3, [sp, #20]
 8003d22:	f854 3c10 	ldr.w	r3, [r4, #-16]
 8003d26:	9304      	str	r3, [sp, #16]
 8003d28:	f854 3c14 	ldr.w	r3, [r4, #-20]
 8003d2c:	9303      	str	r3, [sp, #12]
 8003d2e:	f854 3c18 	ldr.w	r3, [r4, #-24]
 8003d32:	9302      	str	r3, [sp, #8]
 8003d34:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 8003d38:	9301      	str	r3, [sp, #4]
 8003d3a:	f854 3c20 	ldr.w	r3, [r4, #-32]
 8003d3e:	9300      	str	r3, [sp, #0]
 8003d40:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
 8003d44:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
 8003d48:	f7ff ffbc 	bl	8003cc4 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 8003d4c:	f854 3c30 	ldr.w	r3, [r4, #-48]
 8003d50:	64dd      	str	r5, [r3, #76]	; 0x4c
 8003d52:	4625      	mov	r5, r4
 8003d54:	e7d3      	b.n	8003cfe <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_FOREVER) {
 8003d56:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003d58:	1c53      	adds	r3, r2, #1
 8003d5a:	d003      	beq.n	8003d64 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
 8003d5c:	6820      	ldr	r0, [r4, #0]
	if (delay == 0) {
 8003d5e:	b91a      	cbnz	r2, 8003d68 <z_init_static_threads+0x74>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
 8003d60:	f7ff ff8c 	bl	8003c7c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
 8003d64:	3430      	adds	r4, #48	; 0x30
 8003d66:	e7d2      	b.n	8003d0e <z_init_static_threads+0x1a>
 8003d68:	3201      	adds	r2, #1
 8003d6a:	4629      	mov	r1, r5
 8003d6c:	3018      	adds	r0, #24
 8003d6e:	f000 f845 	bl	8003dfc <z_add_timeout>
 8003d72:	e7f7      	b.n	8003d64 <z_init_static_threads+0x70>
 8003d74:	20021440 	.word	0x20021440
 8003d78:	20021440 	.word	0x20021440
 8003d7c:	08005451 	.word	0x08005451

08003d80 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
 8003d80:	4b03      	ldr	r3, [pc, #12]	; (8003d90 <elapsed+0x10>)
 8003d82:	681b      	ldr	r3, [r3, #0]
 8003d84:	b90b      	cbnz	r3, 8003d8a <elapsed+0xa>
 8003d86:	f7fd b9ff 	b.w	8001188 <z_clock_elapsed>
}
 8003d8a:	2000      	movs	r0, #0
 8003d8c:	4770      	bx	lr
 8003d8e:	bf00      	nop
 8003d90:	20020568 	.word	0x20020568

08003d94 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8003d94:	6803      	ldr	r3, [r0, #0]
 8003d96:	b140      	cbz	r0, 8003daa <remove_timeout+0x16>
 8003d98:	4a07      	ldr	r2, [pc, #28]	; (8003db8 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
 8003d9a:	6852      	ldr	r2, [r2, #4]
 8003d9c:	4290      	cmp	r0, r2
 8003d9e:	d004      	beq.n	8003daa <remove_timeout+0x16>
	if (next(t) != NULL) {
 8003da0:	b11b      	cbz	r3, 8003daa <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
 8003da2:	689a      	ldr	r2, [r3, #8]
 8003da4:	6881      	ldr	r1, [r0, #8]
 8003da6:	440a      	add	r2, r1
 8003da8:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
 8003daa:	6842      	ldr	r2, [r0, #4]
 8003dac:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 8003dae:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 8003db0:	2300      	movs	r3, #0
	node->prev = NULL;
 8003db2:	e9c0 3300 	strd	r3, r3, [r0]
}
 8003db6:	4770      	bx	lr
 8003db8:	20021338 	.word	0x20021338

08003dbc <next_timeout>:

static s32_t next_timeout(void)
{
 8003dbc:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
 8003dbe:	4b0d      	ldr	r3, [pc, #52]	; (8003df4 <next_timeout+0x38>)
 8003dc0:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8003dc2:	429c      	cmp	r4, r3
 8003dc4:	d011      	beq.n	8003dea <next_timeout+0x2e>
	struct _timeout *to = first();
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - elapsed());
 8003dc6:	b184      	cbz	r4, 8003dea <next_timeout+0x2e>
 8003dc8:	68a5      	ldr	r5, [r4, #8]
 8003dca:	f7ff ffd9 	bl	8003d80 <elapsed>
 8003dce:	1a28      	subs	r0, r5, r0
 8003dd0:	2800      	cmp	r0, #0
 8003dd2:	db0d      	blt.n	8003df0 <next_timeout+0x34>
 8003dd4:	68a4      	ldr	r4, [r4, #8]
 8003dd6:	f7ff ffd3 	bl	8003d80 <elapsed>
 8003dda:	1a20      	subs	r0, r4, r0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 8003ddc:	4b06      	ldr	r3, [pc, #24]	; (8003df8 <next_timeout+0x3c>)
 8003dde:	691b      	ldr	r3, [r3, #16]
 8003de0:	b113      	cbz	r3, 8003de8 <next_timeout+0x2c>
 8003de2:	4298      	cmp	r0, r3
 8003de4:	bfa8      	it	ge
 8003de6:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 8003de8:	bd38      	pop	{r3, r4, r5, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - elapsed());
 8003dea:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
 8003dee:	e7f5      	b.n	8003ddc <next_timeout+0x20>
 8003df0:	2000      	movs	r0, #0
 8003df2:	e7f3      	b.n	8003ddc <next_timeout+0x20>
 8003df4:	20021338 	.word	0x20021338
 8003df8:	20020530 	.word	0x20020530

08003dfc <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
 8003dfc:	b570      	push	{r4, r5, r6, lr}
 8003dfe:	4604      	mov	r4, r0
 8003e00:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 8003e02:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
 8003e04:	f04f 0310 	mov.w	r3, #16
 8003e08:	f3ef 8511 	mrs	r5, BASEPRI
 8003e0c:	f383 8811 	msr	BASEPRI, r3
 8003e10:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
 8003e14:	f7ff ffb4 	bl	8003d80 <elapsed>
	return list->head == list;
 8003e18:	4b18      	ldr	r3, [pc, #96]	; (8003e7c <z_add_timeout+0x80>)
 8003e1a:	2e01      	cmp	r6, #1
 8003e1c:	bfac      	ite	ge
 8003e1e:	1980      	addge	r0, r0, r6
 8003e20:	3001      	addlt	r0, #1
 8003e22:	681a      	ldr	r2, [r3, #0]
 8003e24:	60a0      	str	r0, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8003e26:	429a      	cmp	r2, r3
 8003e28:	d001      	beq.n	8003e2e <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8003e2a:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
 8003e2c:	b932      	cbnz	r2, 8003e3c <z_add_timeout+0x40>
	node->prev = list->tail;
 8003e2e:	685a      	ldr	r2, [r3, #4]
	node->next = list;
 8003e30:	6023      	str	r3, [r4, #0]
	node->prev = list->tail;
 8003e32:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
 8003e34:	685a      	ldr	r2, [r3, #4]
 8003e36:	6014      	str	r4, [r2, #0]
	list->tail = node;
 8003e38:	605c      	str	r4, [r3, #4]
 8003e3a:	e00a      	b.n	8003e52 <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
 8003e3c:	6890      	ldr	r0, [r2, #8]
 8003e3e:	68a1      	ldr	r1, [r4, #8]
 8003e40:	4288      	cmp	r0, r1
 8003e42:	dd15      	ble.n	8003e70 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
 8003e44:	1a41      	subs	r1, r0, r1
 8003e46:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
 8003e48:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 8003e4a:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
 8003e4e:	600c      	str	r4, [r1, #0]
	successor->prev = node;
 8003e50:	6054      	str	r4, [r2, #4]
	return list->head == list;
 8003e52:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8003e54:	429a      	cmp	r2, r3
 8003e56:	d006      	beq.n	8003e66 <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 8003e58:	4294      	cmp	r4, r2
 8003e5a:	d104      	bne.n	8003e66 <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
 8003e5c:	f7ff ffae 	bl	8003dbc <next_timeout>
 8003e60:	2100      	movs	r1, #0
 8003e62:	f7fd f941 	bl	80010e8 <z_clock_set_timeout>
	__asm__ volatile(
 8003e66:	f385 8811 	msr	BASEPRI, r5
 8003e6a:	f3bf 8f6f 	isb	sy
		}
	}
}
 8003e6e:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
 8003e70:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
 8003e72:	42b2      	cmp	r2, r6
 8003e74:	60a1      	str	r1, [r4, #8]
 8003e76:	d0da      	beq.n	8003e2e <z_add_timeout+0x32>
 8003e78:	6812      	ldr	r2, [r2, #0]
 8003e7a:	e7d7      	b.n	8003e2c <z_add_timeout+0x30>
 8003e7c:	20021338 	.word	0x20021338

08003e80 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
 8003e80:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
 8003e84:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 8003e86:	f7ff fd53 	bl	8003930 <z_time_slice>
	__asm__ volatile(
 8003e8a:	f04f 0310 	mov.w	r3, #16
 8003e8e:	f3ef 8511 	mrs	r5, BASEPRI
 8003e92:	f383 8811 	msr	BASEPRI, r3
 8003e96:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
 8003e9a:	4f21      	ldr	r7, [pc, #132]	; (8003f20 <z_clock_announce+0xa0>)
 8003e9c:	4e21      	ldr	r6, [pc, #132]	; (8003f24 <z_clock_announce+0xa4>)
	return list->head == list;
 8003e9e:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8003f28 <z_clock_announce+0xa8>
 8003ea2:	46b8      	mov	r8, r7
 8003ea4:	6034      	str	r4, [r6, #0]
 8003ea6:	f8d9 4000 	ldr.w	r4, [r9]
 8003eaa:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8003eac:	454c      	cmp	r4, r9
 8003eae:	e9d7 bc00 	ldrd	fp, ip, [r7]
 8003eb2:	d005      	beq.n	8003ec0 <z_clock_announce+0x40>

	while (first() != NULL && first()->dticks <= announce_remaining) {
 8003eb4:	b124      	cbz	r4, 8003ec0 <z_clock_announce+0x40>
 8003eb6:	68a3      	ldr	r3, [r4, #8]
 8003eb8:	4293      	cmp	r3, r2
 8003eba:	dd15      	ble.n	8003ee8 <z_clock_announce+0x68>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 8003ebc:	1a9b      	subs	r3, r3, r2
 8003ebe:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
 8003ec0:	eb1b 0002 	adds.w	r0, fp, r2
	announce_remaining = 0;
 8003ec4:	f04f 0400 	mov.w	r4, #0
	curr_tick += announce_remaining;
 8003ec8:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
 8003ecc:	6034      	str	r4, [r6, #0]
	curr_tick += announce_remaining;
 8003ece:	e9c8 0100 	strd	r0, r1, [r8]

	z_clock_set_timeout(next_timeout(), false);
 8003ed2:	f7ff ff73 	bl	8003dbc <next_timeout>
 8003ed6:	4621      	mov	r1, r4
 8003ed8:	f7fd f906 	bl	80010e8 <z_clock_set_timeout>
	__asm__ volatile(
 8003edc:	f385 8811 	msr	BASEPRI, r5
 8003ee0:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
 8003ee4:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
 8003ee8:	eb1b 0003 	adds.w	r0, fp, r3
 8003eec:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
 8003ef0:	1ad3      	subs	r3, r2, r3
 8003ef2:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
 8003ef4:	2300      	movs	r3, #0
		curr_tick += dt;
 8003ef6:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
 8003efa:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
 8003efc:	4620      	mov	r0, r4
 8003efe:	f7ff ff49 	bl	8003d94 <remove_timeout>
 8003f02:	f385 8811 	msr	BASEPRI, r5
 8003f06:	f3bf 8f6f 	isb	sy
		t->fn(t);
 8003f0a:	68e3      	ldr	r3, [r4, #12]
 8003f0c:	4798      	blx	r3
	__asm__ volatile(
 8003f0e:	f04f 0310 	mov.w	r3, #16
 8003f12:	f3ef 8511 	mrs	r5, BASEPRI
 8003f16:	f383 8811 	msr	BASEPRI, r3
 8003f1a:	f3bf 8f6f 	isb	sy
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
 8003f1e:	e7c2      	b.n	8003ea6 <z_clock_announce+0x26>
 8003f20:	20020000 	.word	0x20020000
 8003f24:	20020568 	.word	0x20020568
 8003f28:	20021338 	.word	0x20021338

08003f2c <z_tick_get>:

s64_t z_tick_get(void)
{
 8003f2c:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
 8003f30:	f04f 0310 	mov.w	r3, #16
 8003f34:	f3ef 8411 	mrs	r4, BASEPRI
 8003f38:	f383 8811 	msr	BASEPRI, r3
 8003f3c:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
 8003f40:	f7fd f922 	bl	8001188 <z_clock_elapsed>
 8003f44:	4b07      	ldr	r3, [pc, #28]	; (8003f64 <z_tick_get+0x38>)
 8003f46:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003f4a:	eb12 0b00 	adds.w	fp, r2, r0
 8003f4e:	f143 0c00 	adc.w	ip, r3, #0
 8003f52:	4658      	mov	r0, fp
 8003f54:	4661      	mov	r1, ip
	__asm__ volatile(
 8003f56:	f384 8811 	msr	BASEPRI, r4
 8003f5a:	f3bf 8f6f 	isb	sy
	}
	return t;
}
 8003f5e:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
 8003f62:	bf00      	nop
 8003f64:	20020000 	.word	0x20020000

08003f68 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
 8003f68:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
 8003f6a:	4c07      	ldr	r4, [pc, #28]	; (8003f88 <init_static_pools+0x20>)
 8003f6c:	4d07      	ldr	r5, [pc, #28]	; (8003f8c <init_static_pools+0x24>)
 8003f6e:	42ac      	cmp	r4, r5
 8003f70:	d301      	bcc.n	8003f76 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
 8003f72:	2000      	movs	r0, #0
 8003f74:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 8003f76:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
 8003f7a:	4620      	mov	r0, r4
	list->tail = (sys_dnode_t *)list;
 8003f7c:	e9c4 3305 	strd	r3, r3, [r4, #20]
 8003f80:	f000 f82b 	bl	8003fda <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
 8003f84:	341c      	adds	r4, #28
 8003f86:	e7f2      	b.n	8003f6e <init_static_pools+0x6>
 8003f88:	20021440 	.word	0x20021440
 8003f8c:	20021440 	.word	0x20021440

08003f90 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
 8003f90:	b570      	push	{r4, r5, r6, lr}
 8003f92:	68c6      	ldr	r6, [r0, #12]
 8003f94:	250c      	movs	r5, #12
	u32_t *bitarray = level <= p->max_inline_level ?
 8003f96:	f990 000b 	ldrsb.w	r0, [r0, #11]
 8003f9a:	434d      	muls	r5, r1
		&p->levels[level].bits : p->levels[level].bits_p;
 8003f9c:	4288      	cmp	r0, r1

	*word = &bitarray[bn / 32];
 8003f9e:	4610      	mov	r0, r2
 8003fa0:	eb06 0405 	add.w	r4, r6, r5
		&p->levels[level].bits : p->levels[level].bits_p;
 8003fa4:	bfb8      	it	lt
 8003fa6:	5974      	ldrlt	r4, [r6, r5]
	*word = &bitarray[bn / 32];
 8003fa8:	2a00      	cmp	r2, #0
 8003faa:	bfb8      	it	lt
 8003fac:	f102 001f 	addlt.w	r0, r2, #31
 8003fb0:	1140      	asrs	r0, r0, #5
 8003fb2:	eb04 0180 	add.w	r1, r4, r0, lsl #2

	return bn & 0x1f;
}
 8003fb6:	f002 001f 	and.w	r0, r2, #31
	*word = &bitarray[bn / 32];
 8003fba:	6019      	str	r1, [r3, #0]
}
 8003fbc:	bd70      	pop	{r4, r5, r6, pc}

08003fbe <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
 8003fbe:	b507      	push	{r0, r1, r2, lr}
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
 8003fc0:	ab01      	add	r3, sp, #4
 8003fc2:	f7ff ffe5 	bl	8003f90 <get_bit_ptr>

	*word |= (1<<bit);
 8003fc6:	9a01      	ldr	r2, [sp, #4]
 8003fc8:	2301      	movs	r3, #1
 8003fca:	fa03 f000 	lsl.w	r0, r3, r0
 8003fce:	6813      	ldr	r3, [r2, #0]
 8003fd0:	4303      	orrs	r3, r0
 8003fd2:	6013      	str	r3, [r2, #0]
}
 8003fd4:	b003      	add	sp, #12
 8003fd6:	f85d fb04 	ldr.w	pc, [sp], #4

08003fda <z_sys_mem_pool_base_init>:

	return block_end <= (parent + parent_sz);
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
 8003fda:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
 8003fde:	6843      	ldr	r3, [r0, #4]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;
 8003fe0:	22ff      	movs	r2, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
 8003fe2:	8906      	ldrh	r6, [r0, #8]
{
 8003fe4:	4604      	mov	r4, r0
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
 8003fe6:	6805      	ldr	r5, [r0, #0]

	for (i = 0; i < p->n_levels; i++) {
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
 8003fe8:	f04f 0e0c 	mov.w	lr, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
 8003fec:	435e      	muls	r6, r3
	for (i = 0; i < p->n_levels; i++) {
 8003fee:	f890 c00a 	ldrb.w	ip, [r0, #10]
	p->max_inline_level = -1;
 8003ff2:	72c2      	strb	r2, [r0, #11]
	for (i = 0; i < p->n_levels; i++) {
 8003ff4:	2000      	movs	r0, #0
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
 8003ff6:	4435      	add	r5, r6
	for (i = 0; i < p->n_levels; i++) {
 8003ff8:	4584      	cmp	ip, r0
 8003ffa:	dc05      	bgt.n	8004008 <z_sys_mem_pool_base_init+0x2e>
		}

		sz = _ALIGN4(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
 8003ffc:	2500      	movs	r5, #0
 8003ffe:	8923      	ldrh	r3, [r4, #8]
 8004000:	42ab      	cmp	r3, r5
 8004002:	dc21      	bgt.n	8004048 <z_sys_mem_pool_base_init+0x6e>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
		set_free_bit(p, 0, i);
	}
}
 8004004:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		sys_dlist_init(&p->levels[i].free_list);
 8004008:	f8d4 800c 	ldr.w	r8, [r4, #12]
 800400c:	fb0e f700 	mul.w	r7, lr, r0
		int nblocks = buflen / sz;
 8004010:	fbb6 f1f3 	udiv	r1, r6, r3
		sys_dlist_init(&p->levels[i].free_list);
 8004014:	eb08 0207 	add.w	r2, r8, r7
		if (nblocks <= 32) {
 8004018:	2920      	cmp	r1, #32
		sys_dlist_init(&p->levels[i].free_list);
 800401a:	f102 0904 	add.w	r9, r2, #4
 800401e:	e9c2 9901 	strd	r9, r9, [r2, #4]
		if (nblocks <= 32) {
 8004022:	dc06      	bgt.n	8004032 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
 8004024:	72e0      	strb	r0, [r4, #11]
		sz = _ALIGN4(sz / 4);
 8004026:	089b      	lsrs	r3, r3, #2
	for (i = 0; i < p->n_levels; i++) {
 8004028:	3001      	adds	r0, #1
		sz = _ALIGN4(sz / 4);
 800402a:	3303      	adds	r3, #3
 800402c:	f023 0303 	bic.w	r3, r3, #3
 8004030:	e7e2      	b.n	8003ff8 <z_sys_mem_pool_base_init+0x1e>
			bits += (nblocks + 31)/32;
 8004032:	f111 021f 	adds.w	r2, r1, #31
			p->levels[i].bits_p = bits;
 8004036:	f848 5007 	str.w	r5, [r8, r7]
			bits += (nblocks + 31)/32;
 800403a:	bf48      	it	mi
 800403c:	f101 023e 	addmi.w	r2, r1, #62	; 0x3e
 8004040:	1152      	asrs	r2, r2, #5
 8004042:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8004046:	e7ee      	b.n	8004026 <z_sys_mem_pool_base_init+0x4c>
		sys_dlist_append(&p->levels[0].free_list, block);
 8004048:	68e3      	ldr	r3, [r4, #12]
	return (u8_t *)p->buf + lsz * block;
 800404a:	6862      	ldr	r2, [r4, #4]
 800404c:	6820      	ldr	r0, [r4, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
 800404e:	1d1e      	adds	r6, r3, #4
	return (u8_t *)p->buf + lsz * block;
 8004050:	436a      	muls	r2, r5
 8004052:	1881      	adds	r1, r0, r2
	node->next = list;
 8004054:	5086      	str	r6, [r0, r2]
	node->prev = list->tail;
 8004056:	689a      	ldr	r2, [r3, #8]
		set_free_bit(p, 0, i);
 8004058:	4620      	mov	r0, r4
 800405a:	604a      	str	r2, [r1, #4]
	list->tail->next = node;
 800405c:	689a      	ldr	r2, [r3, #8]
 800405e:	6011      	str	r1, [r2, #0]
 8004060:	462a      	mov	r2, r5
	list->tail = node;
 8004062:	6099      	str	r1, [r3, #8]
 8004064:	2100      	movs	r1, #0
 8004066:	f7ff ffaa 	bl	8003fbe <set_free_bit>
	for (i = 0; i < p->n_max; i++) {
 800406a:	3501      	adds	r5, #1
 800406c:	e7c7      	b.n	8003ffe <z_sys_mem_pool_base_init+0x24>

0800406e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 800406e:	b508      	push	{r3, lr}
 8004070:	4604      	mov	r4, r0
 8004072:	4608      	mov	r0, r1
 8004074:	4611      	mov	r1, r2
	entry(p1, p2, p3);
 8004076:	461a      	mov	r2, r3
 8004078:	47a0      	blx	r4
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
 800407a:	f7ff fd81 	bl	8003b80 <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
 800407e:	f7fe fef9 	bl	8002e74 <z_impl_k_thread_abort>

08004082 <z_arch_printk_char_out>:
}
 8004082:	2000      	movs	r0, #0
 8004084:	4770      	bx	lr

08004086 <print_err>:
{
 8004086:	b570      	push	{r4, r5, r6, lr}
 8004088:	460d      	mov	r5, r1
 800408a:	4604      	mov	r4, r0
	out('E', ctx);
 800408c:	2045      	movs	r0, #69	; 0x45
 800408e:	47a0      	blx	r4
	out('R', ctx);
 8004090:	4629      	mov	r1, r5
 8004092:	2052      	movs	r0, #82	; 0x52
 8004094:	47a0      	blx	r4
	out('R', ctx);
 8004096:	4629      	mov	r1, r5
 8004098:	4623      	mov	r3, r4
 800409a:	2052      	movs	r0, #82	; 0x52
}
 800409c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
 80040a0:	4718      	bx	r3

080040a2 <z_vprintk>:
{
 80040a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
 80040a6:	f04f 0800 	mov.w	r8, #0
{
 80040aa:	b08b      	sub	sp, #44	; 0x2c
 80040ac:	461c      	mov	r4, r3
 80040ae:	4606      	mov	r6, r0
 80040b0:	1e53      	subs	r3, r2, #1
 80040b2:	460f      	mov	r7, r1
	int min_width = -1;
 80040b4:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
 80040b8:	46c1      	mov	r9, r8
 80040ba:	9302      	str	r3, [sp, #8]
			might_format = 0;
 80040bc:	2500      	movs	r5, #0
					break;
 80040be:	e005      	b.n	80040cc <z_vprintk+0x2a>
		if (!might_format) {
 80040c0:	b96d      	cbnz	r5, 80040de <z_vprintk+0x3c>
			if (*fmt != '%') {
 80040c2:	2825      	cmp	r0, #37	; 0x25
 80040c4:	f000 814f 	beq.w	8004366 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
 80040c8:	4639      	mov	r1, r7
 80040ca:	47b0      	blx	r6
	while (*fmt) {
 80040cc:	9b02      	ldr	r3, [sp, #8]
 80040ce:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 80040d2:	9302      	str	r3, [sp, #8]
 80040d4:	2800      	cmp	r0, #0
 80040d6:	d1f3      	bne.n	80040c0 <z_vprintk+0x1e>
}
 80040d8:	b00b      	add	sp, #44	; 0x2c
 80040da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
 80040de:	2864      	cmp	r0, #100	; 0x64
 80040e0:	d06e      	beq.n	80041c0 <z_vprintk+0x11e>
 80040e2:	d81a      	bhi.n	800411a <z_vprintk+0x78>
 80040e4:	2839      	cmp	r0, #57	; 0x39
 80040e6:	d80a      	bhi.n	80040fe <z_vprintk+0x5c>
 80040e8:	2831      	cmp	r0, #49	; 0x31
 80040ea:	d260      	bcs.n	80041ae <z_vprintk+0x10c>
 80040ec:	282d      	cmp	r0, #45	; 0x2d
 80040ee:	f000 8140 	beq.w	8004372 <z_vprintk+0x2d0>
 80040f2:	2830      	cmp	r0, #48	; 0x30
 80040f4:	d04c      	beq.n	8004190 <z_vprintk+0xee>
 80040f6:	2825      	cmp	r0, #37	; 0x25
 80040f8:	d107      	bne.n	800410a <z_vprintk+0x68>
				out((int)'%', ctx);
 80040fa:	4639      	mov	r1, r7
 80040fc:	e00b      	b.n	8004116 <z_vprintk+0x74>
			switch (*fmt) {
 80040fe:	2858      	cmp	r0, #88	; 0x58
 8004100:	f000 80bb 	beq.w	800427a <z_vprintk+0x1d8>
 8004104:	2863      	cmp	r0, #99	; 0x63
 8004106:	f000 812a 	beq.w	800435e <z_vprintk+0x2bc>
					out((int)'%', ctx);
 800410a:	4639      	mov	r1, r7
 800410c:	2025      	movs	r0, #37	; 0x25
 800410e:	47b0      	blx	r6
					out((int)*fmt, ctx);
 8004110:	9b02      	ldr	r3, [sp, #8]
 8004112:	4639      	mov	r1, r7
 8004114:	7818      	ldrb	r0, [r3, #0]
 8004116:	47b0      	blx	r6
 8004118:	e7d0      	b.n	80040bc <z_vprintk+0x1a>
			switch (*fmt) {
 800411a:	2870      	cmp	r0, #112	; 0x70
 800411c:	f000 80a3 	beq.w	8004266 <z_vprintk+0x1c4>
 8004120:	d811      	bhi.n	8004146 <z_vprintk+0xa4>
 8004122:	2869      	cmp	r0, #105	; 0x69
 8004124:	d04c      	beq.n	80041c0 <z_vprintk+0x11e>
 8004126:	286c      	cmp	r0, #108	; 0x6c
 8004128:	d105      	bne.n	8004136 <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
 800412a:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 800412e:	d12a      	bne.n	8004186 <z_vprintk+0xe4>
					length_mod = 'L';
 8004130:	f04f 084c 	mov.w	r8, #76	; 0x4c
 8004134:	e7ca      	b.n	80040cc <z_vprintk+0x2a>
			switch (*fmt) {
 8004136:	2868      	cmp	r0, #104	; 0x68
 8004138:	d1e7      	bne.n	800410a <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
 800413a:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
 800413e:	d122      	bne.n	8004186 <z_vprintk+0xe4>
					length_mod = 'H';
 8004140:	f04f 0848 	mov.w	r8, #72	; 0x48
 8004144:	e7c2      	b.n	80040cc <z_vprintk+0x2a>
			switch (*fmt) {
 8004146:	2875      	cmp	r0, #117	; 0x75
 8004148:	d071      	beq.n	800422e <z_vprintk+0x18c>
 800414a:	d818      	bhi.n	800417e <z_vprintk+0xdc>
 800414c:	2873      	cmp	r0, #115	; 0x73
 800414e:	d1dc      	bne.n	800410a <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
 8004150:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
 8004154:	46ab      	mov	fp, r5
 8004156:	465b      	mov	r3, fp
 8004158:	f81b 0b01 	ldrb.w	r0, [fp], #1
 800415c:	2800      	cmp	r0, #0
 800415e:	f040 80fb 	bne.w	8004358 <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
 8004162:	f1b9 0f03 	cmp.w	r9, #3
 8004166:	f040 810a 	bne.w	800437e <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
 800416a:	1b5d      	subs	r5, r3, r5
 800416c:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
 8004170:	2d00      	cmp	r5, #0
 8004172:	dda3      	ble.n	80040bc <z_vprintk+0x1a>
						out(' ', ctx);
 8004174:	4639      	mov	r1, r7
 8004176:	2020      	movs	r0, #32
 8004178:	47b0      	blx	r6
 800417a:	3d01      	subs	r5, #1
 800417c:	e7f8      	b.n	8004170 <z_vprintk+0xce>
			switch (*fmt) {
 800417e:	2878      	cmp	r0, #120	; 0x78
 8004180:	d07b      	beq.n	800427a <z_vprintk+0x1d8>
 8004182:	287a      	cmp	r0, #122	; 0x7a
 8004184:	d1c1      	bne.n	800410a <z_vprintk+0x68>
				} else if (length_mod == 0) {
 8004186:	f1b8 0f00 	cmp.w	r8, #0
 800418a:	d1be      	bne.n	800410a <z_vprintk+0x68>
 800418c:	4680      	mov	r8, r0
 800418e:	e79d      	b.n	80040cc <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
 8004190:	f1ba 0f00 	cmp.w	sl, #0
 8004194:	da0e      	bge.n	80041b4 <z_vprintk+0x112>
 8004196:	f1b9 0f00 	cmp.w	r9, #0
 800419a:	f000 80ed 	beq.w	8004378 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
 800419e:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
 80041a2:	f1b9 0f00 	cmp.w	r9, #0
 80041a6:	bf08      	it	eq
 80041a8:	f04f 0902 	moveq.w	r9, #2
 80041ac:	e78e      	b.n	80040cc <z_vprintk+0x2a>
				if (min_width < 0) {
 80041ae:	f1ba 0f00 	cmp.w	sl, #0
 80041b2:	dbf4      	blt.n	800419e <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
 80041b4:	230a      	movs	r3, #10
 80041b6:	fb03 0a0a 	mla	sl, r3, sl, r0
 80041ba:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 80041be:	e7f0      	b.n	80041a2 <z_vprintk+0x100>
				if (length_mod == 'z') {
 80041c0:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80041c4:	d102      	bne.n	80041cc <z_vprintk+0x12a>
					d = va_arg(ap, int);
 80041c6:	f854 5b04 	ldr.w	r5, [r4], #4
 80041ca:	e01f      	b.n	800420c <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
 80041cc:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 80041d0:	d0f9      	beq.n	80041c6 <z_vprintk+0x124>
				} else if (length_mod == 'L') {
 80041d2:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
 80041d6:	d1f6      	bne.n	80041c6 <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
 80041d8:	3407      	adds	r4, #7
					if (lld > __LONG_MAX__ ||
 80041da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					long long lld = va_arg(ap, long long);
 80041de:	f024 0407 	bic.w	r4, r4, #7
 80041e2:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
 80041e6:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
 80041ea:	9106      	str	r1, [sp, #24]
 80041ec:	f143 0100 	adc.w	r1, r3, #0
 80041f0:	9107      	str	r1, [sp, #28]
 80041f2:	2100      	movs	r1, #0
 80041f4:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
 80041f8:	4561      	cmp	r1, ip
 80041fa:	bf08      	it	eq
 80041fc:	4558      	cmpeq	r0, fp
 80041fe:	d204      	bcs.n	800420a <z_vprintk+0x168>
						print_err(out, ctx);
 8004200:	4639      	mov	r1, r7
 8004202:	4630      	mov	r0, r6
 8004204:	f7ff ff3f 	bl	8004086 <print_err>
						break;
 8004208:	e758      	b.n	80040bc <z_vprintk+0x1a>
					d = lld;
 800420a:	4615      	mov	r5, r2
				if (d < 0) {
 800420c:	2d00      	cmp	r5, #0
 800420e:	da05      	bge.n	800421c <z_vprintk+0x17a>
					d = -d;
 8004210:	426d      	negs	r5, r5
					min_width--;
 8004212:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
					out((int)'-', ctx);
 8004216:	4639      	mov	r1, r7
 8004218:	202d      	movs	r0, #45	; 0x2d
 800421a:	47b0      	blx	r6
				_printk_dec_ulong(out, ctx, d, padding,
 800421c:	464b      	mov	r3, r9
 800421e:	462a      	mov	r2, r5
 8004220:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
 8004224:	4639      	mov	r1, r7
 8004226:	4630      	mov	r0, r6
 8004228:	f7fc f9a2 	bl	8000570 <_printk_dec_ulong>
				break;
 800422c:	e746      	b.n	80040bc <z_vprintk+0x1a>
				if (length_mod == 'z') {
 800422e:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8004232:	d102      	bne.n	800423a <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
 8004234:	f854 2b04 	ldr.w	r2, [r4], #4
 8004238:	e011      	b.n	800425e <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
 800423a:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 800423e:	d0f9      	beq.n	8004234 <z_vprintk+0x192>
				} else if (length_mod == 'L') {
 8004240:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
 8004244:	d1f6      	bne.n	8004234 <z_vprintk+0x192>
					unsigned long long llu =
 8004246:	3407      	adds	r4, #7
					if (llu > ~0UL) {
 8004248:	2100      	movs	r1, #0
 800424a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					unsigned long long llu =
 800424e:	f024 0407 	bic.w	r4, r4, #7
 8004252:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
 8004256:	4299      	cmp	r1, r3
 8004258:	bf08      	it	eq
 800425a:	4290      	cmpeq	r0, r2
 800425c:	d3d0      	bcc.n	8004200 <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
 800425e:	f8cd a000 	str.w	sl, [sp]
 8004262:	464b      	mov	r3, r9
 8004264:	e7de      	b.n	8004224 <z_vprintk+0x182>
				  out('0', ctx);
 8004266:	4639      	mov	r1, r7
 8004268:	2030      	movs	r0, #48	; 0x30
				  min_width = 8;
 800426a:	f04f 0a08 	mov.w	sl, #8
				  padding = PAD_ZERO_BEFORE;
 800426e:	f04f 0901 	mov.w	r9, #1
				  out('0', ctx);
 8004272:	47b0      	blx	r6
				  out('x', ctx);
 8004274:	4639      	mov	r1, r7
 8004276:	2078      	movs	r0, #120	; 0x78
 8004278:	47b0      	blx	r6
				if (*fmt == 'p') {
 800427a:	9b02      	ldr	r3, [sp, #8]
 800427c:	781b      	ldrb	r3, [r3, #0]
 800427e:	2b70      	cmp	r3, #112	; 0x70
 8004280:	d104      	bne.n	800428c <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
 8004282:	f854 3b04 	ldr.w	r3, [r4], #4
 8004286:	9304      	str	r3, [sp, #16]
 8004288:	2300      	movs	r3, #0
 800428a:	e00d      	b.n	80042a8 <z_vprintk+0x206>
				} else if (length_mod == 'l') {
 800428c:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 8004290:	d0f7      	beq.n	8004282 <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
 8004292:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
 8004296:	d1f4      	bne.n	8004282 <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
 8004298:	3407      	adds	r4, #7
 800429a:	f024 0307 	bic.w	r3, r4, #7
 800429e:	461c      	mov	r4, r3
 80042a0:	685b      	ldr	r3, [r3, #4]
 80042a2:	f854 2b08 	ldr.w	r2, [r4], #8
 80042a6:	9204      	str	r2, [sp, #16]
	int digits = 0;
 80042a8:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
 80042aa:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
 80042ac:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
 80042b0:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
 80042b2:	9105      	str	r1, [sp, #20]
		shift -= 4;
 80042b4:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
 80042b8:	9804      	ldr	r0, [sp, #16]
 80042ba:	f1cb 0c20 	rsb	ip, fp, #32
 80042be:	f1ab 0120 	sub.w	r1, fp, #32
 80042c2:	fa20 f00b 	lsr.w	r0, r0, fp
 80042c6:	fa03 fc0c 	lsl.w	ip, r3, ip
 80042ca:	fa23 f101 	lsr.w	r1, r3, r1
 80042ce:	ea40 000c 	orr.w	r0, r0, ip
 80042d2:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
 80042d4:	f010 000f 	ands.w	r0, r0, #15
 80042d8:	d108      	bne.n	80042ec <z_vprintk+0x24a>
 80042da:	9905      	ldr	r1, [sp, #20]
 80042dc:	b911      	cbnz	r1, 80042e4 <z_vprintk+0x242>
 80042de:	f1bb 0f00 	cmp.w	fp, #0
 80042e2:	d124      	bne.n	800432e <z_vprintk+0x28c>
			nibble += nibble > 9 ? 87 : 48;
 80042e4:	2130      	movs	r1, #48	; 0x30
 80042e6:	e005      	b.n	80042f4 <z_vprintk+0x252>
			found_largest_digit = 1;
 80042e8:	9505      	str	r5, [sp, #20]
 80042ea:	e7e3      	b.n	80042b4 <z_vprintk+0x212>
			nibble += nibble > 9 ? 87 : 48;
 80042ec:	2809      	cmp	r0, #9
 80042ee:	bf8c      	ite	hi
 80042f0:	2157      	movhi	r1, #87	; 0x57
 80042f2:	2130      	movls	r1, #48	; 0x30
 80042f4:	4408      	add	r0, r1
			out((int)nibble, ctx);
 80042f6:	4639      	mov	r1, r7
 80042f8:	9308      	str	r3, [sp, #32]
 80042fa:	b240      	sxtb	r0, r0
 80042fc:	9205      	str	r2, [sp, #20]
 80042fe:	47b0      	blx	r6
			digits++;
 8004300:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
 8004302:	9a05      	ldr	r2, [sp, #20]
			digits++;
 8004304:	3301      	adds	r3, #1
 8004306:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
 8004308:	9b08      	ldr	r3, [sp, #32]
 800430a:	f1bb 0f00 	cmp.w	fp, #0
 800430e:	d1eb      	bne.n	80042e8 <z_vprintk+0x246>
	if (padding == PAD_SPACE_AFTER) {
 8004310:	f1b9 0f03 	cmp.w	r9, #3
 8004314:	f47f aed2 	bne.w	80040bc <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
 8004318:	9b03      	ldr	r3, [sp, #12]
 800431a:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
 800431e:	2d00      	cmp	r5, #0
 8004320:	f77f aecc 	ble.w	80040bc <z_vprintk+0x1a>
			out(' ', ctx);
 8004324:	4639      	mov	r1, r7
 8004326:	2020      	movs	r0, #32
 8004328:	47b0      	blx	r6
 800432a:	3d01      	subs	r5, #1
 800432c:	e7f7      	b.n	800431e <z_vprintk+0x27c>
		if (remaining-- <= min_width) {
 800432e:	1e51      	subs	r1, r2, #1
 8004330:	4592      	cmp	sl, r2
 8004332:	9108      	str	r1, [sp, #32]
 8004334:	db07      	blt.n	8004346 <z_vprintk+0x2a4>
			if (padding == PAD_ZERO_BEFORE) {
 8004336:	f1b9 0f01 	cmp.w	r9, #1
 800433a:	d106      	bne.n	800434a <z_vprintk+0x2a8>
				out('0', ctx);
 800433c:	4639      	mov	r1, r7
 800433e:	2030      	movs	r0, #48	; 0x30
 8004340:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
 8004342:	47b0      	blx	r6
 8004344:	9b09      	ldr	r3, [sp, #36]	; 0x24
					x = va_arg(ap, unsigned int);
 8004346:	9a08      	ldr	r2, [sp, #32]
 8004348:	e7b4      	b.n	80042b4 <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
 800434a:	f1b9 0f02 	cmp.w	r9, #2
 800434e:	d1fa      	bne.n	8004346 <z_vprintk+0x2a4>
 8004350:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
 8004352:	4639      	mov	r1, r7
 8004354:	2020      	movs	r0, #32
 8004356:	e7f4      	b.n	8004342 <z_vprintk+0x2a0>
					out((int)(*s++), ctx);
 8004358:	4639      	mov	r1, r7
 800435a:	47b0      	blx	r6
 800435c:	e6fb      	b.n	8004156 <z_vprintk+0xb4>
				out(c, ctx);
 800435e:	4639      	mov	r1, r7
 8004360:	f854 0b04 	ldr.w	r0, [r4], #4
 8004364:	e6d7      	b.n	8004116 <z_vprintk+0x74>
				length_mod = 0;
 8004366:	46a8      	mov	r8, r5
				padding = PAD_NONE;
 8004368:	46a9      	mov	r9, r5
				min_width = -1;
 800436a:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
 800436e:	2501      	movs	r5, #1
 8004370:	e6ac      	b.n	80040cc <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
 8004372:	f04f 0903 	mov.w	r9, #3
 8004376:	e6a9      	b.n	80040cc <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
 8004378:	f04f 0901 	mov.w	r9, #1
 800437c:	e6a6      	b.n	80040cc <z_vprintk+0x2a>
			might_format = 0;
 800437e:	4605      	mov	r5, r0
		++fmt;
 8004380:	e6a4      	b.n	80040cc <z_vprintk+0x2a>

08004382 <printk>:
{
 8004382:	b40f      	push	{r0, r1, r2, r3}
 8004384:	b507      	push	{r0, r1, r2, lr}
 8004386:	a904      	add	r1, sp, #16
 8004388:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
 800438c:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
 800438e:	f7fc f943 	bl	8000618 <vprintk>
}
 8004392:	b003      	add	sp, #12
 8004394:	f85d eb04 	ldr.w	lr, [sp], #4
 8004398:	b004      	add	sp, #16
 800439a:	4770      	bx	lr

0800439c <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 800439c:	4770      	bx	lr

0800439e <HAL_GetTick>:
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
 800439e:	f001 b93c 	b.w	800561a <z_impl_k_uptime_get_32>

080043a2 <HAL_Delay>:
 *	  on variable incremented.
 * @param Delay: specifies the delay time length, in milliseconds.
 * @return None
 */
void HAL_Delay(__IO uint32_t Delay)
{
 80043a2:	b082      	sub	sp, #8
 80043a4:	9001      	str	r0, [sp, #4]
	k_sleep(Delay);
 80043a6:	9801      	ldr	r0, [sp, #4]
}
 80043a8:	b002      	add	sp, #8
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, ms)
 80043aa:	f001 b8af 	b.w	800550c <z_impl_k_sleep>

080043ae <__stm32_exti_isr_0>:
	__stm32_exti_isr(0, 1, arg);
 80043ae:	4602      	mov	r2, r0
 80043b0:	2101      	movs	r1, #1
 80043b2:	2000      	movs	r0, #0
 80043b4:	f7fc b9c8 	b.w	8000748 <__stm32_exti_isr>

080043b8 <__stm32_exti_isr_1>:
	__stm32_exti_isr(1, 2, arg);
 80043b8:	4602      	mov	r2, r0
 80043ba:	2102      	movs	r1, #2
 80043bc:	2001      	movs	r0, #1
 80043be:	f7fc b9c3 	b.w	8000748 <__stm32_exti_isr>

080043c2 <__stm32_exti_isr_2>:
	__stm32_exti_isr(2, 3, arg);
 80043c2:	4602      	mov	r2, r0
 80043c4:	2103      	movs	r1, #3
 80043c6:	2002      	movs	r0, #2
 80043c8:	f7fc b9be 	b.w	8000748 <__stm32_exti_isr>

080043cc <__stm32_exti_isr_3>:
	__stm32_exti_isr(3, 4, arg);
 80043cc:	4602      	mov	r2, r0
 80043ce:	2104      	movs	r1, #4
 80043d0:	2003      	movs	r0, #3
 80043d2:	f7fc b9b9 	b.w	8000748 <__stm32_exti_isr>

080043d6 <__stm32_exti_isr_4>:
	__stm32_exti_isr(4, 5, arg);
 80043d6:	4602      	mov	r2, r0
 80043d8:	2105      	movs	r1, #5
 80043da:	2004      	movs	r0, #4
 80043dc:	f7fc b9b4 	b.w	8000748 <__stm32_exti_isr>

080043e0 <__stm32_exti_isr_9_5>:
	__stm32_exti_isr(5, 10, arg);
 80043e0:	4602      	mov	r2, r0
 80043e2:	210a      	movs	r1, #10
 80043e4:	2005      	movs	r0, #5
 80043e6:	f7fc b9af 	b.w	8000748 <__stm32_exti_isr>

080043ea <__stm32_exti_isr_15_10>:
	__stm32_exti_isr(10, 16, arg);
 80043ea:	4602      	mov	r2, r0
 80043ec:	2110      	movs	r1, #16
 80043ee:	200a      	movs	r0, #10
 80043f0:	f7fc b9aa 	b.w	8000748 <__stm32_exti_isr>

080043f4 <__stm32_exti_isr_16>:
	__stm32_exti_isr(16, 17, arg);
 80043f4:	4602      	mov	r2, r0
 80043f6:	2111      	movs	r1, #17
 80043f8:	2010      	movs	r0, #16
 80043fa:	f7fc b9a5 	b.w	8000748 <__stm32_exti_isr>

080043fe <__stm32_exti_isr_18>:
	__stm32_exti_isr(18, 19, arg);
 80043fe:	4602      	mov	r2, r0
 8004400:	2113      	movs	r1, #19
 8004402:	2012      	movs	r0, #18
 8004404:	f7fc b9a0 	b.w	8000748 <__stm32_exti_isr>

08004408 <__stm32_exti_isr_21>:
	__stm32_exti_isr(21, 22, arg);
 8004408:	4602      	mov	r2, r0
 800440a:	2116      	movs	r1, #22
 800440c:	2015      	movs	r0, #21
 800440e:	f7fc b99b 	b.w	8000748 <__stm32_exti_isr>

08004412 <__stm32_exti_isr_22>:
	__stm32_exti_isr(22, 23, arg);
 8004412:	4602      	mov	r2, r0
 8004414:	2117      	movs	r1, #23
 8004416:	2016      	movs	r0, #22
 8004418:	f7fc b996 	b.w	8000748 <__stm32_exti_isr>

0800441c <__stm32_exti_isr_23>:
	__stm32_exti_isr(23, 24, arg);
 800441c:	4602      	mov	r2, r0
 800441e:	2118      	movs	r1, #24
 8004420:	2017      	movs	r0, #23
 8004422:	f7fc b991 	b.w	8000748 <__stm32_exti_isr>

08004426 <stm32_exti_init>:
      defined(CONFIG_SOC_SERIES_STM32F7X) || \
      defined(CONFIG_SOC_SERIES_STM32L1X) || \
      defined(CONFIG_SOC_SERIES_STM32L4X) || \
      defined(CONFIG_SOC_SERIES_STM32MP1X) || \
      defined(CONFIG_SOC_SERIES_STM32WBX)
	IRQ_CONNECT(EXTI0_IRQn,
 8004426:	2200      	movs	r2, #0
 8004428:	2006      	movs	r0, #6
{
 800442a:	b508      	push	{r3, lr}
	IRQ_CONNECT(EXTI0_IRQn,
 800442c:	4611      	mov	r1, r2
 800442e:	f7fe fc69 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_EXTI0_IRQ_PRI,
		__stm32_exti_isr_0, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(EXTI1_IRQn,
 8004432:	2200      	movs	r2, #0
 8004434:	2007      	movs	r0, #7
 8004436:	4611      	mov	r1, r2
 8004438:	f7fe fc64 	bl	8002d04 <z_irq_priority_set>
	IRQ_CONNECT(EXTI2_TSC_IRQn,
		CONFIG_EXTI_STM32_EXTI2_IRQ_PRI,
		__stm32_exti_isr_2, DEVICE_GET(exti_stm32),
		0);
#else
	IRQ_CONNECT(EXTI2_IRQn,
 800443c:	2200      	movs	r2, #0
 800443e:	2008      	movs	r0, #8
 8004440:	4611      	mov	r1, r2
 8004442:	f7fe fc5f 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_EXTI2_IRQ_PRI,
		__stm32_exti_isr_2, DEVICE_GET(exti_stm32),
		0);
#endif /* CONFIG_SOC_SERIES_STM32F3X */
	IRQ_CONNECT(EXTI3_IRQn,
 8004446:	2200      	movs	r2, #0
 8004448:	2009      	movs	r0, #9
 800444a:	4611      	mov	r1, r2
 800444c:	f7fe fc5a 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_EXTI3_IRQ_PRI,
		__stm32_exti_isr_3, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(EXTI4_IRQn,
 8004450:	2200      	movs	r2, #0
 8004452:	200a      	movs	r0, #10
 8004454:	4611      	mov	r1, r2
 8004456:	f7fe fc55 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_EXTI4_IRQ_PRI,
		__stm32_exti_isr_4, DEVICE_GET(exti_stm32),
		0);
#ifndef CONFIG_SOC_SERIES_STM32MP1X
	IRQ_CONNECT(EXTI9_5_IRQn,
 800445a:	2200      	movs	r2, #0
 800445c:	2017      	movs	r0, #23
 800445e:	4611      	mov	r1, r2
 8004460:	f7fe fc50 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_EXTI9_5_IRQ_PRI,
		__stm32_exti_isr_9_5, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(EXTI15_10_IRQn,
 8004464:	2200      	movs	r2, #0
 8004466:	2028      	movs	r0, #40	; 0x28
 8004468:	4611      	mov	r1, r2
 800446a:	f7fe fc4b 	bl	8002d04 <z_irq_priority_set>
#endif /* CONFIG_SOC_SERIES_STM32MP1X */

#if defined(CONFIG_SOC_SERIES_STM32F2X) || \
      defined(CONFIG_SOC_SERIES_STM32F4X) || \
      defined(CONFIG_SOC_SERIES_STM32F7X)
	IRQ_CONNECT(PVD_IRQn,
 800446e:	2200      	movs	r2, #0
 8004470:	2001      	movs	r0, #1
 8004472:	4611      	mov	r1, r2
 8004474:	f7fe fc46 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_PVD_IRQ_PRI,
		__stm32_exti_isr_16, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(OTG_FS_WKUP_IRQn,
 8004478:	2200      	movs	r2, #0
 800447a:	202a      	movs	r0, #42	; 0x2a
 800447c:	4611      	mov	r1, r2
 800447e:	f7fe fc41 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_OTG_FS_WKUP_IRQ_PRI,
		__stm32_exti_isr_18, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(TAMP_STAMP_IRQn,
 8004482:	2200      	movs	r2, #0
 8004484:	2002      	movs	r0, #2
 8004486:	4611      	mov	r1, r2
 8004488:	f7fe fc3c 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_TAMP_STAMP_IRQ_PRI,
		__stm32_exti_isr_21, DEVICE_GET(exti_stm32),
		0);
	IRQ_CONNECT(RTC_WKUP_IRQn,
 800448c:	2200      	movs	r2, #0
 800448e:	2003      	movs	r0, #3
 8004490:	4611      	mov	r1, r2
 8004492:	f7fe fc37 	bl	8002d04 <z_irq_priority_set>
		CONFIG_EXTI_STM32_RTC_WKUP_IRQ_PRI,
		__stm32_exti_isr_22, DEVICE_GET(exti_stm32),
		0);
#endif
#if CONFIG_SOC_SERIES_STM32F7X
	IRQ_CONNECT(LPTIM1_IRQn,
 8004496:	2200      	movs	r2, #0
 8004498:	205d      	movs	r0, #93	; 0x5d
 800449a:	4611      	mov	r1, r2
 800449c:	f7fe fc32 	bl	8002d04 <z_irq_priority_set>
}
 80044a0:	2000      	movs	r0, #0
 80044a2:	bd08      	pop	{r3, pc}

080044a4 <config_pll_init>:
	pllinit->PLLN = CONFIG_CLOCK_STM32_PLL_N_MULTIPLIER;
 80044a4:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
 80044a8:	2219      	movs	r2, #25
 80044aa:	e9c0 2300 	strd	r2, r3, [r0]
	pllinit->PLLP = pllp(CONFIG_CLOCK_STM32_PLL_P_DIVISOR);
 80044ae:	2300      	movs	r3, #0
 80044b0:	6083      	str	r3, [r0, #8]
}
 80044b2:	4770      	bx	lr

080044b4 <LL_RCC_MSI_Disable>:
 * @brief Function kept for driver genericity
 */
void LL_RCC_MSI_Disable(void)
{
	/* Do nothing */
}
 80044b4:	4770      	bx	lr

080044b6 <BSP_LCD_Init>:
  return (BSP_LCD_InitEx(LCD_ORIENTATION_LANDSCAPE));
 80044b6:	2001      	movs	r0, #1
 80044b8:	f7fc bbc6 	b.w	8000c48 <BSP_LCD_InitEx>

080044bc <HAL_DMA_DeInit>:
{
 80044bc:	b538      	push	{r3, r4, r5, lr}
  if(hdma == NULL)
 80044be:	4605      	mov	r5, r0
 80044c0:	b320      	cbz	r0, 800450c <HAL_DMA_DeInit+0x50>
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80044c2:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 80044c6:	b2e4      	uxtb	r4, r4
 80044c8:	2c02      	cmp	r4, #2
 80044ca:	d01d      	beq.n	8004508 <HAL_DMA_DeInit+0x4c>
  __HAL_DMA_DISABLE(hdma);
 80044cc:	6803      	ldr	r3, [r0, #0]
  hdma->Instance->CR   = 0U;
 80044ce:	2400      	movs	r4, #0
  __HAL_DMA_DISABLE(hdma);
 80044d0:	681a      	ldr	r2, [r3, #0]
 80044d2:	f022 0201 	bic.w	r2, r2, #1
 80044d6:	601a      	str	r2, [r3, #0]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 80044d8:	2221      	movs	r2, #33	; 0x21
  hdma->Instance->CR   = 0U;
 80044da:	601c      	str	r4, [r3, #0]
  hdma->Instance->NDTR = 0U;
 80044dc:	605c      	str	r4, [r3, #4]
  hdma->Instance->PAR  = 0U;
 80044de:	609c      	str	r4, [r3, #8]
  hdma->Instance->M0AR = 0U;
 80044e0:	60dc      	str	r4, [r3, #12]
  hdma->Instance->M1AR = 0U;
 80044e2:	611c      	str	r4, [r3, #16]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 80044e4:	615a      	str	r2, [r3, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80044e6:	f7fc fec5 	bl	8001274 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80044ea:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 80044ec:	233f      	movs	r3, #63	; 0x3f
 80044ee:	4093      	lsls	r3, r2
 80044f0:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80044f2:	656c      	str	r4, [r5, #84]	; 0x54
  __HAL_UNLOCK(hdma);
 80044f4:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
 80044f8:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
  hdma->XferHalfCpltCallback = NULL;
 80044fc:	e9c5 440f 	strd	r4, r4, [r5, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 8004500:	e9c5 4411 	strd	r4, r4, [r5, #68]	; 0x44
  hdma->XferAbortCallback = NULL;
 8004504:	e9c5 4413 	strd	r4, r4, [r5, #76]	; 0x4c
}
 8004508:	4620      	mov	r0, r4
 800450a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800450c:	2401      	movs	r4, #1
 800450e:	e7fb      	b.n	8004508 <HAL_DMA_DeInit+0x4c>

08004510 <DMA2D_SetConfig>:
  * @param  Width      The width of data to be transferred from source to destination.
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
{
 8004510:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8004512:	6804      	ldr	r4, [r0, #0]
 8004514:	9d04      	ldr	r5, [sp, #16]
 8004516:	6c66      	ldr	r6, [r4, #68]	; 0x44
 8004518:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800451c:	f006 4640 	and.w	r6, r6, #3221225472	; 0xc0000000
 8004520:	4333      	orrs	r3, r6
 8004522:	6463      	str	r3, [r4, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8004524:	6843      	ldr	r3, [r0, #4]
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 8004526:	63e2      	str	r2, [r4, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8004528:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800452c:	d130      	bne.n	8004590 <DMA2D_SetConfig+0x80>
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
 800452e:	6886      	ldr	r6, [r0, #8]
 8004530:	b11e      	cbz	r6, 800453a <DMA2D_SetConfig+0x2a>
    {
      tmp = (tmp3 | tmp2 | tmp1| tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
 8004532:	2e01      	cmp	r6, #1
 8004534:	d103      	bne.n	800453e <DMA2D_SetConfig+0x2e>
    {
      tmp = (tmp3 | tmp2 | tmp4);
 8004536:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U );
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
 800453a:	63a1      	str	r1, [r4, #56]	; 0x38
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
 800453c:	bd70      	pop	{r4, r5, r6, pc}
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 800453e:	2e02      	cmp	r6, #2
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
 8004540:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
 8004544:	f401 457f 	and.w	r5, r1, #65280	; 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
 8004548:	b2c8      	uxtb	r0, r1
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 800454a:	d107      	bne.n	800455c <DMA2D_SetConfig+0x4c>
      tmp2 = (tmp2 >> 19U);
 800454c:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10U);
 800454e:	0aad      	lsrs	r5, r5, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
 8004550:	02c9      	lsls	r1, r1, #11
 8004552:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
 8004556:	ea41 01d0 	orr.w	r1, r1, r0, lsr #3
 800455a:	e7ee      	b.n	800453a <DMA2D_SetConfig+0x2a>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 800455c:	2e03      	cmp	r6, #3
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
 800455e:	f001 427f 	and.w	r2, r1, #4278190080	; 0xff000000
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8004562:	d10a      	bne.n	800457a <DMA2D_SetConfig+0x6a>
      tmp2 = (tmp2 >> 19U);
 8004564:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
 8004566:	0aed      	lsrs	r5, r5, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
 8004568:	029b      	lsls	r3, r3, #10
      tmp1 = (tmp1 >> 31U);
 800456a:	0fd1      	lsrs	r1, r2, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
 800456c:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
 8004570:	ea43 03d0 	orr.w	r3, r3, r0, lsr #3
 8004574:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
 8004578:	e7df      	b.n	800453a <DMA2D_SetConfig+0x2a>
      tmp2 = (tmp2 >> 20U);
 800457a:	0d19      	lsrs	r1, r3, #20
      tmp3 = (tmp3 >> 12U);
 800457c:	0b2d      	lsrs	r5, r5, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
 800457e:	0209      	lsls	r1, r1, #8
      tmp1 = (tmp1 >> 28U);
 8004580:	0f13      	lsrs	r3, r2, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
 8004582:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
 8004586:	ea41 1110 	orr.w	r1, r1, r0, lsr #4
 800458a:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
 800458e:	e7d4      	b.n	800453a <DMA2D_SetConfig+0x2a>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
 8004590:	60e1      	str	r1, [r4, #12]
}
 8004592:	e7d3      	b.n	800453c <DMA2D_SetConfig+0x2c>

08004594 <HAL_DMA2D_MspInit>:
}
 8004594:	4770      	bx	lr

08004596 <HAL_DMA2D_Init>:
{
 8004596:	b510      	push	{r4, lr}
  if(hdma2d == NULL)
 8004598:	4604      	mov	r4, r0
 800459a:	b380      	cbz	r0, 80045fe <HAL_DMA2D_Init+0x68>
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 800459c:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80045a0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80045a4:	b91b      	cbnz	r3, 80045ae <HAL_DMA2D_Init+0x18>
    hdma2d->Lock = HAL_UNLOCKED;
 80045a6:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    HAL_DMA2D_MspInit(hdma2d);
 80045aa:	f7ff fff3 	bl	8004594 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 80045ae:	2302      	movs	r3, #2
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 80045b0:	6861      	ldr	r1, [r4, #4]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 80045b2:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 80045b6:	6823      	ldr	r3, [r4, #0]
 80045b8:	681a      	ldr	r2, [r3, #0]
 80045ba:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80045be:	430a      	orrs	r2, r1
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 80045c0:	68a1      	ldr	r1, [r4, #8]
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 80045c2:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 80045c4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80045c6:	f022 0207 	bic.w	r2, r2, #7
 80045ca:	430a      	orrs	r2, r1
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 80045cc:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 80045ce:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 80045d0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80045d2:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 80045d6:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80045da:	430a      	orrs	r2, r1
 80045dc:	641a      	str	r2, [r3, #64]	; 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR,(DMA2D_OPFCCR_AI|DMA2D_OPFCCR_RBS), ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
 80045de:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80045e0:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
 80045e4:	f421 1140 	bic.w	r1, r1, #3145728	; 0x300000
 80045e8:	0552      	lsls	r2, r2, #21
 80045ea:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 80045ee:	2000      	movs	r0, #0
  MODIFY_REG(hdma2d->Instance->OPFCCR,(DMA2D_OPFCCR_AI|DMA2D_OPFCCR_RBS), ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
 80045f0:	430a      	orrs	r2, r1
 80045f2:	635a      	str	r2, [r3, #52]	; 0x34
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 80045f4:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 80045f6:	6560      	str	r0, [r4, #84]	; 0x54
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 80045f8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
}
 80045fc:	bd10      	pop	{r4, pc}
     return HAL_ERROR;
 80045fe:	2001      	movs	r0, #1
 8004600:	e7fc      	b.n	80045fc <HAL_DMA2D_Init+0x66>

08004602 <HAL_DMA2D_Start>:
{
 8004602:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hdma2d);
 8004604:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
{
 8004608:	4605      	mov	r5, r0
  __HAL_LOCK(hdma2d);
 800460a:	2c01      	cmp	r4, #1
 800460c:	f04f 0402 	mov.w	r4, #2
 8004610:	d00f      	beq.n	8004632 <HAL_DMA2D_Start+0x30>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8004612:	f880 4051 	strb.w	r4, [r0, #81]	; 0x51
  __HAL_LOCK(hdma2d);
 8004616:	2601      	movs	r6, #1
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8004618:	9c06      	ldr	r4, [sp, #24]
  __HAL_LOCK(hdma2d);
 800461a:	f880 6050 	strb.w	r6, [r0, #80]	; 0x50
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 800461e:	9400      	str	r4, [sp, #0]
 8004620:	f7ff ff76 	bl	8004510 <DMA2D_SetConfig>
  __HAL_DMA2D_ENABLE(hdma2d);
 8004624:	682a      	ldr	r2, [r5, #0]
  return HAL_OK;
 8004626:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
 8004628:	6813      	ldr	r3, [r2, #0]
 800462a:	4333      	orrs	r3, r6
 800462c:	6013      	str	r3, [r2, #0]
}
 800462e:	b002      	add	sp, #8
 8004630:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdma2d);
 8004632:	4620      	mov	r0, r4
 8004634:	e7fb      	b.n	800462e <HAL_DMA2D_Start+0x2c>

08004636 <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
 8004636:	2300      	movs	r3, #0
{
 8004638:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
 800463a:	9301      	str	r3, [sp, #4]
{
 800463c:	4604      	mov	r4, r0
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
 800463e:	6803      	ldr	r3, [r0, #0]
{
 8004640:	460d      	mov	r5, r1
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
 8004642:	681b      	ldr	r3, [r3, #0]
 8004644:	07db      	lsls	r3, r3, #31
 8004646:	d417      	bmi.n	8004678 <HAL_DMA2D_PollForTransfer+0x42>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
 8004648:	6822      	ldr	r2, [r4, #0]
 800464a:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
 800464c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800464e:	4313      	orrs	r3, r2
  if (layer_start != 0U)
 8004650:	069e      	lsls	r6, r3, #26
 8004652:	d506      	bpl.n	8004662 <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
 8004654:	f7ff fea3 	bl	800439e <HAL_GetTick>
 8004658:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
 800465a:	6823      	ldr	r3, [r4, #0]
 800465c:	685a      	ldr	r2, [r3, #4]
 800465e:	06d2      	lsls	r2, r2, #27
 8004660:	d543      	bpl.n	80046ea <HAL_DMA2D_PollForTransfer+0xb4>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8004662:	6823      	ldr	r3, [r4, #0]
 8004664:	2212      	movs	r2, #18
  __HAL_UNLOCK(hdma2d);
 8004666:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8004668:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
 800466a:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
 800466c:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8004670:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
}
 8004674:	b002      	add	sp, #8
 8004676:	bd70      	pop	{r4, r5, r6, pc}
   tickstart = HAL_GetTick();
 8004678:	f7ff fe91 	bl	800439e <HAL_GetTick>
 800467c:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
 800467e:	6823      	ldr	r3, [r4, #0]
 8004680:	685a      	ldr	r2, [r3, #4]
 8004682:	0792      	lsls	r2, r2, #30
 8004684:	d4e0      	bmi.n	8004648 <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8004686:	685a      	ldr	r2, [r3, #4]
 8004688:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 800468a:	9a01      	ldr	r2, [sp, #4]
 800468c:	f012 0f21 	tst.w	r2, #33	; 0x21
 8004690:	d017      	beq.n	80046c2 <HAL_DMA2D_PollForTransfer+0x8c>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8004692:	9a01      	ldr	r2, [sp, #4]
 8004694:	0695      	lsls	r5, r2, #26
 8004696:	d503      	bpl.n	80046a0 <HAL_DMA2D_PollForTransfer+0x6a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 8004698:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800469a:	f042 0202 	orr.w	r2, r2, #2
 800469e:	6562      	str	r2, [r4, #84]	; 0x54
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 80046a0:	9a01      	ldr	r2, [sp, #4]
 80046a2:	07d0      	lsls	r0, r2, #31
 80046a4:	d503      	bpl.n	80046ae <HAL_DMA2D_PollForTransfer+0x78>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 80046a6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80046a8:	f042 0201 	orr.w	r2, r2, #1
 80046ac:	6562      	str	r2, [r4, #84]	; 0x54
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 80046ae:	2221      	movs	r2, #33	; 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 80046b0:	609a      	str	r2, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 80046b2:	2304      	movs	r3, #4
        return HAL_ERROR;
 80046b4:	2001      	movs	r0, #1
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 80046b6:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        __HAL_UNLOCK(hdma2d);
 80046ba:	2300      	movs	r3, #0
 80046bc:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_ERROR;
 80046c0:	e7d8      	b.n	8004674 <HAL_DMA2D_PollForTransfer+0x3e>
      if(Timeout != HAL_MAX_DELAY)
 80046c2:	1c69      	adds	r1, r5, #1
 80046c4:	d0dc      	beq.n	8004680 <HAL_DMA2D_PollForTransfer+0x4a>
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 80046c6:	f7ff fe6a 	bl	800439e <HAL_GetTick>
 80046ca:	1b80      	subs	r0, r0, r6
 80046cc:	42a8      	cmp	r0, r5
 80046ce:	d801      	bhi.n	80046d4 <HAL_DMA2D_PollForTransfer+0x9e>
 80046d0:	2d00      	cmp	r5, #0
 80046d2:	d1d4      	bne.n	800467e <HAL_DMA2D_PollForTransfer+0x48>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 80046d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 80046d6:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 80046d8:	f043 0320 	orr.w	r3, r3, #32
 80046dc:	6563      	str	r3, [r4, #84]	; 0x54
          __HAL_UNLOCK(hdma2d);
 80046de:	2300      	movs	r3, #0
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 80046e0:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
          __HAL_UNLOCK(hdma2d);
 80046e4:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
          return HAL_TIMEOUT;
 80046e8:	e7c4      	b.n	8004674 <HAL_DMA2D_PollForTransfer+0x3e>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 80046ea:	685a      	ldr	r2, [r3, #4]
 80046ec:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 80046ee:	9a01      	ldr	r2, [sp, #4]
 80046f0:	f012 0f29 	tst.w	r2, #41	; 0x29
 80046f4:	d016      	beq.n	8004724 <HAL_DMA2D_PollForTransfer+0xee>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
 80046f6:	9a01      	ldr	r2, [sp, #4]
 80046f8:	0716      	lsls	r6, r2, #28
 80046fa:	d503      	bpl.n	8004704 <HAL_DMA2D_PollForTransfer+0xce>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
 80046fc:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80046fe:	f042 0204 	orr.w	r2, r2, #4
 8004702:	6562      	str	r2, [r4, #84]	; 0x54
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8004704:	9a01      	ldr	r2, [sp, #4]
 8004706:	0695      	lsls	r5, r2, #26
 8004708:	d503      	bpl.n	8004712 <HAL_DMA2D_PollForTransfer+0xdc>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 800470a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800470c:	f042 0202 	orr.w	r2, r2, #2
 8004710:	6562      	str	r2, [r4, #84]	; 0x54
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 8004712:	9a01      	ldr	r2, [sp, #4]
 8004714:	07d0      	lsls	r0, r2, #31
 8004716:	d503      	bpl.n	8004720 <HAL_DMA2D_PollForTransfer+0xea>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 8004718:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800471a:	f042 0201 	orr.w	r2, r2, #1
 800471e:	6562      	str	r2, [r4, #84]	; 0x54
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8004720:	2229      	movs	r2, #41	; 0x29
 8004722:	e7c5      	b.n	80046b0 <HAL_DMA2D_PollForTransfer+0x7a>
      if(Timeout != HAL_MAX_DELAY)
 8004724:	1c69      	adds	r1, r5, #1
 8004726:	d099      	beq.n	800465c <HAL_DMA2D_PollForTransfer+0x26>
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 8004728:	f7ff fe39 	bl	800439e <HAL_GetTick>
 800472c:	1b80      	subs	r0, r0, r6
 800472e:	42a8      	cmp	r0, r5
 8004730:	d8d0      	bhi.n	80046d4 <HAL_DMA2D_PollForTransfer+0x9e>
 8004732:	2d00      	cmp	r5, #0
 8004734:	d191      	bne.n	800465a <HAL_DMA2D_PollForTransfer+0x24>
 8004736:	e7cd      	b.n	80046d4 <HAL_DMA2D_PollForTransfer+0x9e>

08004738 <DSI_ShortWrite>:
{
 8004738:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800473c:	4607      	mov	r7, r0
 800473e:	460d      	mov	r5, r1
 8004740:	4614      	mov	r4, r2
 8004742:	461e      	mov	r6, r3
  tickstart = HAL_GetTick();
 8004744:	f7ff fe2b 	bl	800439e <HAL_GetTick>
 8004748:	4680      	mov	r8, r0
  while((hdsi->Instance->GPSR & DSI_GPSR_CMDFE) == 0U)
 800474a:	683b      	ldr	r3, [r7, #0]
 800474c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800474e:	07d2      	lsls	r2, r2, #31
 8004750:	d50a      	bpl.n	8004768 <DSI_ShortWrite+0x30>
  hdsi->Instance->GHCR = (Mode | (ChannelID << 6U) | (Param1 << 8U) | (Param2 << 16U));
 8004752:	ea44 2106 	orr.w	r1, r4, r6, lsl #8
 8004756:	9c06      	ldr	r4, [sp, #24]
  return HAL_OK;
 8004758:	2000      	movs	r0, #0
  hdsi->Instance->GHCR = (Mode | (ChannelID << 6U) | (Param1 << 8U) | (Param2 << 16U));
 800475a:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 800475e:	ea41 1185 	orr.w	r1, r1, r5, lsl #6
 8004762:	66d9      	str	r1, [r3, #108]	; 0x6c
}
 8004764:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((HAL_GetTick() - tickstart ) > DSI_TIMEOUT_VALUE)
 8004768:	f7ff fe19 	bl	800439e <HAL_GetTick>
 800476c:	eba0 0008 	sub.w	r0, r0, r8
 8004770:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004774:	d9e9      	bls.n	800474a <DSI_ShortWrite+0x12>
      return HAL_TIMEOUT;
 8004776:	2003      	movs	r0, #3
 8004778:	e7f4      	b.n	8004764 <DSI_ShortWrite+0x2c>

0800477a <HAL_DSI_MspInit>:
}
 800477a:	4770      	bx	lr

0800477c <HAL_DSI_MspDeInit>:
 800477c:	4770      	bx	lr

0800477e <HAL_DSI_DeInit>:
{
 800477e:	b530      	push	{r4, r5, lr}
  if (hdsi == NULL)
 8004780:	4605      	mov	r5, r0
{
 8004782:	b085      	sub	sp, #20
  if (hdsi == NULL)
 8004784:	2800      	cmp	r0, #0
 8004786:	d042      	beq.n	800480e <HAL_DSI_DeInit+0x90>
  hdsi->State = HAL_DSI_STATE_BUSY;
 8004788:	2303      	movs	r3, #3
  __HAL_DSI_WRAPPER_DISABLE(hdsi);
 800478a:	2400      	movs	r4, #0
  hdsi->State = HAL_DSI_STATE_BUSY;
 800478c:	7443      	strb	r3, [r0, #17]
  __HAL_DSI_WRAPPER_DISABLE(hdsi);
 800478e:	6803      	ldr	r3, [r0, #0]
 8004790:	9400      	str	r4, [sp, #0]
 8004792:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 8004796:	f022 0208 	bic.w	r2, r2, #8
 800479a:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
 800479e:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 80047a2:	f002 0208 	and.w	r2, r2, #8
 80047a6:	9200      	str	r2, [sp, #0]
 80047a8:	9a00      	ldr	r2, [sp, #0]
  __HAL_DSI_DISABLE(hdsi);
 80047aa:	9401      	str	r4, [sp, #4]
 80047ac:	685a      	ldr	r2, [r3, #4]
 80047ae:	f022 0201 	bic.w	r2, r2, #1
 80047b2:	605a      	str	r2, [r3, #4]
 80047b4:	685a      	ldr	r2, [r3, #4]
 80047b6:	f002 0201 	and.w	r2, r2, #1
 80047ba:	9201      	str	r2, [sp, #4]
 80047bc:	9a01      	ldr	r2, [sp, #4]
  hdsi->Instance->PCTLR &= ~(DSI_PCTLR_CKE | DSI_PCTLR_DEN);
 80047be:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 80047c2:	f022 0206 	bic.w	r2, r2, #6
 80047c6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  __HAL_DSI_PLL_DISABLE(hdsi);
 80047ca:	9402      	str	r4, [sp, #8]
 80047cc:	f8d3 2430 	ldr.w	r2, [r3, #1072]	; 0x430
 80047d0:	f022 0201 	bic.w	r2, r2, #1
 80047d4:	f8c3 2430 	str.w	r2, [r3, #1072]	; 0x430
 80047d8:	f8d3 2430 	ldr.w	r2, [r3, #1072]	; 0x430
 80047dc:	f002 0201 	and.w	r2, r2, #1
 80047e0:	9202      	str	r2, [sp, #8]
 80047e2:	9a02      	ldr	r2, [sp, #8]
  __HAL_DSI_REG_DISABLE(hdsi);
 80047e4:	9403      	str	r4, [sp, #12]
 80047e6:	f8d3 2430 	ldr.w	r2, [r3, #1072]	; 0x430
 80047ea:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80047ee:	f8c3 2430 	str.w	r2, [r3, #1072]	; 0x430
 80047f2:	f8d3 3430 	ldr.w	r3, [r3, #1072]	; 0x430
 80047f6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80047fa:	9303      	str	r3, [sp, #12]
 80047fc:	9b03      	ldr	r3, [sp, #12]
  HAL_DSI_MspDeInit(hdsi);
 80047fe:	f7ff ffbd 	bl	800477c <HAL_DSI_MspDeInit>
  return HAL_OK;
 8004802:	4620      	mov	r0, r4
  hdsi->ErrorCode = HAL_DSI_ERROR_NONE;
 8004804:	616c      	str	r4, [r5, #20]
  __HAL_UNLOCK(hdsi);
 8004806:	742c      	strb	r4, [r5, #16]
  hdsi->State = HAL_DSI_STATE_RESET;
 8004808:	746c      	strb	r4, [r5, #17]
}
 800480a:	b005      	add	sp, #20
 800480c:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 800480e:	2001      	movs	r0, #1
 8004810:	e7fb      	b.n	800480a <HAL_DSI_DeInit+0x8c>

08004812 <HAL_DSI_Start>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DSI_Start(DSI_HandleTypeDef *hdsi)
{
  /* Process locked */
  __HAL_LOCK(hdsi);
 8004812:	7c03      	ldrb	r3, [r0, #16]
{
 8004814:	b082      	sub	sp, #8
  __HAL_LOCK(hdsi);
 8004816:	2b01      	cmp	r3, #1
 8004818:	d01c      	beq.n	8004854 <HAL_DSI_Start+0x42>

  /* Enable the DSI host */
  __HAL_DSI_ENABLE(hdsi);
 800481a:	6802      	ldr	r2, [r0, #0]
 800481c:	2300      	movs	r3, #0
 800481e:	9300      	str	r3, [sp, #0]
 8004820:	6851      	ldr	r1, [r2, #4]
 8004822:	f041 0101 	orr.w	r1, r1, #1
 8004826:	6051      	str	r1, [r2, #4]
 8004828:	6851      	ldr	r1, [r2, #4]
 800482a:	f001 0101 	and.w	r1, r1, #1
 800482e:	9100      	str	r1, [sp, #0]
 8004830:	9900      	ldr	r1, [sp, #0]

  /* Enable the DSI wrapper */
  __HAL_DSI_WRAPPER_ENABLE(hdsi);
 8004832:	9301      	str	r3, [sp, #4]
 8004834:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
 8004838:	f041 0108 	orr.w	r1, r1, #8
 800483c:	f8c2 1404 	str.w	r1, [r2, #1028]	; 0x404
 8004840:	f8d2 2404 	ldr.w	r2, [r2, #1028]	; 0x404

  /* Process unlocked */
  __HAL_UNLOCK(hdsi);
 8004844:	7403      	strb	r3, [r0, #16]

  return HAL_OK;
 8004846:	4618      	mov	r0, r3
  __HAL_DSI_WRAPPER_ENABLE(hdsi);
 8004848:	f002 0208 	and.w	r2, r2, #8
 800484c:	9201      	str	r2, [sp, #4]
 800484e:	9a01      	ldr	r2, [sp, #4]
}
 8004850:	b002      	add	sp, #8
 8004852:	4770      	bx	lr
  __HAL_LOCK(hdsi);
 8004854:	2002      	movs	r0, #2
 8004856:	e7fb      	b.n	8004850 <HAL_DSI_Start+0x3e>

08004858 <HAL_DSI_ShortWrite>:
HAL_StatusTypeDef HAL_DSI_ShortWrite(DSI_HandleTypeDef *hdsi,
                                     uint32_t ChannelID,
                                     uint32_t Mode,
                                     uint32_t Param1,
                                     uint32_t Param2)
{
 8004858:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_StatusTypeDef status;
  /* Check the parameters */
  assert_param(IS_DSI_SHORT_WRITE_PACKET_TYPE(Mode));

  /* Process locked */
  __HAL_LOCK(hdsi);
 800485a:	7c05      	ldrb	r5, [r0, #16]
{
 800485c:	4604      	mov	r4, r0
  __HAL_LOCK(hdsi);
 800485e:	2d01      	cmp	r5, #1
 8004860:	d009      	beq.n	8004876 <HAL_DSI_ShortWrite+0x1e>
 8004862:	2501      	movs	r5, #1
 8004864:	7405      	strb	r5, [r0, #16]

   status = DSI_ShortWrite(hdsi, ChannelID, Mode, Param1, Param2);
 8004866:	9d06      	ldr	r5, [sp, #24]
 8004868:	9500      	str	r5, [sp, #0]
 800486a:	f7ff ff65 	bl	8004738 <DSI_ShortWrite>

  /* Process unlocked */
  __HAL_UNLOCK(hdsi);
 800486e:	2300      	movs	r3, #0
 8004870:	7423      	strb	r3, [r4, #16]

  return status;
}
 8004872:	b003      	add	sp, #12
 8004874:	bd30      	pop	{r4, r5, pc}
  __HAL_LOCK(hdsi);
 8004876:	2002      	movs	r0, #2
 8004878:	e7fb      	b.n	8004872 <HAL_DSI_ShortWrite+0x1a>

0800487a <HAL_DSI_LongWrite>:
                                    uint32_t ChannelID,
                                    uint32_t Mode,
                                    uint32_t NbParams,
                                    uint32_t Param1,
                                    uint8_t *ParametersTable)
{
 800487a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800487e:	461c      	mov	r4, r3
  uint32_t tickstart;
  uint32_t fifoword;
  uint8_t *pparams = ParametersTable;

  /* Process locked */
  __HAL_LOCK(hdsi);
 8004880:	7c03      	ldrb	r3, [r0, #16]
{
 8004882:	4606      	mov	r6, r0
 8004884:	460f      	mov	r7, r1
  __HAL_LOCK(hdsi);
 8004886:	2b01      	cmp	r3, #1
{
 8004888:	4615      	mov	r5, r2
 800488a:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  __HAL_LOCK(hdsi);
 800488e:	d052      	beq.n	8004936 <HAL_DSI_LongWrite+0xbc>
 8004890:	2301      	movs	r3, #1
 8004892:	7403      	strb	r3, [r0, #16]

  /* Check the parameters */
  assert_param(IS_DSI_LONG_WRITE_PACKET_TYPE(Mode));

  /* Get tick */
  tickstart = HAL_GetTick();
 8004894:	f7ff fd83 	bl	800439e <HAL_GetTick>
 8004898:	4683      	mov	fp, r0

  /* Wait for Command FIFO Empty */
  while ((hdsi->Instance->GPSR & DSI_GPSR_CMDFE) == 0U)
 800489a:	6832      	ldr	r2, [r6, #0]
 800489c:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800489e:	f013 0a01 	ands.w	sl, r3, #1
 80048a2:	d019      	beq.n	80048d8 <HAL_DSI_LongWrite+0x5e>
    }
  }

  /* Set the DCS code on payload byte 1, and the other parameters on the write FIFO command*/
  fifoword = Param1;
  nbBytes = (NbParams < 3U) ? NbParams : 3U;
 80048a4:	2c03      	cmp	r4, #3
 80048a6:	4620      	mov	r0, r4

  for (count = 0U; count < nbBytes; count++)
 80048a8:	f04f 0300 	mov.w	r3, #0
  nbBytes = (NbParams < 3U) ? NbParams : 3U;
 80048ac:	bf28      	it	cs
 80048ae:	2003      	movcs	r0, #3
  for (count = 0U; count < nbBytes; count++)
 80048b0:	4283      	cmp	r3, r0
 80048b2:	d11d      	bne.n	80048f0 <HAL_DSI_LongWrite+0x76>
  {
    fifoword |= (((uint32_t)(*(pparams + count))) << (8U + (8U * count)));
  }
  hdsi->Instance->GPDR = fifoword;

  uicounter = NbParams - nbBytes;
 80048b4:	1ae0      	subs	r0, r4, r3
  pparams += nbBytes;
 80048b6:	4443      	add	r3, r8
  hdsi->Instance->GPDR = fifoword;
 80048b8:	f8c2 9070 	str.w	r9, [r2, #112]	; 0x70
  /* Set the Next parameters on the write FIFO command*/
  while (uicounter != 0U)
 80048bc:	bb10      	cbnz	r0, 8004904 <HAL_DSI_LongWrite+0x8a>

  /* Configure the packet to send a long DCS command */
  DSI_ConfigPacketHeader(hdsi->Instance,
                         ChannelID,
                         Mode,
                         ((NbParams + 1U) & 0x00FFU),
 80048be:	3401      	adds	r4, #1
  DSIx->GHCR = (DataType | (ChannelID << 6U) | (Data0 << 8U) | (Data1 << 16U));
 80048c0:	ea45 1587 	orr.w	r5, r5, r7, lsl #6
 80048c4:	0223      	lsls	r3, r4, #8
 80048c6:	0224      	lsls	r4, r4, #8
 80048c8:	b29b      	uxth	r3, r3
 80048ca:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
 80048ce:	431d      	orrs	r5, r3
 80048d0:	432c      	orrs	r4, r5
 80048d2:	66d4      	str	r4, [r2, #108]	; 0x6c
                         (((NbParams + 1U) & 0xFF00U) >> 8U));

  /* Process unlocked */
  __HAL_UNLOCK(hdsi);
 80048d4:	7430      	strb	r0, [r6, #16]

  return HAL_OK;
 80048d6:	e009      	b.n	80048ec <HAL_DSI_LongWrite+0x72>
    if ((HAL_GetTick() - tickstart) > DSI_TIMEOUT_VALUE)
 80048d8:	f7ff fd61 	bl	800439e <HAL_GetTick>
 80048dc:	eba0 000b 	sub.w	r0, r0, fp
 80048e0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80048e4:	d9d9      	bls.n	800489a <HAL_DSI_LongWrite+0x20>
      return HAL_TIMEOUT;
 80048e6:	2003      	movs	r0, #3
      __HAL_UNLOCK(hdsi);
 80048e8:	f886 a010 	strb.w	sl, [r6, #16]
}
 80048ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fifoword |= (((uint32_t)(*(pparams + count))) << (8U + (8U * count)));
 80048f0:	f818 1003 	ldrb.w	r1, [r8, r3]
 80048f4:	3301      	adds	r3, #1
 80048f6:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 80048fa:	fa01 f10c 	lsl.w	r1, r1, ip
 80048fe:	ea49 0901 	orr.w	r9, r9, r1
 8004902:	e7d5      	b.n	80048b0 <HAL_DSI_LongWrite+0x36>
    nbBytes = (uicounter < 4U) ? uicounter : 4U;
 8004904:	2804      	cmp	r0, #4
    fifoword = 0U;
 8004906:	f04f 0c00 	mov.w	ip, #0
    nbBytes = (uicounter < 4U) ? uicounter : 4U;
 800490a:	4686      	mov	lr, r0
    for (count = 0U; count < nbBytes; count++)
 800490c:	4661      	mov	r1, ip
    nbBytes = (uicounter < 4U) ? uicounter : 4U;
 800490e:	bf28      	it	cs
 8004910:	f04f 0e04 	movcs.w	lr, #4
      fifoword |= (((uint32_t)(*(pparams + count))) << (8U * count));
 8004914:	f813 8001 	ldrb.w	r8, [r3, r1]
 8004918:	ea4f 09c1 	mov.w	r9, r1, lsl #3
    for (count = 0U; count < nbBytes; count++)
 800491c:	3101      	adds	r1, #1
      fifoword |= (((uint32_t)(*(pparams + count))) << (8U * count));
 800491e:	fa08 f809 	lsl.w	r8, r8, r9
    for (count = 0U; count < nbBytes; count++)
 8004922:	458e      	cmp	lr, r1
      fifoword |= (((uint32_t)(*(pparams + count))) << (8U * count));
 8004924:	ea4c 0c08 	orr.w	ip, ip, r8
    for (count = 0U; count < nbBytes; count++)
 8004928:	d1f4      	bne.n	8004914 <HAL_DSI_LongWrite+0x9a>
    hdsi->Instance->GPDR = fifoword;
 800492a:	f8c2 c070 	str.w	ip, [r2, #112]	; 0x70
    uicounter -= nbBytes;
 800492e:	eba0 000e 	sub.w	r0, r0, lr
    pparams += nbBytes;
 8004932:	4473      	add	r3, lr
 8004934:	e7c2      	b.n	80048bc <HAL_DSI_LongWrite+0x42>
  __HAL_LOCK(hdsi);
 8004936:	2002      	movs	r0, #2
 8004938:	e7d8      	b.n	80048ec <HAL_DSI_LongWrite+0x72>

0800493a <LTDC_SetConfig>:
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800493a:	01d2      	lsls	r2, r2, #7
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800493c:	f8d1 c000 	ldr.w	ip, [r1]
{
 8004940:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004944:	3284      	adds	r2, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8004946:	6804      	ldr	r4, [r0, #0]
 8004948:	684f      	ldr	r7, [r1, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800494a:	f10c 0601 	add.w	r6, ip, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800494e:	18a3      	adds	r3, r4, r2
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8004950:	68e5      	ldr	r5, [r4, #12]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8004952:	f04f 0e00 	mov.w	lr, #0
  tmp2 = (pLayerCfg->Alpha0 << 24U);
 8004956:	f8d1 9018 	ldr.w	r9, [r1, #24]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800495a:	6858      	ldr	r0, [r3, #4]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800495c:	f3c5 450b 	ubfx	r5, r5, #16, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004960:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8004964:	443d      	add	r5, r7
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004966:	6058      	str	r0, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8004968:	68e0      	ldr	r0, [r4, #12]
 800496a:	f3c0 400b 	ubfx	r0, r0, #16, #12
 800496e:	4430      	add	r0, r6
 8004970:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004974:	68cd      	ldr	r5, [r1, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8004976:	6058      	str	r0, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004978:	68e0      	ldr	r0, [r4, #12]
 800497a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 800497e:	4405      	add	r5, r0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8004980:	6898      	ldr	r0, [r3, #8]
 8004982:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 8004986:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8004988:	6888      	ldr	r0, [r1, #8]
 800498a:	68e6      	ldr	r6, [r4, #12]
 800498c:	3001      	adds	r0, #1
 800498e:	f3c6 060a 	ubfx	r6, r6, #0, #11
 8004992:	4430      	add	r0, r6
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8004994:	690e      	ldr	r6, [r1, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8004996:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800499a:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 800499c:	6918      	ldr	r0, [r3, #16]
 800499e:	f020 0007 	bic.w	r0, r0, #7
 80049a2:	6118      	str	r0, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80049a4:	611e      	str	r6, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80049a6:	699d      	ldr	r5, [r3, #24]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 80049a8:	f891 0032 	ldrb.w	r0, [r1, #50]	; 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 80049ac:	f891 8031 	ldrb.w	r8, [r1, #49]	; 0x31
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80049b0:	f8c3 e018 	str.w	lr, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80049b4:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 80049b8:	ea45 6509 	orr.w	r5, r5, r9, lsl #24
 80049bc:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
 80049c0:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 80049c4:	619d      	str	r5, [r3, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 80049c6:	6958      	ldr	r0, [r3, #20]
 80049c8:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
 80049cc:	6158      	str	r0, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80049ce:	6948      	ldr	r0, [r1, #20]
 80049d0:	6158      	str	r0, [r3, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80049d2:	69d8      	ldr	r0, [r3, #28]
 80049d4:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
 80049d8:	f020 0007 	bic.w	r0, r0, #7
 80049dc:	61d8      	str	r0, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80049de:	e9d1 5007 	ldrd	r5, r0, [r1, #28]
 80049e2:	4305      	orrs	r5, r0
 80049e4:	61dd      	str	r5, [r3, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80049e6:	6a98      	ldr	r0, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80049e8:	6a48      	ldr	r0, [r1, #36]	; 0x24
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80049ea:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80049ee:	6298      	str	r0, [r3, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 80049f0:	b31e      	cbz	r6, 8004a3a <LTDC_SetConfig+0x100>
  {
    tmp = 4U;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 80049f2:	2e01      	cmp	r6, #1
 80049f4:	d023      	beq.n	8004a3e <LTDC_SetConfig+0x104>
  {
    tmp = 3U;
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 80049f6:	1eb0      	subs	r0, r6, #2
 80049f8:	2802      	cmp	r0, #2
 80049fa:	d922      	bls.n	8004a42 <LTDC_SetConfig+0x108>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 80049fc:	2e07      	cmp	r6, #7
  {
    tmp = 2U;
  }
  else
  {
    tmp = 1U;
 80049fe:	bf0c      	ite	eq
 8004a00:	2002      	moveq	r0, #2
 8004a02:	2001      	movne	r0, #1
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8004a04:	6add      	ldr	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004a06:	eba7 070c 	sub.w	r7, r7, ip
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8004a0a:	f005 25e0 	and.w	r5, r5, #3758153728	; 0xe000e000
 8004a0e:	62dd      	str	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004a10:	6a8d      	ldr	r5, [r1, #40]	; 0x28
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8004a12:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004a14:	4345      	muls	r5, r0
 8004a16:	4378      	muls	r0, r7
 8004a18:	3003      	adds	r0, #3
 8004a1a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8004a1e:	62d8      	str	r0, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8004a20:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8004a22:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
 8004a26:	f020 0007 	bic.w	r0, r0, #7
 8004a2a:	6318      	str	r0, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8004a2c:	6319      	str	r1, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8004a2e:	58a3      	ldr	r3, [r4, r2]
 8004a30:	f043 0301 	orr.w	r3, r3, #1
 8004a34:	50a3      	str	r3, [r4, r2]
}
 8004a36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tmp = 4U;
 8004a3a:	2004      	movs	r0, #4
 8004a3c:	e7e2      	b.n	8004a04 <LTDC_SetConfig+0xca>
    tmp = 3U;
 8004a3e:	2003      	movs	r0, #3
 8004a40:	e7e0      	b.n	8004a04 <LTDC_SetConfig+0xca>
    tmp = 2U;
 8004a42:	2002      	movs	r0, #2
 8004a44:	e7de      	b.n	8004a04 <LTDC_SetConfig+0xca>

08004a46 <HAL_LTDC_MspInit>:
}
 8004a46:	4770      	bx	lr

08004a48 <HAL_LTDC_ConfigLayer>:
{
 8004a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
 8004a4a:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
{
 8004a4e:	4606      	mov	r6, r0
 8004a50:	468c      	mov	ip, r1
 8004a52:	4696      	mov	lr, r2
  __HAL_LOCK(hltdc);
 8004a54:	2b01      	cmp	r3, #1
 8004a56:	f04f 0002 	mov.w	r0, #2
 8004a5a:	d01d      	beq.n	8004a98 <HAL_LTDC_ConfigLayer+0x50>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8004a5c:	2434      	movs	r4, #52	; 0x34
 8004a5e:	460d      	mov	r5, r1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8004a60:	f886 00a1 	strb.w	r0, [r6, #161]	; 0xa1
  __HAL_LOCK(hltdc);
 8004a64:	2701      	movs	r7, #1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8004a66:	fb04 6402 	mla	r4, r4, r2, r6
  __HAL_LOCK(hltdc);
 8004a6a:	f886 70a0 	strb.w	r7, [r6, #160]	; 0xa0
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8004a6e:	3438      	adds	r4, #56	; 0x38
 8004a70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004a74:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a76:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004a78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a7a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004a7c:	682b      	ldr	r3, [r5, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8004a7e:	4630      	mov	r0, r6
 8004a80:	4672      	mov	r2, lr
 8004a82:	4661      	mov	r1, ip
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8004a84:	6023      	str	r3, [r4, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8004a86:	f7ff ff58 	bl	800493a <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8004a8a:	6833      	ldr	r3, [r6, #0]
  __HAL_UNLOCK(hltdc);
 8004a8c:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8004a8e:	625f      	str	r7, [r3, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
 8004a90:	f886 70a1 	strb.w	r7, [r6, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8004a94:	f886 00a0 	strb.w	r0, [r6, #160]	; 0xa0
}
 8004a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004a9a <HAL_LTDCEx_StructInitFromVideoConfig>:

  /* The following polarity is inverted:
                     LTDC_DEPOLARITY_AL <-> LTDC_DEPOLARITY_AH */

  /* Note 1 : Code in line w/ Current LTDC specification */
  hltdc->Init.DEPolarity = (VidCfg->DEPolarity == DSI_DATA_ENABLE_ACTIVE_HIGH) ? LTDC_DEPOLARITY_AL : LTDC_DEPOLARITY_AH;
 8004a9a:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8004a9c:	2b00      	cmp	r3, #0
 8004a9e:	bf18      	it	ne
 8004aa0:	f04f 5300 	movne.w	r3, #536870912	; 0x20000000
 8004aa4:	60c3      	str	r3, [r0, #12]
  hltdc->Init.VSPolarity = (VidCfg->VSPolarity == DSI_VSYNC_ACTIVE_HIGH) ? LTDC_VSPOLARITY_AH : LTDC_VSPOLARITY_AL;
 8004aa6:	6a0b      	ldr	r3, [r1, #32]
 8004aa8:	2b00      	cmp	r3, #0
 8004aaa:	bf0c      	ite	eq
 8004aac:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
 8004ab0:	2300      	movne	r3, #0
 8004ab2:	6083      	str	r3, [r0, #8]
  hltdc->Init.HSPolarity = (VidCfg->HSPolarity == DSI_HSYNC_ACTIVE_HIGH) ? LTDC_HSPOLARITY_AH : LTDC_HSPOLARITY_AL;
 8004ab4:	69cb      	ldr	r3, [r1, #28]
 8004ab6:	2b00      	cmp	r3, #0
 8004ab8:	bf0c      	ite	eq
 8004aba:	f04f 4300 	moveq.w	r3, #2147483648	; 0x80000000
 8004abe:	2300      	movne	r3, #0
 8004ac0:	6043      	str	r3, [r0, #4]
  /* hltdc->Init.DEPolarity = VidCfg->DEPolarity << 29;
     hltdc->Init.VSPolarity = VidCfg->VSPolarity << 29;
     hltdc->Init.HSPolarity = VidCfg->HSPolarity << 29; */

  /* Retrieve vertical timing parameters from DSI */
  hltdc->Init.VerticalSync       = VidCfg->VerticalSyncActive - 1U;
 8004ac2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8004ac4:	1e5a      	subs	r2, r3, #1
 8004ac6:	6182      	str	r2, [r0, #24]
  hltdc->Init.AccumulatedVBP     = VidCfg->VerticalSyncActive + VidCfg->VerticalBackPorch - 1U;
 8004ac8:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 8004aca:	4413      	add	r3, r2
 8004acc:	1e5a      	subs	r2, r3, #1
 8004ace:	6202      	str	r2, [r0, #32]
  hltdc->Init.AccumulatedActiveH = VidCfg->VerticalSyncActive + VidCfg->VerticalBackPorch + VidCfg->VerticalActive - 1U;
 8004ad0:	6c0a      	ldr	r2, [r1, #64]	; 0x40
 8004ad2:	4413      	add	r3, r2
 8004ad4:	1e5a      	subs	r2, r3, #1
 8004ad6:	6282      	str	r2, [r0, #40]	; 0x28
  hltdc->Init.TotalHeigh         = VidCfg->VerticalSyncActive + VidCfg->VerticalBackPorch + VidCfg->VerticalActive + VidCfg->VerticalFrontPorch - 1U;
 8004ad8:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 8004ada:	3a01      	subs	r2, #1
 8004adc:	4413      	add	r3, r2
 8004ade:	6303      	str	r3, [r0, #48]	; 0x30

  return HAL_OK;
}
 8004ae0:	2000      	movs	r0, #0
 8004ae2:	4770      	bx	lr

08004ae4 <HAL_SDRAM_MspInit>:
  UNUSED(hsdram);

  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */
}
 8004ae4:	4770      	bx	lr

08004ae6 <HAL_SDRAM_Init>:
{
 8004ae6:	b538      	push	{r3, r4, r5, lr}
 8004ae8:	460d      	mov	r5, r1
  if(hsdram == NULL)
 8004aea:	4604      	mov	r4, r0
 8004aec:	b1c8      	cbz	r0, 8004b22 <HAL_SDRAM_Init+0x3c>
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8004aee:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004af2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004af6:	b91b      	cbnz	r3, 8004b00 <HAL_SDRAM_Init+0x1a>
    hsdram->Lock = HAL_UNLOCKED;
 8004af8:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 8004afc:	f7ff fff2 	bl	8004ae4 <HAL_SDRAM_MspInit>
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b00:	2302      	movs	r3, #2
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8004b02:	1d21      	adds	r1, r4, #4
 8004b04:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b06:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8004b0a:	f7fd fa51 	bl	8001fb0 <FMC_SDRAM_Init>
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 8004b0e:	6862      	ldr	r2, [r4, #4]
 8004b10:	4629      	mov	r1, r5
 8004b12:	6820      	ldr	r0, [r4, #0]
 8004b14:	f000 f830 	bl	8004b78 <FMC_SDRAM_Timing_Init>
  hsdram->State = HAL_SDRAM_STATE_READY;
 8004b18:	2301      	movs	r3, #1
  return HAL_OK;
 8004b1a:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 8004b1c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8004b20:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8004b22:	2001      	movs	r0, #1
 8004b24:	e7fc      	b.n	8004b20 <HAL_SDRAM_Init+0x3a>

08004b26 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8004b26:	b538      	push	{r3, r4, r5, lr}
 8004b28:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8004b2a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
{
 8004b2e:	460d      	mov	r5, r1
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8004b30:	b2c0      	uxtb	r0, r0
 8004b32:	2802      	cmp	r0, #2
 8004b34:	d00d      	beq.n	8004b52 <HAL_SDRAM_SendCommand+0x2c>
  {
    return HAL_BUSY;
  }

  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b36:	2302      	movs	r3, #2

  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8004b38:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b3a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8004b3e:	f000 f85f 	bl	8004c00 <FMC_SDRAM_SendCommand>

  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8004b42:	682b      	ldr	r3, [r5, #0]
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  }

  return HAL_OK;
 8004b44:	2000      	movs	r0, #0
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8004b46:	2b02      	cmp	r3, #2
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 8004b48:	bf0c      	ite	eq
 8004b4a:	2305      	moveq	r3, #5
    hsdram->State = HAL_SDRAM_STATE_READY;
 8004b4c:	2301      	movne	r3, #1
 8004b4e:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8004b52:	bd38      	pop	{r3, r4, r5, pc}

08004b54 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 8004b54:	b510      	push	{r4, lr}
 8004b56:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8004b58:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8004b5c:	b2c0      	uxtb	r0, r0
 8004b5e:	2802      	cmp	r0, #2
 8004b60:	d009      	beq.n	8004b76 <HAL_SDRAM_ProgramRefreshRate+0x22>
  {
    return HAL_BUSY;
  }

  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b62:	2302      	movs	r3, #2

  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8004b64:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004b66:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8004b6a:	f000 f85c 	bl	8004c26 <FMC_SDRAM_ProgramRefreshRate>

  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8004b6e:	2301      	movs	r3, #1

  return HAL_OK;
 8004b70:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 8004b72:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8004b76:	bd10      	pop	{r4, pc}

08004b78 <FMC_SDRAM_Timing_Init>:
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank != FMC_SDRAM_BANK2)
 8004b78:	68cb      	ldr	r3, [r1, #12]
 8004b7a:	2a01      	cmp	r2, #1
{
 8004b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b7e:	680c      	ldr	r4, [r1, #0]
 8004b80:	f103 37ff 	add.w	r7, r3, #4294967295	; 0xffffffff
 8004b84:	694b      	ldr	r3, [r1, #20]
 8004b86:	688e      	ldr	r6, [r1, #8]
 8004b88:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
 8004b8c:	690d      	ldr	r5, [r1, #16]
 8004b8e:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8004b92:	684c      	ldr	r4, [r1, #4]
 8004b94:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
 8004b98:	6989      	ldr	r1, [r1, #24]
 8004b9a:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8004b9e:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8004ba2:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 8004ba6:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
 8004baa:	ea4f 2606 	mov.w	r6, r6, lsl #8
 8004bae:	ea4f 1404 	mov.w	r4, r4, lsl #4
 8004bb2:	ea4f 4505 	mov.w	r5, r5, lsl #16
 8004bb6:	ea4f 6101 	mov.w	r1, r1, lsl #24
 8004bba:	ea43 3307 	orr.w	r3, r3, r7, lsl #12
  if (Bank != FMC_SDRAM_BANK2)
 8004bbe:	d00c      	beq.n	8004bda <FMC_SDRAM_Timing_Init+0x62>
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));

    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bc0:	ea43 030c 	orr.w	r3, r3, ip
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8004bc4:	6882      	ldr	r2, [r0, #8]
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bc6:	4323      	orrs	r3, r4
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8004bc8:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bcc:	4333      	orrs	r3, r6
 8004bce:	432b      	orrs	r3, r5
 8004bd0:	430b      	orrs	r3, r1
 8004bd2:	4313      	orrs	r3, r2
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8004bd4:	6083      	str	r3, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  }

  return HAL_OK;
}
 8004bd6:	2000      	movs	r0, #0
 8004bd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8004bda:	6887      	ldr	r7, [r0, #8]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bdc:	ea44 0206 	orr.w	r2, r4, r6
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8004be0:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004be4:	ea42 020c 	orr.w	r2, r2, ip
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8004be8:	f427 4770 	bic.w	r7, r7, #61440	; 0xf000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bec:	432a      	orrs	r2, r5
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8004bee:	433b      	orrs	r3, r7
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 8004bf0:	68c7      	ldr	r7, [r0, #12]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bf2:	430a      	orrs	r2, r1
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8004bf4:	f007 4770 	and.w	r7, r7, #4026531840	; 0xf0000000
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8004bf8:	6083      	str	r3, [r0, #8]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8004bfa:	433a      	orrs	r2, r7
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8004bfc:	60c2      	str	r2, [r0, #12]
 8004bfe:	e7ea      	b.n	8004bd6 <FMC_SDRAM_Timing_Init+0x5e>

08004c00 <FMC_SDRAM_SendCommand>:
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8004c00:	e9d1 3200 	ldrd	r3, r2, [r1]
{
 8004c04:	b513      	push	{r0, r1, r4, lr}
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8004c06:	4313      	orrs	r3, r2
                    ((Command->ModeRegisterDefinition) << 9)
 8004c08:	68ca      	ldr	r2, [r1, #12]
{
 8004c0a:	4604      	mov	r4, r0
  __IO uint32_t tmpr = 0;
 8004c0c:	2000      	movs	r0, #0
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8004c0e:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
 8004c12:	688a      	ldr	r2, [r1, #8]
  __IO uint32_t tmpr = 0;
 8004c14:	9001      	str	r0, [sp, #4]
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8004c16:	3a01      	subs	r2, #1
 8004c18:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8004c1c:	9301      	str	r3, [sp, #4]
                    );

  Device->SDCMR = tmpr;
 8004c1e:	9b01      	ldr	r3, [sp, #4]
 8004c20:	6123      	str	r3, [r4, #16]

  return HAL_OK;
}
 8004c22:	b002      	add	sp, #8
 8004c24:	bd10      	pop	{r4, pc}

08004c26 <FMC_SDRAM_ProgramRefreshRate>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 8004c26:	6943      	ldr	r3, [r0, #20]
 8004c28:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 8004c2c:	6141      	str	r1, [r0, #20]

  return HAL_OK;
}
 8004c2e:	2000      	movs	r0, #0
 8004c30:	4770      	bx	lr

08004c32 <OTM8009A_IO_Delay>:
 8004c32:	f7ff bbb6 	b.w	80043a2 <HAL_Delay>

08004c36 <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	__reserved();
 8004c36:	f7fe b8ab 	b.w	8002d90 <__bus_fault>

08004c3a <z_do_kernel_oops>:

void z_do_kernel_oops(const NANO_ESF *esf)
{
 8004c3a:	4601      	mov	r1, r0
	z_NanoFatalErrorHandler(esf->basic.r0, esf);
 8004c3c:	6800      	ldr	r0, [r0, #0]
 8004c3e:	f7fe b8bb 	b.w	8002db8 <z_NanoFatalErrorHandler>

08004c42 <__nmi>:
 *
 * @return N/A
 */

void __nmi(void)
{
 8004c42:	b508      	push	{r3, lr}
	handler();
 8004c44:	f7fe f966 	bl	8002f14 <z_SysNmiOnReset>
	z_ExcExit();
}
 8004c48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_ExcExit();
 8004c4c:	f7fd be92 	b.w	8002974 <_IntExit>

08004c50 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
 8004c50:	3801      	subs	r0, #1
 8004c52:	3901      	subs	r1, #1
 8004c54:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8004c58:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8004c5c:	4293      	cmp	r3, r2
 8004c5e:	d101      	bne.n	8004c64 <strcmp+0x14>
 8004c60:	2b00      	cmp	r3, #0
 8004c62:	d1f7      	bne.n	8004c54 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
 8004c64:	1a98      	subs	r0, r3, r2
 8004c66:	4770      	bx	lr

08004c68 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
 8004c68:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
 8004c6a:	ea81 0400 	eor.w	r4, r1, r0
 8004c6e:	4603      	mov	r3, r0
 8004c70:	07a5      	lsls	r5, r4, #30
 8004c72:	d00b      	beq.n	8004c8c <memcpy+0x24>
 8004c74:	3b01      	subs	r3, #1
 8004c76:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
 8004c78:	4291      	cmp	r1, r2
 8004c7a:	d11a      	bne.n	8004cb2 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 8004c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
 8004c7e:	2a00      	cmp	r2, #0
 8004c80:	d0fc      	beq.n	8004c7c <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
 8004c82:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
 8004c86:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
 8004c88:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
 8004c8c:	079c      	lsls	r4, r3, #30
 8004c8e:	d1f6      	bne.n	8004c7e <memcpy+0x16>
 8004c90:	0895      	lsrs	r5, r2, #2
 8004c92:	1f1e      	subs	r6, r3, #4
 8004c94:	00ac      	lsls	r4, r5, #2
 8004c96:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
 8004c98:	42b9      	cmp	r1, r7
 8004c9a:	d105      	bne.n	8004ca8 <memcpy+0x40>
 8004c9c:	f06f 0603 	mvn.w	r6, #3
 8004ca0:	4423      	add	r3, r4
 8004ca2:	fb06 2205 	mla	r2, r6, r5, r2
 8004ca6:	e7e5      	b.n	8004c74 <memcpy+0xc>
			*(d_word++) = *(s_word++);
 8004ca8:	f851 cb04 	ldr.w	ip, [r1], #4
 8004cac:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
 8004cb0:	e7f2      	b.n	8004c98 <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
 8004cb2:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004cb6:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 8004cba:	e7dd      	b.n	8004c78 <memcpy+0x10>

08004cbc <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
 8004cbc:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
 8004cbe:	4603      	mov	r3, r0
{
 8004cc0:	b570      	push	{r4, r5, r6, lr}

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
 8004cc2:	079c      	lsls	r4, r3, #30
 8004cc4:	d110      	bne.n	8004ce8 <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
 8004cc6:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
 8004cca:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
 8004cce:	0894      	lsrs	r4, r2, #2
 8004cd0:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 8004cd4:	42b3      	cmp	r3, r6
 8004cd6:	d10d      	bne.n	8004cf4 <memset+0x38>
 8004cd8:	f06f 0503 	mvn.w	r5, #3
 8004cdc:	fb05 2404 	mla	r4, r5, r4, r2
 8004ce0:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
 8004ce2:	42a3      	cmp	r3, r4
 8004ce4:	d109      	bne.n	8004cfa <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 8004ce6:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
 8004ce8:	2a00      	cmp	r2, #0
 8004cea:	d0fc      	beq.n	8004ce6 <memset+0x2a>
		*(d_byte++) = c_byte;
 8004cec:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 8004cf0:	3a01      	subs	r2, #1
 8004cf2:	e7e6      	b.n	8004cc2 <memset+0x6>
		*(d_word++) = c_word;
 8004cf4:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
 8004cf8:	e7ec      	b.n	8004cd4 <memset+0x18>
		*(d_byte++) = c_byte;
 8004cfa:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 8004cfe:	e7f0      	b.n	8004ce2 <memset+0x26>

08004d00 <_stdout_hook_default>:
}
 8004d00:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004d04:	4770      	bx	lr

08004d06 <gpio_stm32_isr>:
	struct gpio_stm32_data *data = dev->driver_data;
 8004d06:	688a      	ldr	r2, [r1, #8]
	if ((BIT(line) & data->cb_pins) != 0) {
 8004d08:	6813      	ldr	r3, [r2, #0]
 8004d0a:	40c3      	lsrs	r3, r0
 8004d0c:	07db      	lsls	r3, r3, #31
{
 8004d0e:	b570      	push	{r4, r5, r6, lr}
 8004d10:	460e      	mov	r6, r1
	if ((BIT(line) & data->cb_pins) != 0) {
 8004d12:	d50f      	bpl.n	8004d34 <gpio_stm32_isr+0x2e>
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8004d14:	6851      	ldr	r1, [r2, #4]
 8004d16:	b169      	cbz	r1, 8004d34 <gpio_stm32_isr+0x2e>
		gpio_fire_callbacks(&data->cb, dev, BIT(line));
 8004d18:	2501      	movs	r5, #1
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8004d1a:	680c      	ldr	r4, [r1, #0]
 8004d1c:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
 8004d1e:	688b      	ldr	r3, [r1, #8]
 8004d20:	421d      	tst	r5, r3
 8004d22:	d003      	beq.n	8004d2c <gpio_stm32_isr+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
 8004d24:	684b      	ldr	r3, [r1, #4]
 8004d26:	462a      	mov	r2, r5
 8004d28:	4630      	mov	r0, r6
 8004d2a:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8004d2c:	b114      	cbz	r4, 8004d34 <gpio_stm32_isr+0x2e>
 8004d2e:	4621      	mov	r1, r4
 8004d30:	6824      	ldr	r4, [r4, #0]
 8004d32:	e7f4      	b.n	8004d1e <gpio_stm32_isr+0x18>
}
 8004d34:	bd70      	pop	{r4, r5, r6, pc}

08004d36 <gpio_stm32_write>:
	const struct gpio_stm32_config *cfg = dev->config->config_info;
 8004d36:	6800      	ldr	r0, [r0, #0]
	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8004d38:	6880      	ldr	r0, [r0, #8]
{
 8004d3a:	b510      	push	{r4, lr}
	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8004d3c:	6800      	ldr	r0, [r0, #0]
	if (access_op != GPIO_ACCESS_BY_PIN) {
 8004d3e:	b941      	cbnz	r1, 8004d52 <gpio_stm32_write+0x1c>
	pinval = 1 << pin;
 8004d40:	2401      	movs	r4, #1
 8004d42:	fa04 f202 	lsl.w	r2, r4, r2
	if (value != 0U) {
 8004d46:	b113      	cbz	r3, 8004d4e <gpio_stm32_write+0x18>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 8004d48:	6182      	str	r2, [r0, #24]
}
 8004d4a:	4608      	mov	r0, r1
 8004d4c:	bd10      	pop	{r4, pc}
 8004d4e:	0412      	lsls	r2, r2, #16
 8004d50:	e7fa      	b.n	8004d48 <gpio_stm32_write+0x12>
		return -ENOTSUP;
 8004d52:	f06f 0122 	mvn.w	r1, #34	; 0x22
 8004d56:	e7f8      	b.n	8004d4a <gpio_stm32_write+0x14>

08004d58 <gpio_stm32_read>:
	const struct gpio_stm32_config *cfg = dev->config->config_info;
 8004d58:	6800      	ldr	r0, [r0, #0]
	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8004d5a:	6880      	ldr	r0, [r0, #8]
{
 8004d5c:	b510      	push	{r4, lr}
	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8004d5e:	6800      	ldr	r0, [r0, #0]
	if (access_op != GPIO_ACCESS_BY_PIN) {
 8004d60:	b931      	cbnz	r1, 8004d70 <gpio_stm32_read+0x18>
  return (uint32_t)(READ_REG(GPIOx->IDR));
 8004d62:	6904      	ldr	r4, [r0, #16]
	*value = (LL_GPIO_ReadInputPort(gpio) >> pin) & 0x1;
 8004d64:	40d4      	lsrs	r4, r2
 8004d66:	f004 0401 	and.w	r4, r4, #1
 8004d6a:	601c      	str	r4, [r3, #0]
}
 8004d6c:	4608      	mov	r0, r1
 8004d6e:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
 8004d70:	f06f 0122 	mvn.w	r1, #34	; 0x22
 8004d74:	e7fa      	b.n	8004d6c <gpio_stm32_read+0x14>

08004d76 <gpio_stm32_manage_callback>:
	struct gpio_stm32_data *data = dev->driver_data;
 8004d76:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
 8004d78:	6858      	ldr	r0, [r3, #4]
{
 8004d7a:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
 8004d7c:	b158      	cbz	r0, 8004d96 <gpio_stm32_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8004d7e:	2400      	movs	r4, #0
 8004d80:	4281      	cmp	r1, r0
 8004d82:	d113      	bne.n	8004dac <gpio_stm32_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
 8004d84:	6808      	ldr	r0, [r1, #0]
 8004d86:	b95c      	cbnz	r4, 8004da0 <gpio_stm32_manage_callback+0x2a>
 8004d88:	689c      	ldr	r4, [r3, #8]
	list->head = node;
 8004d8a:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
 8004d8c:	42a1      	cmp	r1, r4
 8004d8e:	d100      	bne.n	8004d92 <gpio_stm32_manage_callback+0x1c>
	list->tail = node;
 8004d90:	6098      	str	r0, [r3, #8]
	parent->next = child;
 8004d92:	2000      	movs	r0, #0
 8004d94:	6008      	str	r0, [r1, #0]
	if (set) {
 8004d96:	b972      	cbnz	r2, 8004db6 <gpio_stm32_manage_callback+0x40>
	return 0;
 8004d98:	2000      	movs	r0, #0
}
 8004d9a:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8004d9c:	4628      	mov	r0, r5
 8004d9e:	e7ef      	b.n	8004d80 <gpio_stm32_manage_callback+0xa>
	parent->next = child;
 8004da0:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 8004da2:	6898      	ldr	r0, [r3, #8]
 8004da4:	4281      	cmp	r1, r0
	list->tail = node;
 8004da6:	bf08      	it	eq
 8004da8:	609c      	streq	r4, [r3, #8]
 8004daa:	e7f2      	b.n	8004d92 <gpio_stm32_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8004dac:	6805      	ldr	r5, [r0, #0]
	return node->next;
 8004dae:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8004db0:	2d00      	cmp	r5, #0
 8004db2:	d1f3      	bne.n	8004d9c <gpio_stm32_manage_callback+0x26>
			if (!set) {
 8004db4:	b13a      	cbz	r2, 8004dc6 <gpio_stm32_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
 8004db6:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 8004db8:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
 8004dba:	6898      	ldr	r0, [r3, #8]
	list->head = node;
 8004dbc:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 8004dbe:	2800      	cmp	r0, #0
 8004dc0:	d1ea      	bne.n	8004d98 <gpio_stm32_manage_callback+0x22>
	list->tail = node;
 8004dc2:	6099      	str	r1, [r3, #8]
 8004dc4:	e7e9      	b.n	8004d9a <gpio_stm32_manage_callback+0x24>
				return -EINVAL;
 8004dc6:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&data->cb, callback, set);
 8004dca:	e7e6      	b.n	8004d9a <gpio_stm32_manage_callback+0x24>

08004dcc <gpio_stm32_enable_callback>:
	struct gpio_stm32_data *data = dev->driver_data;
 8004dcc:	6880      	ldr	r0, [r0, #8]
	if (access_op != GPIO_ACCESS_BY_PIN) {
 8004dce:	b939      	cbnz	r1, 8004de0 <gpio_stm32_enable_callback+0x14>
	data->cb_pins |= BIT(pin);
 8004dd0:	2301      	movs	r3, #1
 8004dd2:	fa03 f202 	lsl.w	r2, r3, r2
 8004dd6:	6803      	ldr	r3, [r0, #0]
 8004dd8:	4313      	orrs	r3, r2
 8004dda:	6003      	str	r3, [r0, #0]
}
 8004ddc:	4608      	mov	r0, r1
 8004dde:	4770      	bx	lr
		return -ENOTSUP;
 8004de0:	f06f 0122 	mvn.w	r1, #34	; 0x22
 8004de4:	e7fa      	b.n	8004ddc <gpio_stm32_enable_callback+0x10>

08004de6 <gpio_stm32_disable_callback>:
	struct gpio_stm32_data *data = dev->driver_data;
 8004de6:	6880      	ldr	r0, [r0, #8]
	if (access_op != GPIO_ACCESS_BY_PIN) {
 8004de8:	b941      	cbnz	r1, 8004dfc <gpio_stm32_disable_callback+0x16>
	data->cb_pins &= ~BIT(pin);
 8004dea:	2301      	movs	r3, #1
 8004dec:	fa03 f202 	lsl.w	r2, r3, r2
 8004df0:	6803      	ldr	r3, [r0, #0]
 8004df2:	ea23 0302 	bic.w	r3, r3, r2
 8004df6:	6003      	str	r3, [r0, #0]
}
 8004df8:	4608      	mov	r0, r1
 8004dfa:	4770      	bx	lr
		return -ENOTSUP;
 8004dfc:	f06f 0122 	mvn.w	r1, #34	; 0x22
 8004e00:	e7fa      	b.n	8004df8 <gpio_stm32_disable_callback+0x12>

08004e02 <gpio_stm32_flags_to_conf>:
	int direction = flags & GPIO_DIR_MASK;
 8004e02:	f000 0301 	and.w	r3, r0, #1
	if (pincfg == NULL) {
 8004e06:	b1b1      	cbz	r1, 8004e36 <gpio_stm32_flags_to_conf+0x34>
	if (direction == GPIO_DIR_OUT) {
 8004e08:	b123      	cbz	r3, 8004e14 <gpio_stm32_flags_to_conf+0x12>
		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 8004e0a:	2310      	movs	r3, #16
 8004e0c:	600b      	str	r3, [r1, #0]
	return 0;
 8004e0e:	2300      	movs	r3, #0
}
 8004e10:	4618      	mov	r0, r3
 8004e12:	4770      	bx	lr
	int pud = flags & GPIO_PUD_MASK;
 8004e14:	f400 7040 	and.w	r0, r0, #768	; 0x300
		if (pud == GPIO_PUD_PULL_UP) {
 8004e18:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8004e1c:	d103      	bne.n	8004e26 <gpio_stm32_flags_to_conf+0x24>
			*pincfg |= STM32_PINCFG_PULL_UP;
 8004e1e:	f44f 7200 	mov.w	r2, #512	; 0x200
			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8004e22:	600a      	str	r2, [r1, #0]
 8004e24:	e7f4      	b.n	8004e10 <gpio_stm32_flags_to_conf+0xe>
		} else if (pud == GPIO_PUD_PULL_DOWN) {
 8004e26:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8004e2a:	d001      	beq.n	8004e30 <gpio_stm32_flags_to_conf+0x2e>
		*pincfg = STM32_PINCFG_MODE_INPUT;
 8004e2c:	600b      	str	r3, [r1, #0]
 8004e2e:	e7ef      	b.n	8004e10 <gpio_stm32_flags_to_conf+0xe>
			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8004e30:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8004e34:	e7f5      	b.n	8004e22 <gpio_stm32_flags_to_conf+0x20>
		return -EINVAL;
 8004e36:	f06f 0315 	mvn.w	r3, #21
 8004e3a:	e7e9      	b.n	8004e10 <gpio_stm32_flags_to_conf+0xe>

08004e3c <gpio_stm32_configure>:
{
 8004e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 8004e3e:	f002 0530 	and.w	r5, r2, #48	; 0x30
	pinval = 1 << pin;
 8004e42:	2401      	movs	r4, #1
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8004e44:	f8d0 c000 	ldr.w	ip, [r0]
 8004e48:	408c      	lsls	r4, r1
	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 8004e4a:	092e      	lsrs	r6, r5, #4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e4c:	fa94 f7a4 	rbit	r7, r4
  return __builtin_clz(value);
 8004e50:	fab7 f787 	clz	r7, r7
 8004e54:	f04f 0e03 	mov.w	lr, #3
 8004e58:	007f      	lsls	r7, r7, #1
 8004e5a:	fa0e f707 	lsl.w	r7, lr, r7
 8004e5e:	ea2c 0c07 	bic.w	ip, ip, r7
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e62:	fa94 f7a4 	rbit	r7, r4
  return __builtin_clz(value);
 8004e66:	fab7 f787 	clz	r7, r7
	if (STM32_MODER_ALT_MODE == mode) {
 8004e6a:	2d20      	cmp	r5, #32
 8004e6c:	ea4f 0747 	mov.w	r7, r7, lsl #1
 8004e70:	fa06 f607 	lsl.w	r6, r6, r7
 8004e74:	ea46 060c 	orr.w	r6, r6, ip
 8004e78:	6006      	str	r6, [r0, #0]
 8004e7a:	d116      	bne.n	8004eaa <gpio_stm32_configure+0x6e>
		if (pin < 8) {
 8004e7c:	2907      	cmp	r1, #7
 8004e7e:	dc49      	bgt.n	8004f14 <gpio_stm32_configure+0xd8>
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFRL0 << (POSITION_VAL(Pin) * 4U)),
 8004e80:	6a07      	ldr	r7, [r0, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e82:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8004e86:	b10e      	cbz	r6, 8004e8c <gpio_stm32_configure+0x50>
  return __builtin_clz(value);
 8004e88:	fab6 f586 	clz	r5, r6
 8004e8c:	260f      	movs	r6, #15
 8004e8e:	00ad      	lsls	r5, r5, #2
 8004e90:	fa06 f505 	lsl.w	r5, r6, r5
 8004e94:	ea27 0605 	bic.w	r6, r7, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e98:	fa94 f5a4 	rbit	r5, r4
  return __builtin_clz(value);
 8004e9c:	fab5 f585 	clz	r5, r5
 8004ea0:	00ad      	lsls	r5, r5, #2
 8004ea2:	fa03 f505 	lsl.w	r5, r3, r5
 8004ea6:	4335      	orrs	r5, r6
 8004ea8:	6205      	str	r5, [r0, #32]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8004eaa:	6845      	ldr	r5, [r0, #4]
	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8004eac:	f3c2 1380 	ubfx	r3, r2, #6, #1
 8004eb0:	ea25 0504 	bic.w	r5, r5, r4
 8004eb4:	fa03 f101 	lsl.w	r1, r3, r1
	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 8004eb8:	f3c2 13c1 	ubfx	r3, r2, #7, #2
 8004ebc:	4329      	orrs	r1, r5
 8004ebe:	6041      	str	r1, [r0, #4]
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8004ec0:	6885      	ldr	r5, [r0, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004ec2:	fa94 f1a4 	rbit	r1, r4
  return __builtin_clz(value);
 8004ec6:	fab1 f181 	clz	r1, r1
 8004eca:	2603      	movs	r6, #3
 8004ecc:	0049      	lsls	r1, r1, #1
 8004ece:	fa06 f101 	lsl.w	r1, r6, r1
 8004ed2:	ea25 0501 	bic.w	r5, r5, r1
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004ed6:	fa94 f1a4 	rbit	r1, r4
  return __builtin_clz(value);
 8004eda:	fab1 f181 	clz	r1, r1
	LL_GPIO_SetPinPull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 8004ede:	f3c2 2241 	ubfx	r2, r2, #9, #2
 8004ee2:	0049      	lsls	r1, r1, #1
 8004ee4:	408b      	lsls	r3, r1
 8004ee6:	432b      	orrs	r3, r5
 8004ee8:	6083      	str	r3, [r0, #8]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8004eea:	68c1      	ldr	r1, [r0, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004eec:	fa94 f3a4 	rbit	r3, r4
  return __builtin_clz(value);
 8004ef0:	fab3 f383 	clz	r3, r3
 8004ef4:	005b      	lsls	r3, r3, #1
 8004ef6:	fa06 f303 	lsl.w	r3, r6, r3
 8004efa:	ea21 0303 	bic.w	r3, r1, r3
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004efe:	fa94 f4a4 	rbit	r4, r4
  return __builtin_clz(value);
 8004f02:	fab4 f484 	clz	r4, r4
 8004f06:	0064      	lsls	r4, r4, #1
 8004f08:	fa02 f404 	lsl.w	r4, r2, r4
 8004f0c:	431c      	orrs	r4, r3
 8004f0e:	60c4      	str	r4, [r0, #12]
}
 8004f10:	2000      	movs	r0, #0
 8004f12:	bdf0      	pop	{r4, r5, r6, r7, pc}
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFRH0 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8004f14:	6a47      	ldr	r7, [r0, #36]	; 0x24
 8004f16:	0a26      	lsrs	r6, r4, #8
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004f18:	fa96 fca6 	rbit	ip, r6
  if (value == 0U)
 8004f1c:	f1bc 0f00 	cmp.w	ip, #0
 8004f20:	d001      	beq.n	8004f26 <gpio_stm32_configure+0xea>
  return __builtin_clz(value);
 8004f22:	fabc f58c 	clz	r5, ip
 8004f26:	f04f 0c0f 	mov.w	ip, #15
 8004f2a:	00ad      	lsls	r5, r5, #2
 8004f2c:	fa0c f505 	lsl.w	r5, ip, r5
 8004f30:	ea27 0505 	bic.w	r5, r7, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004f34:	fa96 f6a6 	rbit	r6, r6
  return __builtin_clz(value);
 8004f38:	fab6 f686 	clz	r6, r6
 8004f3c:	00b6      	lsls	r6, r6, #2
 8004f3e:	40b3      	lsls	r3, r6
 8004f40:	432b      	orrs	r3, r5
 8004f42:	6243      	str	r3, [r0, #36]	; 0x24
 8004f44:	e7b1      	b.n	8004eaa <gpio_stm32_configure+0x6e>

08004f46 <spi_stm32_next_tx>:
}

static ALWAYS_INLINE
bool spi_context_tx_buf_on(struct spi_context *ctx)
{
	return !!(ctx->tx_buf && ctx->tx_len);
 8004f46:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8004f48:	b152      	cbz	r2, 8004f60 <spi_stm32_next_tx+0x1a>
 8004f4a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8004f4c:	b153      	cbz	r3, 8004f64 <spi_stm32_next_tx+0x1e>
		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8004f4e:	6803      	ldr	r3, [r0, #0]
 8004f50:	889b      	ldrh	r3, [r3, #4]
 8004f52:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8004f56:	2b08      	cmp	r3, #8
			tx_frame = UNALIGNED_GET((u8_t *)(data->ctx.tx_buf));
 8004f58:	bf0c      	ite	eq
 8004f5a:	7810      	ldrbeq	r0, [r2, #0]
			tx_frame = UNALIGNED_GET((u16_t *)(data->ctx.tx_buf));
 8004f5c:	8810      	ldrhne	r0, [r2, #0]
 8004f5e:	4770      	bx	lr
	u16_t tx_frame = SPI_STM32_TX_NOP;
 8004f60:	4610      	mov	r0, r2
 8004f62:	4770      	bx	lr
 8004f64:	4618      	mov	r0, r3
}
 8004f66:	4770      	bx	lr

08004f68 <spi_stm32_irq_config_func_2>:
		    POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,
		    &api_funcs);

#ifdef CONFIG_SPI_STM32_INTERRUPT
static void spi_stm32_irq_config_func_2(struct device *dev)
{
 8004f68:	b508      	push	{r3, lr}
	IRQ_CONNECT(DT_SPI_2_IRQ, DT_SPI_2_IRQ_PRI,
 8004f6a:	2024      	movs	r0, #36	; 0x24
 8004f6c:	2200      	movs	r2, #0
 8004f6e:	2105      	movs	r1, #5
 8004f70:	f7fd fec8 	bl	8002d04 <z_irq_priority_set>
		    spi_stm32_isr, DEVICE_GET(spi_stm32_2), 0);
	irq_enable(DT_SPI_2_IRQ);
 8004f74:	2024      	movs	r0, #36	; 0x24
}
 8004f76:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(DT_SPI_2_IRQ);
 8004f7a:	f7fd beb3 	b.w	8002ce4 <z_arch_irq_enable>

08004f7e <spi_stm32_get_err.part.5>:
  return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 8004f7e:	6883      	ldr	r3, [r0, #8]
static int spi_stm32_get_err(SPI_TypeDef *spi)
 8004f80:	b082      	sub	sp, #8
 8004f82:	065b      	lsls	r3, r3, #25
 8004f84:	d505      	bpl.n	8004f92 <spi_stm32_get_err.part.5+0x14>
  tmpreg = SPIx->DR;
 8004f86:	68c3      	ldr	r3, [r0, #12]
 8004f88:	9301      	str	r3, [sp, #4]
  (void) tmpreg;
 8004f8a:	9b01      	ldr	r3, [sp, #4]
  tmpreg = SPIx->SR;
 8004f8c:	6883      	ldr	r3, [r0, #8]
 8004f8e:	9301      	str	r3, [sp, #4]
  (void) tmpreg;
 8004f90:	9b01      	ldr	r3, [sp, #4]
}
 8004f92:	f06f 0004 	mvn.w	r0, #4
 8004f96:	b002      	add	sp, #8
 8004f98:	4770      	bx	lr

08004f9a <gpio_pin_write>:
	return api->write(port, access_op, pin, value);
 8004f9a:	6843      	ldr	r3, [r0, #4]
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, u32_t pin,
				 u32_t value)
{
 8004f9c:	b410      	push	{r4}
	return api->write(port, access_op, pin, value);
 8004f9e:	685c      	ldr	r4, [r3, #4]
 8004fa0:	4613      	mov	r3, r2
 8004fa2:	460a      	mov	r2, r1
 8004fa4:	2100      	movs	r1, #0
 8004fa6:	46a4      	mov	ip, r4
	return gpio_write(port, GPIO_ACCESS_BY_PIN, pin, value);
}
 8004fa8:	bc10      	pop	{r4}
	return api->write(port, access_op, pin, value);
 8004faa:	4760      	bx	ip

08004fac <_spi_context_cs_control.isra.6>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
 8004fac:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
 8004fae:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
 8004fb0:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
 8004fb2:	b324      	cbz	r4, 8004ffe <_spi_context_cs_control.isra.6+0x52>
 8004fb4:	68a3      	ldr	r3, [r4, #8]
 8004fb6:	b313      	cbz	r3, 8004ffe <_spi_context_cs_control.isra.6+0x52>
 8004fb8:	6818      	ldr	r0, [r3, #0]
 8004fba:	b300      	cbz	r0, 8004ffe <_spi_context_cs_control.isra.6+0x52>
		if (on) {
 8004fbc:	b161      	cbz	r1, 8004fd8 <_spi_context_cs_control.isra.6+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
 8004fbe:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
 8004fc2:	6859      	ldr	r1, [r3, #4]
 8004fc4:	0fd2      	lsrs	r2, r2, #31
 8004fc6:	f7ff ffe8 	bl	8004f9a <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
 8004fca:	682b      	ldr	r3, [r5, #0]
 8004fcc:	689b      	ldr	r3, [r3, #8]
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_BUSY_WAIT, k_busy_wait, u32_t, usec_to_wait)
 8004fce:	6898      	ldr	r0, [r3, #8]
}
 8004fd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8004fd4:	f7fe be3c 	b.w	8003c50 <z_impl_k_busy_wait>
			if (!force_off &&
 8004fd8:	b912      	cbnz	r2, 8004fe0 <_spi_context_cs_control.isra.6+0x34>
 8004fda:	88a2      	ldrh	r2, [r4, #4]
 8004fdc:	0492      	lsls	r2, r2, #18
 8004fde:	d40e      	bmi.n	8004ffe <_spi_context_cs_control.isra.6+0x52>
 8004fe0:	6898      	ldr	r0, [r3, #8]
 8004fe2:	f7fe fe35 	bl	8003c50 <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
 8004fe6:	682a      	ldr	r2, [r5, #0]
 8004fe8:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
 8004fea:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
 8004fee:	43d2      	mvns	r2, r2
 8004ff0:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004ff4:	0fd2      	lsrs	r2, r2, #31
}
 8004ff6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
 8004ffa:	f7ff bfce 	b.w	8004f9a <gpio_pin_write>
}
 8004ffe:	bd38      	pop	{r3, r4, r5, pc}

08005000 <spi_context_unlock_unconditionally>:
{
 8005000:	b510      	push	{r4, lr}
 8005002:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
 8005004:	2201      	movs	r2, #1
 8005006:	2100      	movs	r1, #0
 8005008:	f7ff ffd0 	bl	8004fac <_spi_context_cs_control.isra.6>
	if (!k_sem_count_get(&ctx->lock)) {
 800500c:	68e3      	ldr	r3, [r4, #12]
 800500e:	b923      	cbnz	r3, 800501a <spi_context_unlock_unconditionally+0x1a>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
 8005010:	1d20      	adds	r0, r4, #4
}
 8005012:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005016:	f7fe bdb9 	b.w	8003b8c <z_impl_k_sem_give>
 800501a:	bd10      	pop	{r4, pc}

0800501c <spi_stm32_release>:
{
 800501c:	b508      	push	{r3, lr}
	spi_context_unlock_unconditionally(&data->ctx);
 800501e:	6880      	ldr	r0, [r0, #8]
 8005020:	f7ff ffee 	bl	8005000 <spi_context_unlock_unconditionally>
}
 8005024:	2000      	movs	r0, #0
 8005026:	bd08      	pop	{r3, pc}

08005028 <spi_stm32_complete>:
  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 8005028:	684b      	ldr	r3, [r1, #4]
 800502a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
{
 800502e:	b570      	push	{r4, r5, r6, lr}
 8005030:	604b      	str	r3, [r1, #4]
 8005032:	4616      	mov	r6, r2
  CLEAR_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
 8005034:	684b      	ldr	r3, [r1, #4]
	_spi_context_cs_control(ctx, on, false);
 8005036:	2200      	movs	r2, #0
 8005038:	460c      	mov	r4, r1
 800503a:	4605      	mov	r5, r0
 800503c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005040:	604b      	str	r3, [r1, #4]
  CLEAR_BIT(SPIx->CR2, SPI_CR2_ERRIE);
 8005042:	684b      	ldr	r3, [r1, #4]
 8005044:	f023 0320 	bic.w	r3, r3, #32
 8005048:	604b      	str	r3, [r1, #4]
 800504a:	4611      	mov	r1, r2
 800504c:	f7ff ffae 	bl	8004fac <_spi_context_cs_control.isra.6>
  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 8005050:	68a3      	ldr	r3, [r4, #8]
 8005052:	07da      	lsls	r2, r3, #31
 8005054:	d501      	bpl.n	800505a <spi_stm32_complete+0x32>
  return (uint8_t)(READ_REG(SPIx->DR));
 8005056:	68e3      	ldr	r3, [r4, #12]
 8005058:	e7fa      	b.n	8005050 <spi_stm32_complete+0x28>
  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 800505a:	6823      	ldr	r3, [r4, #0]
 800505c:	f403 7382 	and.w	r3, r3, #260	; 0x104
	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 8005060:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8005064:	d102      	bne.n	800506c <spi_stm32_complete+0x44>
  return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 8005066:	68a3      	ldr	r3, [r4, #8]
 8005068:	061b      	lsls	r3, r3, #24
 800506a:	d4fc      	bmi.n	8005066 <spi_stm32_complete+0x3e>
  CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 800506c:	6823      	ldr	r3, [r4, #0]
 800506e:	f105 0014 	add.w	r0, r5, #20
 8005072:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005076:	6023      	str	r3, [r4, #0]
	ctx->sync_status = status;
 8005078:	626e      	str	r6, [r5, #36]	; 0x24
}
 800507a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800507e:	f7fe bd85 	b.w	8003b8c <z_impl_k_sem_give>

08005082 <spi_stm32_isr>:
	const struct spi_stm32_config *cfg = dev->config->config_info;
 8005082:	6803      	ldr	r3, [r0, #0]
	SPI_TypeDef *spi = cfg->spi;
 8005084:	689b      	ldr	r3, [r3, #8]
 8005086:	6899      	ldr	r1, [r3, #8]
	u32_t sr = LL_SPI_ReadReg(spi, SR);
 8005088:	688b      	ldr	r3, [r1, #8]
	if (sr & SPI_STM32_ERR_MSK) {
 800508a:	f413 7fb8 	tst.w	r3, #368	; 0x170
{
 800508e:	b570      	push	{r4, r5, r6, lr}
	struct spi_stm32_data *data = dev->driver_data;
 8005090:	6884      	ldr	r4, [r0, #8]
	if (sr & SPI_STM32_ERR_MSK) {
 8005092:	d009      	beq.n	80050a8 <spi_stm32_isr+0x26>
 8005094:	4608      	mov	r0, r1
 8005096:	f7ff ff72 	bl	8004f7e <spi_stm32_get_err.part.5>
	if (err) {
 800509a:	4602      	mov	r2, r0
 800509c:	b120      	cbz	r0, 80050a8 <spi_stm32_isr+0x26>
		spi_stm32_complete(data, spi, err);
 800509e:	4620      	mov	r0, r4
}
 80050a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi_stm32_complete(data, spi, err);
 80050a4:	f7ff bfc0 	b.w	8005028 <spi_stm32_complete>
	return !!(ctx->tx_len);
 80050a8:	6be5      	ldr	r5, [r4, #60]	; 0x3c
	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 80050aa:	b915      	cbnz	r5, 80050b2 <spi_stm32_isr+0x30>
	if (spi_stm32_transfer_ongoing(data)) {
 80050ac:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80050ae:	2a00      	cmp	r2, #0
 80050b0:	d0f5      	beq.n	800509e <spi_stm32_isr+0x1c>
	u16_t operation = data->ctx.config->operation;
 80050b2:	6823      	ldr	r3, [r4, #0]
 80050b4:	889e      	ldrh	r6, [r3, #4]
	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 80050b6:	07f2      	lsls	r2, r6, #31
 80050b8:	f100 8085 	bmi.w	80051c6 <spi_stm32_isr+0x144>
	tx_frame = spi_stm32_next_tx(data);
 80050bc:	4620      	mov	r0, r4
 80050be:	f7ff ff42 	bl	8004f46 <spi_stm32_next_tx>
  return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 80050c2:	688b      	ldr	r3, [r1, #8]
 80050c4:	079b      	lsls	r3, r3, #30
 80050c6:	d5fc      	bpl.n	80050c2 <spi_stm32_isr+0x40>
	if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 80050c8:	f3c6 1645 	ubfx	r6, r6, #5, #6
 80050cc:	2e08      	cmp	r6, #8
 80050ce:	d149      	bne.n	8005164 <spi_stm32_isr+0xe2>
		LL_SPI_TransmitData8(spi, tx_frame);
 80050d0:	b2c0      	uxtb	r0, r0
  */
__STATIC_INLINE void LL_SPI_TransmitData8(SPI_TypeDef *SPIx, uint8_t TxData)
{
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
  *spidr = TxData;
 80050d2:	7308      	strb	r0, [r1, #12]
	if (!ctx->tx_len) {
 80050d4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80050d6:	b183      	cbz	r3, 80050fa <spi_stm32_isr+0x78>
	ctx->tx_len -= len;
 80050d8:	3b01      	subs	r3, #1
 80050da:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
 80050dc:	2b00      	cmp	r3, #0
 80050de:	d13b      	bne.n	8005158 <spi_stm32_isr+0xd6>
		ctx->tx_count--;
 80050e0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80050e2:	3b01      	subs	r3, #1
 80050e4:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
 80050e6:	2b00      	cmp	r3, #0
 80050e8:	d03a      	beq.n	8005160 <spi_stm32_isr+0xde>
			ctx->current_tx++;
 80050ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80050ec:	f103 0208 	add.w	r2, r3, #8
 80050f0:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 80050f2:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
 80050f4:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 80050f6:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
 80050f8:	63e3      	str	r3, [r4, #60]	; 0x3c
  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 80050fa:	688b      	ldr	r3, [r1, #8]
 80050fc:	07d8      	lsls	r0, r3, #31
 80050fe:	d5fc      	bpl.n	80050fa <spi_stm32_isr+0x78>
	if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8005100:	6822      	ldr	r2, [r4, #0]
 8005102:	8892      	ldrh	r2, [r2, #4]
 8005104:	f3c2 1245 	ubfx	r2, r2, #5, #6
 8005108:	2a08      	cmp	r2, #8
  return (uint8_t)(READ_REG(SPIx->DR));
 800510a:	68ca      	ldr	r2, [r1, #12]
 800510c:	e9d4 3010 	ldrd	r3, r0, [r4, #64]	; 0x40
 8005110:	d141      	bne.n	8005196 <spi_stm32_isr+0x114>
}

static ALWAYS_INLINE
bool spi_context_rx_buf_on(struct spi_context *ctx)
{
	return !!(ctx->rx_buf && ctx->rx_len);
 8005112:	b10b      	cbz	r3, 8005118 <spi_stm32_isr+0x96>
 8005114:	b100      	cbz	r0, 8005118 <spi_stm32_isr+0x96>
 8005116:	701a      	strb	r2, [r3, #0]
	if (!ctx->rx_len) {
 8005118:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800511a:	b193      	cbz	r3, 8005142 <spi_stm32_isr+0xc0>
	ctx->rx_len -= len;
 800511c:	3b01      	subs	r3, #1
 800511e:	6463      	str	r3, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
 8005120:	2b00      	cmp	r3, #0
 8005122:	f040 80a2 	bne.w	800526a <spi_stm32_isr+0x1e8>
		ctx->rx_count--;
 8005126:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005128:	3b01      	subs	r3, #1
 800512a:	6363      	str	r3, [r4, #52]	; 0x34
		if (ctx->rx_count) {
 800512c:	2b00      	cmp	r3, #0
 800512e:	f000 80a1 	beq.w	8005274 <spi_stm32_isr+0x1f2>
			ctx->current_rx++;
 8005132:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005134:	f103 0208 	add.w	r2, r3, #8
 8005138:	6322      	str	r2, [r4, #48]	; 0x30
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 800513a:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
 800513c:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 800513e:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_len = ctx->current_rx->len / dfs;
 8005140:	6463      	str	r3, [r4, #68]	; 0x44
	u32_t sr = LL_SPI_ReadReg(spi, SR);
 8005142:	688b      	ldr	r3, [r1, #8]
	if (sr & SPI_STM32_ERR_MSK) {
 8005144:	f413 7fb8 	tst.w	r3, #368	; 0x170
 8005148:	f040 809c 	bne.w	8005284 <spi_stm32_isr+0x202>
	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 800514c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800514e:	b913      	cbnz	r3, 8005156 <spi_stm32_isr+0xd4>
	if (err || !spi_stm32_transfer_ongoing(data)) {
 8005150:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8005152:	2a00      	cmp	r2, #0
 8005154:	d0a3      	beq.n	800509e <spi_stm32_isr+0x1c>
}
 8005156:	bd70      	pop	{r4, r5, r6, pc}
	} else if (ctx->tx_buf) {
 8005158:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800515a:	2b00      	cmp	r3, #0
 800515c:	d0cd      	beq.n	80050fa <spi_stm32_isr+0x78>
		ctx->tx_buf += dfs * len;
 800515e:	3301      	adds	r3, #1
 8005160:	63a3      	str	r3, [r4, #56]	; 0x38
 8005162:	e7ca      	b.n	80050fa <spi_stm32_isr+0x78>
  */
__STATIC_INLINE void LL_SPI_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData)
{
#if defined (__GNUC__)
  __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
  *spidr = TxData;
 8005164:	8188      	strh	r0, [r1, #12]
	if (!ctx->tx_len) {
 8005166:	2d00      	cmp	r5, #0
 8005168:	d0c7      	beq.n	80050fa <spi_stm32_isr+0x78>
	ctx->tx_len -= len;
 800516a:	3d01      	subs	r5, #1
 800516c:	63e5      	str	r5, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
 800516e:	b96d      	cbnz	r5, 800518c <spi_stm32_isr+0x10a>
		ctx->tx_count--;
 8005170:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005172:	3b01      	subs	r3, #1
 8005174:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
 8005176:	2b00      	cmp	r3, #0
 8005178:	d0f2      	beq.n	8005160 <spi_stm32_isr+0xde>
			ctx->current_tx++;
 800517a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800517c:	f103 0208 	add.w	r2, r3, #8
 8005180:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 8005182:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
 8005184:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 8005186:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
 8005188:	085b      	lsrs	r3, r3, #1
 800518a:	e7b5      	b.n	80050f8 <spi_stm32_isr+0x76>
	} else if (ctx->tx_buf) {
 800518c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800518e:	2b00      	cmp	r3, #0
 8005190:	d0b3      	beq.n	80050fa <spi_stm32_isr+0x78>
		ctx->tx_buf += dfs * len;
 8005192:	3302      	adds	r3, #2
 8005194:	e7e4      	b.n	8005160 <spi_stm32_isr+0xde>
	return !!(ctx->rx_buf && ctx->rx_len);
 8005196:	b10b      	cbz	r3, 800519c <spi_stm32_isr+0x11a>
 8005198:	b100      	cbz	r0, 800519c <spi_stm32_isr+0x11a>
			UNALIGNED_PUT(rx_frame, (u16_t *)data->ctx.rx_buf);
 800519a:	801a      	strh	r2, [r3, #0]
	if (!ctx->rx_len) {
 800519c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800519e:	2b00      	cmp	r3, #0
 80051a0:	d0cf      	beq.n	8005142 <spi_stm32_isr+0xc0>
	ctx->rx_len -= len;
 80051a2:	3b01      	subs	r3, #1
 80051a4:	6463      	str	r3, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
 80051a6:	2b00      	cmp	r3, #0
 80051a8:	d166      	bne.n	8005278 <spi_stm32_isr+0x1f6>
		ctx->rx_count--;
 80051aa:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80051ac:	3b01      	subs	r3, #1
 80051ae:	6363      	str	r3, [r4, #52]	; 0x34
		if (ctx->rx_count) {
 80051b0:	2b00      	cmp	r3, #0
 80051b2:	d05f      	beq.n	8005274 <spi_stm32_isr+0x1f2>
			ctx->current_rx++;
 80051b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80051b6:	f103 0208 	add.w	r2, r3, #8
 80051ba:	6322      	str	r2, [r4, #48]	; 0x30
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 80051bc:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
 80051be:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
 80051c0:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_len = ctx->current_rx->len / dfs;
 80051c2:	085b      	lsrs	r3, r3, #1
 80051c4:	e7bc      	b.n	8005140 <spi_stm32_isr+0xbe>
  return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 80051c6:	688b      	ldr	r3, [r1, #8]
 80051c8:	079a      	lsls	r2, r3, #30
 80051ca:	d549      	bpl.n	8005260 <spi_stm32_isr+0x1de>
	if (LL_SPI_IsActiveFlag_TXE(spi) && spi_context_tx_on(&data->ctx)) {
 80051cc:	2d00      	cmp	r5, #0
 80051ce:	d047      	beq.n	8005260 <spi_stm32_isr+0x1de>
		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 80051d0:	f3c6 1645 	ubfx	r6, r6, #5, #6
		u16_t tx_frame = spi_stm32_next_tx(data);
 80051d4:	4620      	mov	r0, r4
 80051d6:	f7ff feb6 	bl	8004f46 <spi_stm32_next_tx>
		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 80051da:	2e08      	cmp	r6, #8
 80051dc:	d129      	bne.n	8005232 <spi_stm32_isr+0x1b0>
			LL_SPI_TransmitData8(spi, tx_frame);
 80051de:	b2c0      	uxtb	r0, r0
  *spidr = TxData;
 80051e0:	7308      	strb	r0, [r1, #12]
	if (!ctx->tx_len) {
 80051e2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80051e4:	b173      	cbz	r3, 8005204 <spi_stm32_isr+0x182>
	ctx->tx_len -= len;
 80051e6:	3b01      	subs	r3, #1
 80051e8:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
 80051ea:	b9e3      	cbnz	r3, 8005226 <spi_stm32_isr+0x1a4>
		ctx->tx_count--;
 80051ec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80051ee:	3b01      	subs	r3, #1
 80051f0:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
 80051f2:	b1e3      	cbz	r3, 800522e <spi_stm32_isr+0x1ac>
			ctx->current_tx++;
 80051f4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80051f6:	f103 0208 	add.w	r2, r3, #8
 80051fa:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 80051fc:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
 80051fe:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 8005200:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
 8005202:	63e3      	str	r3, [r4, #60]	; 0x3c
  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 8005204:	688b      	ldr	r3, [r1, #8]
 8005206:	07db      	lsls	r3, r3, #31
 8005208:	d59b      	bpl.n	8005142 <spi_stm32_isr+0xc0>
	return !!(ctx->rx_buf && ctx->rx_len);
 800520a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800520c:	2b00      	cmp	r3, #0
 800520e:	d098      	beq.n	8005142 <spi_stm32_isr+0xc0>
 8005210:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8005212:	2a00      	cmp	r2, #0
 8005214:	d095      	beq.n	8005142 <spi_stm32_isr+0xc0>
		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8005216:	6822      	ldr	r2, [r4, #0]
 8005218:	8892      	ldrh	r2, [r2, #4]
 800521a:	f3c2 1245 	ubfx	r2, r2, #5, #6
 800521e:	2a08      	cmp	r2, #8
  return (uint8_t)(READ_REG(SPIx->DR));
 8005220:	68ca      	ldr	r2, [r1, #12]
 8005222:	d1ba      	bne.n	800519a <spi_stm32_isr+0x118>
 8005224:	e777      	b.n	8005116 <spi_stm32_isr+0x94>
	} else if (ctx->tx_buf) {
 8005226:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005228:	2b00      	cmp	r3, #0
 800522a:	d0eb      	beq.n	8005204 <spi_stm32_isr+0x182>
		ctx->tx_buf += dfs * len;
 800522c:	3301      	adds	r3, #1
 800522e:	63a3      	str	r3, [r4, #56]	; 0x38
 8005230:	e7e8      	b.n	8005204 <spi_stm32_isr+0x182>
	ctx->tx_len -= len;
 8005232:	3d01      	subs	r5, #1
  *spidr = TxData;
 8005234:	8188      	strh	r0, [r1, #12]
 8005236:	63e5      	str	r5, [r4, #60]	; 0x3c
	if (!ctx->tx_len) {
 8005238:	b96d      	cbnz	r5, 8005256 <spi_stm32_isr+0x1d4>
		ctx->tx_count--;
 800523a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800523c:	3b01      	subs	r3, #1
 800523e:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (ctx->tx_count) {
 8005240:	2b00      	cmp	r3, #0
 8005242:	d0f4      	beq.n	800522e <spi_stm32_isr+0x1ac>
			ctx->current_tx++;
 8005244:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005246:	f103 0208 	add.w	r2, r3, #8
 800524a:	62a2      	str	r2, [r4, #40]	; 0x28
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 800524c:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
 800524e:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
 8005250:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_len = ctx->current_tx->len / dfs;
 8005252:	085b      	lsrs	r3, r3, #1
 8005254:	e7d5      	b.n	8005202 <spi_stm32_isr+0x180>
	} else if (ctx->tx_buf) {
 8005256:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005258:	2b00      	cmp	r3, #0
 800525a:	d0d3      	beq.n	8005204 <spi_stm32_isr+0x182>
		ctx->tx_buf += dfs * len;
 800525c:	3302      	adds	r3, #2
 800525e:	e7e6      	b.n	800522e <spi_stm32_isr+0x1ac>
  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 8005260:	684b      	ldr	r3, [r1, #4]
 8005262:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005266:	604b      	str	r3, [r1, #4]
 8005268:	e7cc      	b.n	8005204 <spi_stm32_isr+0x182>
	} else if (ctx->rx_buf) {
 800526a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800526c:	2b00      	cmp	r3, #0
 800526e:	f43f af68 	beq.w	8005142 <spi_stm32_isr+0xc0>
		ctx->rx_buf += dfs * len;
 8005272:	3301      	adds	r3, #1
 8005274:	6423      	str	r3, [r4, #64]	; 0x40
 8005276:	e764      	b.n	8005142 <spi_stm32_isr+0xc0>
	} else if (ctx->rx_buf) {
 8005278:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800527a:	2b00      	cmp	r3, #0
 800527c:	f43f af61 	beq.w	8005142 <spi_stm32_isr+0xc0>
		ctx->rx_buf += dfs * len;
 8005280:	3302      	adds	r3, #2
 8005282:	e7f7      	b.n	8005274 <spi_stm32_isr+0x1f2>
 8005284:	4608      	mov	r0, r1
 8005286:	f7ff fe7a 	bl	8004f7e <spi_stm32_get_err.part.5>
	if (err || !spi_stm32_transfer_ongoing(data)) {
 800528a:	4602      	mov	r2, r0
 800528c:	2800      	cmp	r0, #0
 800528e:	f47f af06 	bne.w	800509e <spi_stm32_isr+0x1c>
 8005292:	e75b      	b.n	800514c <spi_stm32_isr+0xca>

08005294 <uart_stm32_set_baudrate>:
	const struct uart_stm32_config *config = DEV_CFG(dev);
 8005294:	6803      	ldr	r3, [r0, #0]
{
 8005296:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8005298:	460c      	mov	r4, r1
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 800529a:	6899      	ldr	r1, [r3, #8]
	clock_control_get_rate(data->clock,
 800529c:	6883      	ldr	r3, [r0, #8]
	return api->get_rate(dev, sys, rate);
 800529e:	aa01      	add	r2, sp, #4
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 80052a0:	f851 5b08 	ldr.w	r5, [r1], #8
	clock_control_get_rate(data->clock,
 80052a4:	6858      	ldr	r0, [r3, #4]
 80052a6:	6843      	ldr	r3, [r0, #4]
 80052a8:	68db      	ldr	r3, [r3, #12]
 80052aa:	4798      	blx	r3
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 80052ac:	9901      	ldr	r1, [sp, #4]
 80052ae:	eb01 0154 	add.w	r1, r1, r4, lsr #1
 80052b2:	fbb1 f1f4 	udiv	r1, r1, r4
 80052b6:	b289      	uxth	r1, r1
 80052b8:	60e9      	str	r1, [r5, #12]
}
 80052ba:	b003      	add	sp, #12
 80052bc:	bd30      	pop	{r4, r5, pc}

080052be <uart_stm32_poll_out>:
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 80052be:	6803      	ldr	r3, [r0, #0]
 80052c0:	689b      	ldr	r3, [r3, #8]
 80052c2:	681b      	ldr	r3, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_TXE) == (USART_ISR_TXE)) ? 1UL : 0UL);
 80052c4:	69da      	ldr	r2, [r3, #28]
 80052c6:	0612      	lsls	r2, r2, #24
 80052c8:	d5fc      	bpl.n	80052c4 <uart_stm32_poll_out+0x6>
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80052ca:	2240      	movs	r2, #64	; 0x40
 80052cc:	621a      	str	r2, [r3, #32]
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
  USARTx->TDR = Value;
 80052ce:	6299      	str	r1, [r3, #40]	; 0x28
}
 80052d0:	4770      	bx	lr

080052d2 <uart_stm32_err_check>:
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 80052d2:	6803      	ldr	r3, [r0, #0]
 80052d4:	689b      	ldr	r3, [r3, #8]
 80052d6:	681b      	ldr	r3, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 80052d8:	69d8      	ldr	r0, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_PE) == (USART_ISR_PE)) ? 1UL : 0UL);
 80052da:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 80052dc:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  return ((READ_BIT(USARTx->ISR, USART_ISR_PE) == (USART_ISR_PE)) ? 1UL : 0UL);
 80052e0:	07d2      	lsls	r2, r2, #31
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 80052e2:	69da      	ldr	r2, [r3, #28]
		err |= UART_ERROR_PARITY;
 80052e4:	bf48      	it	mi
 80052e6:	f040 0002 	orrmi.w	r0, r0, #2
 80052ea:	0791      	lsls	r1, r2, #30
		err |= UART_ERROR_FRAMING;
 80052ec:	bf48      	it	mi
 80052ee:	f040 0004 	orrmi.w	r0, r0, #4
	if (err & UART_ERROR_OVERRUN) {
 80052f2:	07c2      	lsls	r2, r0, #31
 80052f4:	d501      	bpl.n	80052fa <uart_stm32_err_check+0x28>
  WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
 80052f6:	2208      	movs	r2, #8
 80052f8:	621a      	str	r2, [r3, #32]
	if (err & UART_ERROR_PARITY) {
 80052fa:	0781      	lsls	r1, r0, #30
 80052fc:	d501      	bpl.n	8005302 <uart_stm32_err_check+0x30>
  WRITE_REG(USARTx->ICR, USART_ICR_PECF);
 80052fe:	2201      	movs	r2, #1
 8005300:	621a      	str	r2, [r3, #32]
	if (err & UART_ERROR_FRAMING) {
 8005302:	0742      	lsls	r2, r0, #29
 8005304:	d501      	bpl.n	800530a <uart_stm32_err_check+0x38>
  WRITE_REG(USARTx->ICR, USART_ICR_FECF);
 8005306:	2202      	movs	r2, #2
 8005308:	621a      	str	r2, [r3, #32]
  WRITE_REG(USARTx->ICR, USART_ICR_NCF);
 800530a:	2204      	movs	r2, #4
 800530c:	621a      	str	r2, [r3, #32]
}
 800530e:	4770      	bx	lr

08005310 <uart_stm32_poll_in>:
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 8005310:	6803      	ldr	r3, [r0, #0]
 8005312:	689b      	ldr	r3, [r3, #8]
 8005314:	681b      	ldr	r3, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8005316:	69da      	ldr	r2, [r3, #28]
 8005318:	0710      	lsls	r0, r2, #28
 800531a:	d501      	bpl.n	8005320 <uart_stm32_poll_in+0x10>
  WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
 800531c:	2208      	movs	r2, #8
 800531e:	621a      	str	r2, [r3, #32]
  return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE)) ? 1UL : 0UL);
 8005320:	69da      	ldr	r2, [r3, #28]
 8005322:	0692      	lsls	r2, r2, #26
 8005324:	d503      	bpl.n	800532e <uart_stm32_poll_in+0x1e>
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
 8005326:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	return 0;
 8005328:	2000      	movs	r0, #0
 800532a:	700b      	strb	r3, [r1, #0]
 800532c:	4770      	bx	lr
		return -1;
 800532e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8005332:	4770      	bx	lr

08005334 <uart_stm32_config_get>:
	cfg->baudrate = data->baud_rate;
 8005334:	6883      	ldr	r3, [r0, #8]
 8005336:	681b      	ldr	r3, [r3, #0]
 8005338:	600b      	str	r3, [r1, #0]
	USART_TypeDef *UartInstance = UART_STRUCT(dev);
 800533a:	6803      	ldr	r3, [r0, #0]
 800533c:	689b      	ldr	r3, [r3, #8]
 800533e:	681a      	ldr	r2, [r3, #0]
  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 8005340:	6813      	ldr	r3, [r2, #0]
 8005342:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
	switch (parity) {
 8005346:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800534a:	d028      	beq.n	800539e <uart_stm32_config_get+0x6a>
		return UART_CFG_PARITY_NONE;
 800534c:	f5a3 60c0 	sub.w	r0, r3, #1536	; 0x600
 8005350:	4243      	negs	r3, r0
 8005352:	4143      	adcs	r3, r0
	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 8005354:	710b      	strb	r3, [r1, #4]
  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 8005356:	6853      	ldr	r3, [r2, #4]
 8005358:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
	switch (sb) {
 800535c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005360:	d01f      	beq.n	80053a2 <uart_stm32_config_get+0x6e>
 8005362:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8005366:	d01e      	beq.n	80053a6 <uart_stm32_config_get+0x72>
 8005368:	2b00      	cmp	r3, #0
		return UART_CFG_STOP_BITS_2;
 800536a:	bf0c      	ite	eq
 800536c:	2301      	moveq	r3, #1
 800536e:	2303      	movne	r3, #3
	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 8005370:	714b      	strb	r3, [r1, #5]
  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8005372:	6813      	ldr	r3, [r2, #0]
 8005374:	f003 2310 	and.w	r3, r3, #268439552	; 0x10001000
	switch (db) {
 8005378:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800537c:	d015      	beq.n	80053aa <uart_stm32_config_get+0x76>
 800537e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
		return UART_CFG_DATA_BITS_8;
 8005382:	bf0c      	ite	eq
 8005384:	2302      	moveq	r3, #2
 8005386:	2303      	movne	r3, #3
	cfg->data_bits = uart_stm32_ll2cfg_databits(
 8005388:	718b      	strb	r3, [r1, #6]
}
 800538a:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 800538c:	6893      	ldr	r3, [r2, #8]
 800538e:	f403 7340 	and.w	r3, r3, #768	; 0x300
	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 8005392:	f5a3 7240 	sub.w	r2, r3, #768	; 0x300
 8005396:	4253      	negs	r3, r2
 8005398:	4153      	adcs	r3, r2
 800539a:	71cb      	strb	r3, [r1, #7]
}
 800539c:	4770      	bx	lr
		return UART_CFG_PARITY_EVEN;
 800539e:	2302      	movs	r3, #2
 80053a0:	e7d8      	b.n	8005354 <uart_stm32_config_get+0x20>
		return UART_CFG_STOP_BITS_0_5;
 80053a2:	2300      	movs	r3, #0
 80053a4:	e7e4      	b.n	8005370 <uart_stm32_config_get+0x3c>
		return UART_CFG_STOP_BITS_1_5;
 80053a6:	2302      	movs	r3, #2
 80053a8:	e7e2      	b.n	8005370 <uart_stm32_config_get+0x3c>
		return UART_CFG_DATA_BITS_9;
 80053aa:	2304      	movs	r3, #4
 80053ac:	e7ec      	b.n	8005388 <uart_stm32_config_get+0x54>

080053ae <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 80053ae:	7b43      	ldrb	r3, [r0, #13]
 80053b0:	06db      	lsls	r3, r3, #27
 80053b2:	bf03      	ittte	eq
 80053b4:	6980      	ldreq	r0, [r0, #24]
 80053b6:	fab0 f080 	clzeq	r0, r0
 80053ba:	0940      	lsreq	r0, r0, #5
 80053bc:	2000      	movne	r0, #0
}
 80053be:	4770      	bx	lr

080053c0 <z_unpend_thread_no_timeout>:
{
 80053c0:	b538      	push	{r3, r4, r5, lr}
 80053c2:	4604      	mov	r4, r0
	__asm__ volatile(
 80053c4:	f04f 0310 	mov.w	r3, #16
 80053c8:	f3ef 8511 	mrs	r5, BASEPRI
 80053cc:	f383 8811 	msr	BASEPRI, r3
 80053d0:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 80053d4:	4601      	mov	r1, r0
 80053d6:	6880      	ldr	r0, [r0, #8]
 80053d8:	f7fe f9e4 	bl	80037a4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 80053dc:	7b63      	ldrb	r3, [r4, #13]
 80053de:	f023 0302 	bic.w	r3, r3, #2
 80053e2:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
 80053e4:	f385 8811 	msr	BASEPRI, r5
 80053e8:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
 80053ec:	2300      	movs	r3, #0
 80053ee:	60a3      	str	r3, [r4, #8]
}
 80053f0:	bd38      	pop	{r3, r4, r5, pc}

080053f2 <z_reschedule>:
{
 80053f2:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_is_in_isr();
 80053f4:	b939      	cbnz	r1, 8005406 <z_reschedule+0x14>
 80053f6:	f7fe f991 	bl	800371c <resched.part.15>
	if (resched(key.key)) {
 80053fa:	b120      	cbz	r0, 8005406 <z_reschedule+0x14>
 80053fc:	4608      	mov	r0, r1
}
 80053fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005402:	f7fd bad1 	b.w	80029a8 <__swap>
 8005406:	f381 8811 	msr	BASEPRI, r1
 800540a:	f3bf 8f6f 	isb	sy
 800540e:	bd08      	pop	{r3, pc}

08005410 <z_reschedule_irqlock>:
{
 8005410:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_is_in_isr();
 8005412:	4602      	mov	r2, r0
 8005414:	b938      	cbnz	r0, 8005426 <z_reschedule_irqlock+0x16>
 8005416:	f7fe f981 	bl	800371c <resched.part.15>
	if (resched(key)) {
 800541a:	b120      	cbz	r0, 8005426 <z_reschedule_irqlock+0x16>
 800541c:	4610      	mov	r0, r2
}
 800541e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005422:	f7fd bac1 	b.w	80029a8 <__swap>
 8005426:	f382 8811 	msr	BASEPRI, r2
 800542a:	f3bf 8f6f 	isb	sy
 800542e:	bd08      	pop	{r3, pc}

08005430 <z_reschedule_unlocked>:
	__asm__ volatile(
 8005430:	f04f 0310 	mov.w	r3, #16
 8005434:	f3ef 8011 	mrs	r0, BASEPRI
 8005438:	f383 8811 	msr	BASEPRI, r3
 800543c:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(z_arch_irq_lock());
 8005440:	f7ff bfe6 	b.w	8005410 <z_reschedule_irqlock>

08005444 <z_priq_dumb_best>:
	return list->head == list;
 8005444:	6803      	ldr	r3, [r0, #0]
}
 8005446:	4298      	cmp	r0, r3
 8005448:	bf14      	ite	ne
 800544a:	4618      	movne	r0, r3
 800544c:	2000      	moveq	r0, #0
 800544e:	4770      	bx	lr

08005450 <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
 8005450:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
 8005454:	b570      	push	{r4, r5, r6, lr}
 8005456:	4604      	mov	r4, r0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
 8005458:	f1a0 0518 	sub.w	r5, r0, #24
	if (th->base.pended_on != NULL) {
 800545c:	b1cb      	cbz	r3, 8005492 <z_thread_timeout+0x42>
 800545e:	f04f 0310 	mov.w	r3, #16
 8005462:	f3ef 8611 	mrs	r6, BASEPRI
 8005466:	f383 8811 	msr	BASEPRI, r3
 800546a:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 800546e:	4629      	mov	r1, r5
 8005470:	f850 0c10 	ldr.w	r0, [r0, #-16]
 8005474:	f7fe f996 	bl	80037a4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 8005478:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
 800547c:	f023 0302 	bic.w	r3, r3, #2
 8005480:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
 8005484:	f386 8811 	msr	BASEPRI, r6
 8005488:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
 800548c:	2300      	movs	r3, #0
 800548e:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8005492:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
 8005496:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8005498:	f023 0314 	bic.w	r3, r3, #20
 800549c:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
 80054a0:	f7ff ff85 	bl	80053ae <z_is_thread_ready>
 80054a4:	b120      	cbz	r0, 80054b0 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
 80054a6:	4628      	mov	r0, r5
}
 80054a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80054ac:	f7fe b9ca 	b.w	8003844 <z_add_thread_to_ready_q>
 80054b0:	bd70      	pop	{r4, r5, r6, pc}

080054b2 <z_unpend_first_thread>:
{
 80054b2:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
 80054b4:	f04f 0310 	mov.w	r3, #16
 80054b8:	f3ef 8211 	mrs	r2, BASEPRI
 80054bc:	f383 8811 	msr	BASEPRI, r3
 80054c0:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
 80054c4:	f7ff ffbe 	bl	8005444 <z_priq_dumb_best>
 80054c8:	4604      	mov	r4, r0
	__asm__ volatile(
 80054ca:	f382 8811 	msr	BASEPRI, r2
 80054ce:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
 80054d2:	b1c8      	cbz	r0, 8005508 <z_unpend_first_thread+0x56>
	__asm__ volatile(
 80054d4:	f04f 0310 	mov.w	r3, #16
 80054d8:	f3ef 8511 	mrs	r5, BASEPRI
 80054dc:	f383 8811 	msr	BASEPRI, r3
 80054e0:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 80054e4:	4601      	mov	r1, r0
 80054e6:	6880      	ldr	r0, [r0, #8]
 80054e8:	f7fe f95c 	bl	80037a4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 80054ec:	7b63      	ldrb	r3, [r4, #13]
 80054ee:	f023 0302 	bic.w	r3, r3, #2
 80054f2:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
 80054f4:	f385 8811 	msr	BASEPRI, r5
 80054f8:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
 80054fc:	2300      	movs	r3, #0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 80054fe:	f104 0018 	add.w	r0, r4, #24
 8005502:	60a3      	str	r3, [r4, #8]
 8005504:	f000 f845 	bl	8005592 <z_abort_timeout>
}
 8005508:	4620      	mov	r0, r4
 800550a:	bd38      	pop	{r3, r4, r5, pc}

0800550c <z_impl_k_sleep>:
{
 800550c:	b510      	push	{r4, lr}
	if (ticks == 0) {
 800550e:	4604      	mov	r4, r0
 8005510:	b958      	cbnz	r0, 800552a <z_impl_k_sleep+0x1e>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
 8005512:	f7fe faeb 	bl	8003aec <z_impl_k_yield>
}

static inline u64_t __ticks_to_ms(s64_t ticks)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	return (u64_t)ticks * MSEC_PER_SEC /
 8005516:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800551a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800551e:	2300      	movs	r3, #0
 8005520:	fb84 0100 	smull	r0, r1, r4, r0
 8005524:	f7fa fe68 	bl	80001f8 <__aeabi_uldivmod>
}
 8005528:	bd10      	pop	{r4, pc}
 800552a:	f7fe faa5 	bl	8003a78 <z_tick_sleep.part.16>
 800552e:	4604      	mov	r4, r0
 8005530:	e7f1      	b.n	8005516 <z_impl_k_sleep+0xa>

08005532 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 8005532:	7b43      	ldrb	r3, [r0, #13]
 8005534:	06db      	lsls	r3, r3, #27
 8005536:	bf03      	ittte	eq
 8005538:	6980      	ldreq	r0, [r0, #24]
 800553a:	fab0 f080 	clzeq	r0, r0
 800553e:	0940      	lsreq	r0, r0, #5
 8005540:	2000      	movne	r0, #0
}
 8005542:	4770      	bx	lr

08005544 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
 8005544:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
 8005546:	b510      	push	{r4, lr}
 8005548:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
 800554a:	b103      	cbz	r3, 800554e <z_thread_single_abort+0xa>
		thread->fn_abort();
 800554c:	4798      	blx	r3
	if (z_is_thread_ready(thread)) {
 800554e:	4620      	mov	r0, r4
 8005550:	f7ff ffef 	bl	8005532 <z_is_thread_ready>
 8005554:	b138      	cbz	r0, 8005566 <z_thread_single_abort+0x22>
		z_remove_thread_from_ready_q(thread);
 8005556:	4620      	mov	r0, r4
 8005558:	f7fe fa1e 	bl	8003998 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_DEAD;
 800555c:	7b63      	ldrb	r3, [r4, #13]
 800555e:	f043 0308 	orr.w	r3, r3, #8
 8005562:	7363      	strb	r3, [r4, #13]
}
 8005564:	bd10      	pop	{r4, pc}
		if (z_is_thread_pending(thread)) {
 8005566:	7b63      	ldrb	r3, [r4, #13]
 8005568:	079b      	lsls	r3, r3, #30
 800556a:	d502      	bpl.n	8005572 <z_thread_single_abort+0x2e>
			z_unpend_thread_no_timeout(thread);
 800556c:	4620      	mov	r0, r4
 800556e:	f7ff ff27 	bl	80053c0 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
 8005572:	69a3      	ldr	r3, [r4, #24]
 8005574:	2b00      	cmp	r3, #0
 8005576:	d0f1      	beq.n	800555c <z_thread_single_abort+0x18>
 8005578:	f104 0018 	add.w	r0, r4, #24
 800557c:	f000 f809 	bl	8005592 <z_abort_timeout>
 8005580:	e7ec      	b.n	800555c <z_thread_single_abort+0x18>

08005582 <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
 8005582:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
 8005584:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
 8005586:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
 8005588:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
 800558a:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
 800558c:	e9c0 3306 	strd	r3, r3, [r0, #24]

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
 8005590:	4770      	bx	lr

08005592 <z_abort_timeout>:
{
 8005592:	b510      	push	{r4, lr}
	__asm__ volatile(
 8005594:	f04f 0210 	mov.w	r2, #16
 8005598:	f3ef 8411 	mrs	r4, BASEPRI
 800559c:	f382 8811 	msr	BASEPRI, r2
 80055a0:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
 80055a4:	6803      	ldr	r3, [r0, #0]
 80055a6:	b13b      	cbz	r3, 80055b8 <z_abort_timeout+0x26>
			remove_timeout(to);
 80055a8:	f7fe fbf4 	bl	8003d94 <remove_timeout>
			ret = 0;
 80055ac:	2000      	movs	r0, #0
	__asm__ volatile(
 80055ae:	f384 8811 	msr	BASEPRI, r4
 80055b2:	f3bf 8f6f 	isb	sy
}
 80055b6:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
 80055b8:	f06f 0015 	mvn.w	r0, #21
 80055bc:	e7f7      	b.n	80055ae <z_abort_timeout+0x1c>

080055be <z_get_next_timeout_expiry>:
{
 80055be:	b510      	push	{r4, lr}
	__asm__ volatile(
 80055c0:	f04f 0310 	mov.w	r3, #16
 80055c4:	f3ef 8411 	mrs	r4, BASEPRI
 80055c8:	f383 8811 	msr	BASEPRI, r3
 80055cc:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
 80055d0:	f7fe fbf4 	bl	8003dbc <next_timeout>
	__asm__ volatile(
 80055d4:	f384 8811 	msr	BASEPRI, r4
 80055d8:	f3bf 8f6f 	isb	sy
}
 80055dc:	bd10      	pop	{r4, pc}

080055de <z_set_timeout_expiry>:
{
 80055de:	b570      	push	{r4, r5, r6, lr}
 80055e0:	4604      	mov	r4, r0
 80055e2:	460e      	mov	r6, r1
	__asm__ volatile(
 80055e4:	f04f 0310 	mov.w	r3, #16
 80055e8:	f3ef 8511 	mrs	r5, BASEPRI
 80055ec:	f383 8811 	msr	BASEPRI, r3
 80055f0:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
 80055f4:	f7fe fbe2 	bl	8003dbc <next_timeout>
		if (sooner && !imminent) {
 80055f8:	42a0      	cmp	r0, r4
 80055fa:	dd05      	ble.n	8005608 <z_set_timeout_expiry+0x2a>
 80055fc:	2801      	cmp	r0, #1
 80055fe:	dd03      	ble.n	8005608 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
 8005600:	4631      	mov	r1, r6
 8005602:	4620      	mov	r0, r4
 8005604:	f7fb fd70 	bl	80010e8 <z_clock_set_timeout>
	__asm__ volatile(
 8005608:	f385 8811 	msr	BASEPRI, r5
 800560c:	f3bf 8f6f 	isb	sy
}
 8005610:	bd70      	pop	{r4, r5, r6, pc}

08005612 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
 8005612:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
 8005614:	f7fe fc8a 	bl	8003f2c <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
 8005618:	bd08      	pop	{r3, pc}

0800561a <z_impl_k_uptime_get_32>:

u32_t z_impl_k_uptime_get_32(void)
{
 800561a:	b508      	push	{r3, lr}
	return __ticks_to_ms(z_tick_get_32());
 800561c:	f7ff fff9 	bl	8005612 <z_tick_get_32>
 8005620:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005624:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005628:	2300      	movs	r3, #0
 800562a:	fba0 0101 	umull	r0, r1, r0, r1
 800562e:	f7fa fde3 	bl	80001f8 <__aeabi_uldivmod>
}
 8005632:	bd08      	pop	{r3, pc}

08005634 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
 8005634:	b508      	push	{r3, lr}
	__asm__ volatile(
 8005636:	f04f 0210 	mov.w	r2, #16
 800563a:	f3ef 8311 	mrs	r3, BASEPRI
 800563e:	f382 8811 	msr	BASEPRI, r2
 8005642:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
 8005646:	f7ff ffba 	bl	80055be <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
 800564a:	2101      	movs	r1, #1
 800564c:	2802      	cmp	r0, #2
 800564e:	bfd8      	it	le
 8005650:	4608      	movle	r0, r1
 8005652:	f7ff ffc4 	bl	80055de <z_set_timeout_expiry>
	k_cpu_idle();
 8005656:	f7fd fb95 	bl	8002d84 <k_cpu_idle>
 800565a:	e7ec      	b.n	8005636 <idle+0x2>

0800565c <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
 800565c:	4770      	bx	lr
